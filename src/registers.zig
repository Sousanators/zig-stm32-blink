pub fn Register(comptime R: type) type {
    return RegisterRW(R, R);
}

pub fn RegisterRW(comptime Read: type, comptime Write: type) type {
    return struct {
        raw_ptr: *volatile u32,

        const Self = @This();

        pub fn init(address: usize) Self {
            const ptr: *volatile u32 = @ptrFromInt(address);
            return Self{ .raw_ptr = ptr };
        }

        pub fn initRange(address: usize, comptime dim_increment: usize, comptime num_registers: usize) [num_registers]Self {
            var registers: [num_registers]Self = undefined;
            var i: usize = 0;
            while (i < num_registers) : (i += 1) {
                registers[i] = Self.init(address + (i * dim_increment));
            }
            return registers;
        }

        pub inline fn read(self: Self) Read {
            return @bitCast(self.raw_ptr.*);
        }

        pub fn write(self: Self, value: Write) void {
            // Forcing the alignment is a workaround for stores through
            // volatile pointers generating multiple loads and stores.
            // This is necessary for LLVM to generate code that can successfully
            // modify MMIO registers that only allow word-sized stores.
            // https://github.com/ziglang/zig/issues/8981#issuecomment-854911077
            const aligned: Write align(4) = value;
            const ptr: *const u32 = @ptrCast(&aligned);
            self.raw_ptr.* = ptr.*;
        }

        pub fn modify(self: Self, new_value: anytype) void {
            if (Read != Write) {
                @compileError("Can't modify because read and write types for this register aren't the same.");
            }
            var old_value = self.read();
            const info = @typeInfo(@TypeOf(new_value));
            inline for (info.Struct.fields) |field| {
                @field(old_value, field.name) = @field(new_value, field.name);
            }
            self.write(old_value);
        }

        pub inline fn read_raw(self: Self) u32 {
            return self.raw_ptr.*;
        }

        pub inline fn write_raw(self: Self, value: u32) void {
            self.raw_ptr.* = value;
        }

        pub fn default_read_value(_: Self) Read {
            return Read{};
        }

        pub fn default_write_value(_: Self) Write {
            return Write{};
        }
    };
}

pub const device_name = "STM32F767";
pub const device_revision = "1.6";
pub const device_description = "STM32F767";

pub const cpu = struct {
    pub const name = "CM7";
    pub const revision = "r0p1";
    pub const endian = "little";
    pub const mpu_present = true;
    pub const fpu_present = true;
    pub const vendor_systick_config = false;
    pub const nvic_prio_bits = 4;
};

/// Random number generator
pub const RNG = struct {
    const base_address = 0x50060800;
    /// CR
    const CR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// RNGEN [2:2]
        /// Random number generator
        RNGEN: u1 = 0,
        /// IE [3:3]
        /// Interrupt enable
        IE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// SR
    const SR_val = packed struct {
        /// DRDY [0:0]
        /// Data ready
        DRDY: u1 = 0,
        /// CECS [1:1]
        /// Clock error current status
        CECS: u1 = 0,
        /// SECS [2:2]
        /// Seed error current status
        SECS: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// CEIS [5:5]
        /// Clock error interrupt
        CEIS: u1 = 0,
        /// SEIS [6:6]
        /// Seed error interrupt
        SEIS: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x4);

    /// DR
    const DR_val = packed struct {
        /// RNDATA [0:31]
        /// Random data
        RNDATA: u32 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0x8);
};

/// Hash processor
pub const HASH = struct {
    const base_address = 0x50060400;
    /// CR
    const CR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// INIT [2:2]
        /// Initialize message digest
        INIT: u1 = 0,
        /// DMAE [3:3]
        /// DMA enable
        DMAE: u1 = 0,
        /// DATATYPE [4:5]
        /// Data type selection
        DATATYPE: u2 = 0,
        /// MODE [6:6]
        /// Mode selection
        MODE: u1 = 0,
        /// ALGO0 [7:7]
        /// Algorithm selection
        ALGO0: u1 = 0,
        /// NBW [8:11]
        /// Number of words already
        NBW: u4 = 0,
        /// DINNE [12:12]
        /// DIN not empty
        DINNE: u1 = 0,
        /// MDMAT [13:13]
        /// Multiple DMA Transfers
        MDMAT: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// LKEY [16:16]
        /// Long key selection
        LKEY: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// ALGO1 [18:18]
        /// ALGO
        ALGO1: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// DIN
    const DIN_val = packed struct {
        /// DATAIN [0:31]
        /// Data input
        DATAIN: u32 = 0,
    };
    /// data input register
    pub const DIN = Register(DIN_val).init(base_address + 0x4);

    /// STR
    const STR_val = packed struct {
        /// NBLW [0:4]
        /// Number of valid bits in the last word of
        NBLW: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DCAL [8:8]
        /// Digest calculation
        DCAL: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// start register
    pub const STR = Register(STR_val).init(base_address + 0x8);

    /// HR0
    const HR0_val = packed struct {
        /// H0 [0:31]
        /// H0
        H0: u32 = 0,
    };
    /// digest registers
    pub const HR0 = Register(HR0_val).init(base_address + 0xc);

    /// HR1
    const HR1_val = packed struct {
        /// H1 [0:31]
        /// H1
        H1: u32 = 0,
    };
    /// digest registers
    pub const HR1 = Register(HR1_val).init(base_address + 0x10);

    /// HR2
    const HR2_val = packed struct {
        /// H2 [0:31]
        /// H2
        H2: u32 = 0,
    };
    /// digest registers
    pub const HR2 = Register(HR2_val).init(base_address + 0x14);

    /// HR3
    const HR3_val = packed struct {
        /// H3 [0:31]
        /// H3
        H3: u32 = 0,
    };
    /// digest registers
    pub const HR3 = Register(HR3_val).init(base_address + 0x18);

    /// HR4
    const HR4_val = packed struct {
        /// H4 [0:31]
        /// H4
        H4: u32 = 0,
    };
    /// digest registers
    pub const HR4 = Register(HR4_val).init(base_address + 0x1c);

    /// IMR
    const IMR_val = packed struct {
        /// DINIE [0:0]
        /// Data input interrupt
        DINIE: u1 = 0,
        /// DCIE [1:1]
        /// Digest calculation completion interrupt
        DCIE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IMR = Register(IMR_val).init(base_address + 0x20);

    /// SR
    const SR_val = packed struct {
        /// DINIS [0:0]
        /// Data input interrupt
        DINIS: u1 = 1,
        /// DCIS [1:1]
        /// Digest calculation completion interrupt
        DCIS: u1 = 0,
        /// DMAS [2:2]
        /// DMA Status
        DMAS: u1 = 0,
        /// BUSY [3:3]
        /// Busy bit
        BUSY: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x24);

    /// CSR0
    const CSR0_val = packed struct {
        /// CSR0 [0:31]
        /// CSR0
        CSR0: u32 = 0,
    };
    /// context swap registers
    pub const CSR0 = Register(CSR0_val).init(base_address + 0xf8);

    /// CSR1
    const CSR1_val = packed struct {
        /// CSR1 [0:31]
        /// CSR1
        CSR1: u32 = 0,
    };
    /// context swap registers
    pub const CSR1 = Register(CSR1_val).init(base_address + 0xfc);

    /// CSR2
    const CSR2_val = packed struct {
        /// CSR2 [0:31]
        /// CSR2
        CSR2: u32 = 0,
    };
    /// context swap registers
    pub const CSR2 = Register(CSR2_val).init(base_address + 0x100);

    /// CSR3
    const CSR3_val = packed struct {
        /// CSR3 [0:31]
        /// CSR3
        CSR3: u32 = 0,
    };
    /// context swap registers
    pub const CSR3 = Register(CSR3_val).init(base_address + 0x104);

    /// CSR4
    const CSR4_val = packed struct {
        /// CSR4 [0:31]
        /// CSR4
        CSR4: u32 = 0,
    };
    /// context swap registers
    pub const CSR4 = Register(CSR4_val).init(base_address + 0x108);

    /// CSR5
    const CSR5_val = packed struct {
        /// CSR5 [0:31]
        /// CSR5
        CSR5: u32 = 0,
    };
    /// context swap registers
    pub const CSR5 = Register(CSR5_val).init(base_address + 0x10c);

    /// CSR6
    const CSR6_val = packed struct {
        /// CSR6 [0:31]
        /// CSR6
        CSR6: u32 = 0,
    };
    /// context swap registers
    pub const CSR6 = Register(CSR6_val).init(base_address + 0x110);

    /// CSR7
    const CSR7_val = packed struct {
        /// CSR7 [0:31]
        /// CSR7
        CSR7: u32 = 0,
    };
    /// context swap registers
    pub const CSR7 = Register(CSR7_val).init(base_address + 0x114);

    /// CSR8
    const CSR8_val = packed struct {
        /// CSR8 [0:31]
        /// CSR8
        CSR8: u32 = 0,
    };
    /// context swap registers
    pub const CSR8 = Register(CSR8_val).init(base_address + 0x118);

    /// CSR9
    const CSR9_val = packed struct {
        /// CSR9 [0:31]
        /// CSR9
        CSR9: u32 = 0,
    };
    /// context swap registers
    pub const CSR9 = Register(CSR9_val).init(base_address + 0x11c);

    /// CSR10
    const CSR10_val = packed struct {
        /// CSR10 [0:31]
        /// CSR10
        CSR10: u32 = 0,
    };
    /// context swap registers
    pub const CSR10 = Register(CSR10_val).init(base_address + 0x120);

    /// CSR11
    const CSR11_val = packed struct {
        /// CSR11 [0:31]
        /// CSR11
        CSR11: u32 = 0,
    };
    /// context swap registers
    pub const CSR11 = Register(CSR11_val).init(base_address + 0x124);

    /// CSR12
    const CSR12_val = packed struct {
        /// CSR12 [0:31]
        /// CSR12
        CSR12: u32 = 0,
    };
    /// context swap registers
    pub const CSR12 = Register(CSR12_val).init(base_address + 0x128);

    /// CSR13
    const CSR13_val = packed struct {
        /// CSR13 [0:31]
        /// CSR13
        CSR13: u32 = 0,
    };
    /// context swap registers
    pub const CSR13 = Register(CSR13_val).init(base_address + 0x12c);

    /// CSR14
    const CSR14_val = packed struct {
        /// CSR14 [0:31]
        /// CSR14
        CSR14: u32 = 0,
    };
    /// context swap registers
    pub const CSR14 = Register(CSR14_val).init(base_address + 0x130);

    /// CSR15
    const CSR15_val = packed struct {
        /// CSR15 [0:31]
        /// CSR15
        CSR15: u32 = 0,
    };
    /// context swap registers
    pub const CSR15 = Register(CSR15_val).init(base_address + 0x134);

    /// CSR16
    const CSR16_val = packed struct {
        /// CSR16 [0:31]
        /// CSR16
        CSR16: u32 = 0,
    };
    /// context swap registers
    pub const CSR16 = Register(CSR16_val).init(base_address + 0x138);

    /// CSR17
    const CSR17_val = packed struct {
        /// CSR17 [0:31]
        /// CSR17
        CSR17: u32 = 0,
    };
    /// context swap registers
    pub const CSR17 = Register(CSR17_val).init(base_address + 0x13c);

    /// CSR18
    const CSR18_val = packed struct {
        /// CSR18 [0:31]
        /// CSR18
        CSR18: u32 = 0,
    };
    /// context swap registers
    pub const CSR18 = Register(CSR18_val).init(base_address + 0x140);

    /// CSR19
    const CSR19_val = packed struct {
        /// CSR19 [0:31]
        /// CSR19
        CSR19: u32 = 0,
    };
    /// context swap registers
    pub const CSR19 = Register(CSR19_val).init(base_address + 0x144);

    /// CSR20
    const CSR20_val = packed struct {
        /// CSR20 [0:31]
        /// CSR20
        CSR20: u32 = 0,
    };
    /// context swap registers
    pub const CSR20 = Register(CSR20_val).init(base_address + 0x148);

    /// CSR21
    const CSR21_val = packed struct {
        /// CSR21 [0:31]
        /// CSR21
        CSR21: u32 = 0,
    };
    /// context swap registers
    pub const CSR21 = Register(CSR21_val).init(base_address + 0x14c);

    /// CSR22
    const CSR22_val = packed struct {
        /// CSR22 [0:31]
        /// CSR22
        CSR22: u32 = 0,
    };
    /// context swap registers
    pub const CSR22 = Register(CSR22_val).init(base_address + 0x150);

    /// CSR23
    const CSR23_val = packed struct {
        /// CSR23 [0:31]
        /// CSR23
        CSR23: u32 = 0,
    };
    /// context swap registers
    pub const CSR23 = Register(CSR23_val).init(base_address + 0x154);

    /// CSR24
    const CSR24_val = packed struct {
        /// CSR24 [0:31]
        /// CSR24
        CSR24: u32 = 0,
    };
    /// context swap registers
    pub const CSR24 = Register(CSR24_val).init(base_address + 0x158);

    /// CSR25
    const CSR25_val = packed struct {
        /// CSR25 [0:31]
        /// CSR25
        CSR25: u32 = 0,
    };
    /// context swap registers
    pub const CSR25 = Register(CSR25_val).init(base_address + 0x15c);

    /// CSR26
    const CSR26_val = packed struct {
        /// CSR26 [0:31]
        /// CSR26
        CSR26: u32 = 0,
    };
    /// context swap registers
    pub const CSR26 = Register(CSR26_val).init(base_address + 0x160);

    /// CSR27
    const CSR27_val = packed struct {
        /// CSR27 [0:31]
        /// CSR27
        CSR27: u32 = 0,
    };
    /// context swap registers
    pub const CSR27 = Register(CSR27_val).init(base_address + 0x164);

    /// CSR28
    const CSR28_val = packed struct {
        /// CSR28 [0:31]
        /// CSR28
        CSR28: u32 = 0,
    };
    /// context swap registers
    pub const CSR28 = Register(CSR28_val).init(base_address + 0x168);

    /// CSR29
    const CSR29_val = packed struct {
        /// CSR29 [0:31]
        /// CSR29
        CSR29: u32 = 0,
    };
    /// context swap registers
    pub const CSR29 = Register(CSR29_val).init(base_address + 0x16c);

    /// CSR30
    const CSR30_val = packed struct {
        /// CSR30 [0:31]
        /// CSR30
        CSR30: u32 = 0,
    };
    /// context swap registers
    pub const CSR30 = Register(CSR30_val).init(base_address + 0x170);

    /// CSR31
    const CSR31_val = packed struct {
        /// CSR31 [0:31]
        /// CSR31
        CSR31: u32 = 0,
    };
    /// context swap registers
    pub const CSR31 = Register(CSR31_val).init(base_address + 0x174);

    /// CSR32
    const CSR32_val = packed struct {
        /// CSR32 [0:31]
        /// CSR32
        CSR32: u32 = 0,
    };
    /// context swap registers
    pub const CSR32 = Register(CSR32_val).init(base_address + 0x178);

    /// CSR33
    const CSR33_val = packed struct {
        /// CSR33 [0:31]
        /// CSR33
        CSR33: u32 = 0,
    };
    /// context swap registers
    pub const CSR33 = Register(CSR33_val).init(base_address + 0x17c);

    /// CSR34
    const CSR34_val = packed struct {
        /// CSR34 [0:31]
        /// CSR34
        CSR34: u32 = 0,
    };
    /// context swap registers
    pub const CSR34 = Register(CSR34_val).init(base_address + 0x180);

    /// CSR35
    const CSR35_val = packed struct {
        /// CSR35 [0:31]
        /// CSR35
        CSR35: u32 = 0,
    };
    /// context swap registers
    pub const CSR35 = Register(CSR35_val).init(base_address + 0x184);

    /// CSR36
    const CSR36_val = packed struct {
        /// CSR36 [0:31]
        /// CSR36
        CSR36: u32 = 0,
    };
    /// context swap registers
    pub const CSR36 = Register(CSR36_val).init(base_address + 0x188);

    /// CSR37
    const CSR37_val = packed struct {
        /// CSR37 [0:31]
        /// CSR37
        CSR37: u32 = 0,
    };
    /// context swap registers
    pub const CSR37 = Register(CSR37_val).init(base_address + 0x18c);

    /// CSR38
    const CSR38_val = packed struct {
        /// CSR38 [0:31]
        /// CSR38
        CSR38: u32 = 0,
    };
    /// context swap registers
    pub const CSR38 = Register(CSR38_val).init(base_address + 0x190);

    /// CSR39
    const CSR39_val = packed struct {
        /// CSR39 [0:31]
        /// CSR39
        CSR39: u32 = 0,
    };
    /// context swap registers
    pub const CSR39 = Register(CSR39_val).init(base_address + 0x194);

    /// CSR40
    const CSR40_val = packed struct {
        /// CSR40 [0:31]
        /// CSR40
        CSR40: u32 = 0,
    };
    /// context swap registers
    pub const CSR40 = Register(CSR40_val).init(base_address + 0x198);

    /// CSR41
    const CSR41_val = packed struct {
        /// CSR41 [0:31]
        /// CSR41
        CSR41: u32 = 0,
    };
    /// context swap registers
    pub const CSR41 = Register(CSR41_val).init(base_address + 0x19c);

    /// CSR42
    const CSR42_val = packed struct {
        /// CSR42 [0:31]
        /// CSR42
        CSR42: u32 = 0,
    };
    /// context swap registers
    pub const CSR42 = Register(CSR42_val).init(base_address + 0x1a0);

    /// CSR43
    const CSR43_val = packed struct {
        /// CSR43 [0:31]
        /// CSR43
        CSR43: u32 = 0,
    };
    /// context swap registers
    pub const CSR43 = Register(CSR43_val).init(base_address + 0x1a4);

    /// CSR44
    const CSR44_val = packed struct {
        /// CSR44 [0:31]
        /// CSR44
        CSR44: u32 = 0,
    };
    /// context swap registers
    pub const CSR44 = Register(CSR44_val).init(base_address + 0x1a8);

    /// CSR45
    const CSR45_val = packed struct {
        /// CSR45 [0:31]
        /// CSR45
        CSR45: u32 = 0,
    };
    /// context swap registers
    pub const CSR45 = Register(CSR45_val).init(base_address + 0x1ac);

    /// CSR46
    const CSR46_val = packed struct {
        /// CSR46 [0:31]
        /// CSR46
        CSR46: u32 = 0,
    };
    /// context swap registers
    pub const CSR46 = Register(CSR46_val).init(base_address + 0x1b0);

    /// CSR47
    const CSR47_val = packed struct {
        /// CSR47 [0:31]
        /// CSR47
        CSR47: u32 = 0,
    };
    /// context swap registers
    pub const CSR47 = Register(CSR47_val).init(base_address + 0x1b4);

    /// CSR48
    const CSR48_val = packed struct {
        /// CSR48 [0:31]
        /// CSR48
        CSR48: u32 = 0,
    };
    /// context swap registers
    pub const CSR48 = Register(CSR48_val).init(base_address + 0x1b8);

    /// CSR49
    const CSR49_val = packed struct {
        /// CSR49 [0:31]
        /// CSR49
        CSR49: u32 = 0,
    };
    /// context swap registers
    pub const CSR49 = Register(CSR49_val).init(base_address + 0x1bc);

    /// CSR50
    const CSR50_val = packed struct {
        /// CSR50 [0:31]
        /// CSR50
        CSR50: u32 = 0,
    };
    /// context swap registers
    pub const CSR50 = Register(CSR50_val).init(base_address + 0x1c0);

    /// CSR51
    const CSR51_val = packed struct {
        /// CSR51 [0:31]
        /// CSR51
        CSR51: u32 = 0,
    };
    /// context swap registers
    pub const CSR51 = Register(CSR51_val).init(base_address + 0x1c4);

    /// CSR52
    const CSR52_val = packed struct {
        /// CSR52 [0:31]
        /// CSR52
        CSR52: u32 = 0,
    };
    /// context swap registers
    pub const CSR52 = Register(CSR52_val).init(base_address + 0x1c8);

    /// CSR53
    const CSR53_val = packed struct {
        /// CSR53 [0:31]
        /// CSR53
        CSR53: u32 = 0,
    };
    /// context swap registers
    pub const CSR53 = Register(CSR53_val).init(base_address + 0x1cc);

    /// HASH_HR0
    const HASH_HR0_val = packed struct {
        /// H0 [0:31]
        /// H0
        H0: u32 = 0,
    };
    /// HASH digest register
    pub const HASH_HR0 = Register(HASH_HR0_val).init(base_address + 0x310);

    /// HASH_HR1
    const HASH_HR1_val = packed struct {
        /// H1 [0:31]
        /// H1
        H1: u32 = 0,
    };
    /// read-only
    pub const HASH_HR1 = Register(HASH_HR1_val).init(base_address + 0x314);

    /// HASH_HR2
    const HASH_HR2_val = packed struct {
        /// H2 [0:31]
        /// H2
        H2: u32 = 0,
    };
    /// read-only
    pub const HASH_HR2 = Register(HASH_HR2_val).init(base_address + 0x318);

    /// HASH_HR3
    const HASH_HR3_val = packed struct {
        /// H3 [0:31]
        /// H3
        H3: u32 = 0,
    };
    /// read-only
    pub const HASH_HR3 = Register(HASH_HR3_val).init(base_address + 0x31c);

    /// HASH_HR4
    const HASH_HR4_val = packed struct {
        /// H4 [0:31]
        /// H4
        H4: u32 = 0,
    };
    /// read-only
    pub const HASH_HR4 = Register(HASH_HR4_val).init(base_address + 0x320);

    /// HASH_HR5
    const HASH_HR5_val = packed struct {
        /// H5 [0:31]
        /// H5
        H5: u32 = 0,
    };
    /// read-only
    pub const HASH_HR5 = Register(HASH_HR5_val).init(base_address + 0x324);

    /// HASH_HR6
    const HASH_HR6_val = packed struct {
        /// H6 [0:31]
        /// H6
        H6: u32 = 0,
    };
    /// read-only
    pub const HASH_HR6 = Register(HASH_HR6_val).init(base_address + 0x328);

    /// HASH_HR7
    const HASH_HR7_val = packed struct {
        /// H7 [0:31]
        /// H7
        H7: u32 = 0,
    };
    /// read-only
    pub const HASH_HR7 = Register(HASH_HR7_val).init(base_address + 0x32c);
};

/// Cryptographic processor
pub const CRYP = struct {
    const base_address = 0x50060000;
    /// CR
    const CR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// ALGODIR [2:2]
        /// Algorithm direction
        ALGODIR: u1 = 0,
        /// ALGOMODE0 [3:5]
        /// Algorithm mode
        ALGOMODE0: u3 = 0,
        /// DATATYPE [6:7]
        /// Data type selection
        DATATYPE: u2 = 0,
        /// KEYSIZE [8:9]
        /// Key size selection (AES mode
        KEYSIZE: u2 = 0,
        /// unused [10:13]
        _unused10: u4 = 0,
        /// FFLUSH [14:14]
        /// FIFO flush
        FFLUSH: u1 = 0,
        /// CRYPEN [15:15]
        /// Cryptographic processor
        CRYPEN: u1 = 0,
        /// GCM_CCMPH [16:17]
        /// GCM_CCMPH
        GCM_CCMPH: u2 = 0,
        /// unused [18:18]
        _unused18: u1 = 0,
        /// ALGOMODE3 [19:19]
        /// ALGOMODE
        ALGOMODE3: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// SR
    const SR_val = packed struct {
        /// IFEM [0:0]
        /// Input FIFO empty
        IFEM: u1 = 1,
        /// IFNF [1:1]
        /// Input FIFO not full
        IFNF: u1 = 1,
        /// OFNE [2:2]
        /// Output FIFO not empty
        OFNE: u1 = 0,
        /// OFFU [3:3]
        /// Output FIFO full
        OFFU: u1 = 0,
        /// BUSY [4:4]
        /// Busy bit
        BUSY: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x4);

    /// DIN
    const DIN_val = packed struct {
        /// DATAIN [0:31]
        /// Data input
        DATAIN: u32 = 0,
    };
    /// data input register
    pub const DIN = Register(DIN_val).init(base_address + 0x8);

    /// DOUT
    const DOUT_val = packed struct {
        /// DATAOUT [0:31]
        /// Data output
        DATAOUT: u32 = 0,
    };
    /// data output register
    pub const DOUT = Register(DOUT_val).init(base_address + 0xc);

    /// DMACR
    const DMACR_val = packed struct {
        /// DIEN [0:0]
        /// DMA input enable
        DIEN: u1 = 0,
        /// DOEN [1:1]
        /// DMA output enable
        DOEN: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DMACR = Register(DMACR_val).init(base_address + 0x10);

    /// IMSCR
    const IMSCR_val = packed struct {
        /// INIM [0:0]
        /// Input FIFO service interrupt
        INIM: u1 = 0,
        /// OUTIM [1:1]
        /// Output FIFO service interrupt
        OUTIM: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt mask set/clear
    pub const IMSCR = Register(IMSCR_val).init(base_address + 0x14);

    /// RISR
    const RISR_val = packed struct {
        /// INRIS [0:0]
        /// Input FIFO service raw interrupt
        INRIS: u1 = 1,
        /// OUTRIS [1:1]
        /// Output FIFO service raw interrupt
        OUTRIS: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// raw interrupt status register
    pub const RISR = Register(RISR_val).init(base_address + 0x18);

    /// MISR
    const MISR_val = packed struct {
        /// INMIS [0:0]
        /// Input FIFO service masked interrupt
        INMIS: u1 = 0,
        /// OUTMIS [1:1]
        /// Output FIFO service masked interrupt
        OUTMIS: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// masked interrupt status
    pub const MISR = Register(MISR_val).init(base_address + 0x1c);

    /// K0LR
    const K0LR_val = packed struct {
        /// b224 [0:0]
        /// b224
        b224: u1 = 0,
        /// b225 [1:1]
        /// b225
        b225: u1 = 0,
        /// b226 [2:2]
        /// b226
        b226: u1 = 0,
        /// b227 [3:3]
        /// b227
        b227: u1 = 0,
        /// b228 [4:4]
        /// b228
        b228: u1 = 0,
        /// b229 [5:5]
        /// b229
        b229: u1 = 0,
        /// b230 [6:6]
        /// b230
        b230: u1 = 0,
        /// b231 [7:7]
        /// b231
        b231: u1 = 0,
        /// b232 [8:8]
        /// b232
        b232: u1 = 0,
        /// b233 [9:9]
        /// b233
        b233: u1 = 0,
        /// b234 [10:10]
        /// b234
        b234: u1 = 0,
        /// b235 [11:11]
        /// b235
        b235: u1 = 0,
        /// b236 [12:12]
        /// b236
        b236: u1 = 0,
        /// b237 [13:13]
        /// b237
        b237: u1 = 0,
        /// b238 [14:14]
        /// b238
        b238: u1 = 0,
        /// b239 [15:15]
        /// b239
        b239: u1 = 0,
        /// b240 [16:16]
        /// b240
        b240: u1 = 0,
        /// b241 [17:17]
        /// b241
        b241: u1 = 0,
        /// b242 [18:18]
        /// b242
        b242: u1 = 0,
        /// b243 [19:19]
        /// b243
        b243: u1 = 0,
        /// b244 [20:20]
        /// b244
        b244: u1 = 0,
        /// b245 [21:21]
        /// b245
        b245: u1 = 0,
        /// b246 [22:22]
        /// b246
        b246: u1 = 0,
        /// b247 [23:23]
        /// b247
        b247: u1 = 0,
        /// b248 [24:24]
        /// b248
        b248: u1 = 0,
        /// b249 [25:25]
        /// b249
        b249: u1 = 0,
        /// b250 [26:26]
        /// b250
        b250: u1 = 0,
        /// b251 [27:27]
        /// b251
        b251: u1 = 0,
        /// b252 [28:28]
        /// b252
        b252: u1 = 0,
        /// b253 [29:29]
        /// b253
        b253: u1 = 0,
        /// b254 [30:30]
        /// b254
        b254: u1 = 0,
        /// b255 [31:31]
        /// b255
        b255: u1 = 0,
    };
    /// key registers
    pub const K0LR = Register(K0LR_val).init(base_address + 0x20);

    /// K0RR
    const K0RR_val = packed struct {
        /// b192 [0:0]
        /// b192
        b192: u1 = 0,
        /// b193 [1:1]
        /// b193
        b193: u1 = 0,
        /// b194 [2:2]
        /// b194
        b194: u1 = 0,
        /// b195 [3:3]
        /// b195
        b195: u1 = 0,
        /// b196 [4:4]
        /// b196
        b196: u1 = 0,
        /// b197 [5:5]
        /// b197
        b197: u1 = 0,
        /// b198 [6:6]
        /// b198
        b198: u1 = 0,
        /// b199 [7:7]
        /// b199
        b199: u1 = 0,
        /// b200 [8:8]
        /// b200
        b200: u1 = 0,
        /// b201 [9:9]
        /// b201
        b201: u1 = 0,
        /// b202 [10:10]
        /// b202
        b202: u1 = 0,
        /// b203 [11:11]
        /// b203
        b203: u1 = 0,
        /// b204 [12:12]
        /// b204
        b204: u1 = 0,
        /// b205 [13:13]
        /// b205
        b205: u1 = 0,
        /// b206 [14:14]
        /// b206
        b206: u1 = 0,
        /// b207 [15:15]
        /// b207
        b207: u1 = 0,
        /// b208 [16:16]
        /// b208
        b208: u1 = 0,
        /// b209 [17:17]
        /// b209
        b209: u1 = 0,
        /// b210 [18:18]
        /// b210
        b210: u1 = 0,
        /// b211 [19:19]
        /// b211
        b211: u1 = 0,
        /// b212 [20:20]
        /// b212
        b212: u1 = 0,
        /// b213 [21:21]
        /// b213
        b213: u1 = 0,
        /// b214 [22:22]
        /// b214
        b214: u1 = 0,
        /// b215 [23:23]
        /// b215
        b215: u1 = 0,
        /// b216 [24:24]
        /// b216
        b216: u1 = 0,
        /// b217 [25:25]
        /// b217
        b217: u1 = 0,
        /// b218 [26:26]
        /// b218
        b218: u1 = 0,
        /// b219 [27:27]
        /// b219
        b219: u1 = 0,
        /// b220 [28:28]
        /// b220
        b220: u1 = 0,
        /// b221 [29:29]
        /// b221
        b221: u1 = 0,
        /// b222 [30:30]
        /// b222
        b222: u1 = 0,
        /// b223 [31:31]
        /// b223
        b223: u1 = 0,
    };
    /// key registers
    pub const K0RR = Register(K0RR_val).init(base_address + 0x24);

    /// K1LR
    const K1LR_val = packed struct {
        /// b160 [0:0]
        /// b160
        b160: u1 = 0,
        /// b161 [1:1]
        /// b161
        b161: u1 = 0,
        /// b162 [2:2]
        /// b162
        b162: u1 = 0,
        /// b163 [3:3]
        /// b163
        b163: u1 = 0,
        /// b164 [4:4]
        /// b164
        b164: u1 = 0,
        /// b165 [5:5]
        /// b165
        b165: u1 = 0,
        /// b166 [6:6]
        /// b166
        b166: u1 = 0,
        /// b167 [7:7]
        /// b167
        b167: u1 = 0,
        /// b168 [8:8]
        /// b168
        b168: u1 = 0,
        /// b169 [9:9]
        /// b169
        b169: u1 = 0,
        /// b170 [10:10]
        /// b170
        b170: u1 = 0,
        /// b171 [11:11]
        /// b171
        b171: u1 = 0,
        /// b172 [12:12]
        /// b172
        b172: u1 = 0,
        /// b173 [13:13]
        /// b173
        b173: u1 = 0,
        /// b174 [14:14]
        /// b174
        b174: u1 = 0,
        /// b175 [15:15]
        /// b175
        b175: u1 = 0,
        /// b176 [16:16]
        /// b176
        b176: u1 = 0,
        /// b177 [17:17]
        /// b177
        b177: u1 = 0,
        /// b178 [18:18]
        /// b178
        b178: u1 = 0,
        /// b179 [19:19]
        /// b179
        b179: u1 = 0,
        /// b180 [20:20]
        /// b180
        b180: u1 = 0,
        /// b181 [21:21]
        /// b181
        b181: u1 = 0,
        /// b182 [22:22]
        /// b182
        b182: u1 = 0,
        /// b183 [23:23]
        /// b183
        b183: u1 = 0,
        /// b184 [24:24]
        /// b184
        b184: u1 = 0,
        /// b185 [25:25]
        /// b185
        b185: u1 = 0,
        /// b186 [26:26]
        /// b186
        b186: u1 = 0,
        /// b187 [27:27]
        /// b187
        b187: u1 = 0,
        /// b188 [28:28]
        /// b188
        b188: u1 = 0,
        /// b189 [29:29]
        /// b189
        b189: u1 = 0,
        /// b190 [30:30]
        /// b190
        b190: u1 = 0,
        /// b191 [31:31]
        /// b191
        b191: u1 = 0,
    };
    /// key registers
    pub const K1LR = Register(K1LR_val).init(base_address + 0x28);

    /// K1RR
    const K1RR_val = packed struct {
        /// b128 [0:0]
        /// b128
        b128: u1 = 0,
        /// b129 [1:1]
        /// b129
        b129: u1 = 0,
        /// b130 [2:2]
        /// b130
        b130: u1 = 0,
        /// b131 [3:3]
        /// b131
        b131: u1 = 0,
        /// b132 [4:4]
        /// b132
        b132: u1 = 0,
        /// b133 [5:5]
        /// b133
        b133: u1 = 0,
        /// b134 [6:6]
        /// b134
        b134: u1 = 0,
        /// b135 [7:7]
        /// b135
        b135: u1 = 0,
        /// b136 [8:8]
        /// b136
        b136: u1 = 0,
        /// b137 [9:9]
        /// b137
        b137: u1 = 0,
        /// b138 [10:10]
        /// b138
        b138: u1 = 0,
        /// b139 [11:11]
        /// b139
        b139: u1 = 0,
        /// b140 [12:12]
        /// b140
        b140: u1 = 0,
        /// b141 [13:13]
        /// b141
        b141: u1 = 0,
        /// b142 [14:14]
        /// b142
        b142: u1 = 0,
        /// b143 [15:15]
        /// b143
        b143: u1 = 0,
        /// b144 [16:16]
        /// b144
        b144: u1 = 0,
        /// b145 [17:17]
        /// b145
        b145: u1 = 0,
        /// b146 [18:18]
        /// b146
        b146: u1 = 0,
        /// b147 [19:19]
        /// b147
        b147: u1 = 0,
        /// b148 [20:20]
        /// b148
        b148: u1 = 0,
        /// b149 [21:21]
        /// b149
        b149: u1 = 0,
        /// b150 [22:22]
        /// b150
        b150: u1 = 0,
        /// b151 [23:23]
        /// b151
        b151: u1 = 0,
        /// b152 [24:24]
        /// b152
        b152: u1 = 0,
        /// b153 [25:25]
        /// b153
        b153: u1 = 0,
        /// b154 [26:26]
        /// b154
        b154: u1 = 0,
        /// b155 [27:27]
        /// b155
        b155: u1 = 0,
        /// b156 [28:28]
        /// b156
        b156: u1 = 0,
        /// b157 [29:29]
        /// b157
        b157: u1 = 0,
        /// b158 [30:30]
        /// b158
        b158: u1 = 0,
        /// b159 [31:31]
        /// b159
        b159: u1 = 0,
    };
    /// key registers
    pub const K1RR = Register(K1RR_val).init(base_address + 0x2c);

    /// K2LR
    const K2LR_val = packed struct {
        /// b96 [0:0]
        /// b96
        b96: u1 = 0,
        /// b97 [1:1]
        /// b97
        b97: u1 = 0,
        /// b98 [2:2]
        /// b98
        b98: u1 = 0,
        /// b99 [3:3]
        /// b99
        b99: u1 = 0,
        /// b100 [4:4]
        /// b100
        b100: u1 = 0,
        /// b101 [5:5]
        /// b101
        b101: u1 = 0,
        /// b102 [6:6]
        /// b102
        b102: u1 = 0,
        /// b103 [7:7]
        /// b103
        b103: u1 = 0,
        /// b104 [8:8]
        /// b104
        b104: u1 = 0,
        /// b105 [9:9]
        /// b105
        b105: u1 = 0,
        /// b106 [10:10]
        /// b106
        b106: u1 = 0,
        /// b107 [11:11]
        /// b107
        b107: u1 = 0,
        /// b108 [12:12]
        /// b108
        b108: u1 = 0,
        /// b109 [13:13]
        /// b109
        b109: u1 = 0,
        /// b110 [14:14]
        /// b110
        b110: u1 = 0,
        /// b111 [15:15]
        /// b111
        b111: u1 = 0,
        /// b112 [16:16]
        /// b112
        b112: u1 = 0,
        /// b113 [17:17]
        /// b113
        b113: u1 = 0,
        /// b114 [18:18]
        /// b114
        b114: u1 = 0,
        /// b115 [19:19]
        /// b115
        b115: u1 = 0,
        /// b116 [20:20]
        /// b116
        b116: u1 = 0,
        /// b117 [21:21]
        /// b117
        b117: u1 = 0,
        /// b118 [22:22]
        /// b118
        b118: u1 = 0,
        /// b119 [23:23]
        /// b119
        b119: u1 = 0,
        /// b120 [24:24]
        /// b120
        b120: u1 = 0,
        /// b121 [25:25]
        /// b121
        b121: u1 = 0,
        /// b122 [26:26]
        /// b122
        b122: u1 = 0,
        /// b123 [27:27]
        /// b123
        b123: u1 = 0,
        /// b124 [28:28]
        /// b124
        b124: u1 = 0,
        /// b125 [29:29]
        /// b125
        b125: u1 = 0,
        /// b126 [30:30]
        /// b126
        b126: u1 = 0,
        /// b127 [31:31]
        /// b127
        b127: u1 = 0,
    };
    /// key registers
    pub const K2LR = Register(K2LR_val).init(base_address + 0x30);

    /// K2RR
    const K2RR_val = packed struct {
        /// b64 [0:0]
        /// b64
        b64: u1 = 0,
        /// b65 [1:1]
        /// b65
        b65: u1 = 0,
        /// b66 [2:2]
        /// b66
        b66: u1 = 0,
        /// b67 [3:3]
        /// b67
        b67: u1 = 0,
        /// b68 [4:4]
        /// b68
        b68: u1 = 0,
        /// b69 [5:5]
        /// b69
        b69: u1 = 0,
        /// b70 [6:6]
        /// b70
        b70: u1 = 0,
        /// b71 [7:7]
        /// b71
        b71: u1 = 0,
        /// b72 [8:8]
        /// b72
        b72: u1 = 0,
        /// b73 [9:9]
        /// b73
        b73: u1 = 0,
        /// b74 [10:10]
        /// b74
        b74: u1 = 0,
        /// b75 [11:11]
        /// b75
        b75: u1 = 0,
        /// b76 [12:12]
        /// b76
        b76: u1 = 0,
        /// b77 [13:13]
        /// b77
        b77: u1 = 0,
        /// b78 [14:14]
        /// b78
        b78: u1 = 0,
        /// b79 [15:15]
        /// b79
        b79: u1 = 0,
        /// b80 [16:16]
        /// b80
        b80: u1 = 0,
        /// b81 [17:17]
        /// b81
        b81: u1 = 0,
        /// b82 [18:18]
        /// b82
        b82: u1 = 0,
        /// b83 [19:19]
        /// b83
        b83: u1 = 0,
        /// b84 [20:20]
        /// b84
        b84: u1 = 0,
        /// b85 [21:21]
        /// b85
        b85: u1 = 0,
        /// b86 [22:22]
        /// b86
        b86: u1 = 0,
        /// b87 [23:23]
        /// b87
        b87: u1 = 0,
        /// b88 [24:24]
        /// b88
        b88: u1 = 0,
        /// b89 [25:25]
        /// b89
        b89: u1 = 0,
        /// b90 [26:26]
        /// b90
        b90: u1 = 0,
        /// b91 [27:27]
        /// b91
        b91: u1 = 0,
        /// b92 [28:28]
        /// b92
        b92: u1 = 0,
        /// b93 [29:29]
        /// b93
        b93: u1 = 0,
        /// b94 [30:30]
        /// b94
        b94: u1 = 0,
        /// b95 [31:31]
        /// b95
        b95: u1 = 0,
    };
    /// key registers
    pub const K2RR = Register(K2RR_val).init(base_address + 0x34);

    /// K3LR
    const K3LR_val = packed struct {
        /// b32 [0:0]
        /// b32
        b32: u1 = 0,
        /// b33 [1:1]
        /// b33
        b33: u1 = 0,
        /// b34 [2:2]
        /// b34
        b34: u1 = 0,
        /// b35 [3:3]
        /// b35
        b35: u1 = 0,
        /// b36 [4:4]
        /// b36
        b36: u1 = 0,
        /// b37 [5:5]
        /// b37
        b37: u1 = 0,
        /// b38 [6:6]
        /// b38
        b38: u1 = 0,
        /// b39 [7:7]
        /// b39
        b39: u1 = 0,
        /// b40 [8:8]
        /// b40
        b40: u1 = 0,
        /// b41 [9:9]
        /// b41
        b41: u1 = 0,
        /// b42 [10:10]
        /// b42
        b42: u1 = 0,
        /// b43 [11:11]
        /// b43
        b43: u1 = 0,
        /// b44 [12:12]
        /// b44
        b44: u1 = 0,
        /// b45 [13:13]
        /// b45
        b45: u1 = 0,
        /// b46 [14:14]
        /// b46
        b46: u1 = 0,
        /// b47 [15:15]
        /// b47
        b47: u1 = 0,
        /// b48 [16:16]
        /// b48
        b48: u1 = 0,
        /// b49 [17:17]
        /// b49
        b49: u1 = 0,
        /// b50 [18:18]
        /// b50
        b50: u1 = 0,
        /// b51 [19:19]
        /// b51
        b51: u1 = 0,
        /// b52 [20:20]
        /// b52
        b52: u1 = 0,
        /// b53 [21:21]
        /// b53
        b53: u1 = 0,
        /// b54 [22:22]
        /// b54
        b54: u1 = 0,
        /// b55 [23:23]
        /// b55
        b55: u1 = 0,
        /// b56 [24:24]
        /// b56
        b56: u1 = 0,
        /// b57 [25:25]
        /// b57
        b57: u1 = 0,
        /// b58 [26:26]
        /// b58
        b58: u1 = 0,
        /// b59 [27:27]
        /// b59
        b59: u1 = 0,
        /// b60 [28:28]
        /// b60
        b60: u1 = 0,
        /// b61 [29:29]
        /// b61
        b61: u1 = 0,
        /// b62 [30:30]
        /// b62
        b62: u1 = 0,
        /// b63 [31:31]
        /// b63
        b63: u1 = 0,
    };
    /// key registers
    pub const K3LR = Register(K3LR_val).init(base_address + 0x38);

    /// K3RR
    const K3RR_val = packed struct {
        /// b0 [0:0]
        /// b0
        b0: u1 = 0,
        /// b1 [1:1]
        /// b1
        b1: u1 = 0,
        /// b2 [2:2]
        /// b2
        b2: u1 = 0,
        /// b3 [3:3]
        /// b3
        b3: u1 = 0,
        /// b4 [4:4]
        /// b4
        b4: u1 = 0,
        /// b5 [5:5]
        /// b5
        b5: u1 = 0,
        /// b6 [6:6]
        /// b6
        b6: u1 = 0,
        /// b7 [7:7]
        /// b7
        b7: u1 = 0,
        /// b8 [8:8]
        /// b8
        b8: u1 = 0,
        /// b9 [9:9]
        /// b9
        b9: u1 = 0,
        /// b10 [10:10]
        /// b10
        b10: u1 = 0,
        /// b11 [11:11]
        /// b11
        b11: u1 = 0,
        /// b12 [12:12]
        /// b12
        b12: u1 = 0,
        /// b13 [13:13]
        /// b13
        b13: u1 = 0,
        /// b14 [14:14]
        /// b14
        b14: u1 = 0,
        /// b15 [15:15]
        /// b15
        b15: u1 = 0,
        /// b16 [16:16]
        /// b16
        b16: u1 = 0,
        /// b17 [17:17]
        /// b17
        b17: u1 = 0,
        /// b18 [18:18]
        /// b18
        b18: u1 = 0,
        /// b19 [19:19]
        /// b19
        b19: u1 = 0,
        /// b20 [20:20]
        /// b20
        b20: u1 = 0,
        /// b21 [21:21]
        /// b21
        b21: u1 = 0,
        /// b22 [22:22]
        /// b22
        b22: u1 = 0,
        /// b23 [23:23]
        /// b23
        b23: u1 = 0,
        /// b24 [24:24]
        /// b24
        b24: u1 = 0,
        /// b25 [25:25]
        /// b25
        b25: u1 = 0,
        /// b26 [26:26]
        /// b26
        b26: u1 = 0,
        /// b27 [27:27]
        /// b27
        b27: u1 = 0,
        /// b28 [28:28]
        /// b28
        b28: u1 = 0,
        /// b29 [29:29]
        /// b29
        b29: u1 = 0,
        /// b30 [30:30]
        /// b30
        b30: u1 = 0,
        /// b31 [31:31]
        /// b31
        b31: u1 = 0,
    };
    /// key registers
    pub const K3RR = Register(K3RR_val).init(base_address + 0x3c);

    /// IV0LR
    const IV0LR_val = packed struct {
        /// IV31 [0:0]
        /// IV31
        IV31: u1 = 0,
        /// IV30 [1:1]
        /// IV30
        IV30: u1 = 0,
        /// IV29 [2:2]
        /// IV29
        IV29: u1 = 0,
        /// IV28 [3:3]
        /// IV28
        IV28: u1 = 0,
        /// IV27 [4:4]
        /// IV27
        IV27: u1 = 0,
        /// IV26 [5:5]
        /// IV26
        IV26: u1 = 0,
        /// IV25 [6:6]
        /// IV25
        IV25: u1 = 0,
        /// IV24 [7:7]
        /// IV24
        IV24: u1 = 0,
        /// IV23 [8:8]
        /// IV23
        IV23: u1 = 0,
        /// IV22 [9:9]
        /// IV22
        IV22: u1 = 0,
        /// IV21 [10:10]
        /// IV21
        IV21: u1 = 0,
        /// IV20 [11:11]
        /// IV20
        IV20: u1 = 0,
        /// IV19 [12:12]
        /// IV19
        IV19: u1 = 0,
        /// IV18 [13:13]
        /// IV18
        IV18: u1 = 0,
        /// IV17 [14:14]
        /// IV17
        IV17: u1 = 0,
        /// IV16 [15:15]
        /// IV16
        IV16: u1 = 0,
        /// IV15 [16:16]
        /// IV15
        IV15: u1 = 0,
        /// IV14 [17:17]
        /// IV14
        IV14: u1 = 0,
        /// IV13 [18:18]
        /// IV13
        IV13: u1 = 0,
        /// IV12 [19:19]
        /// IV12
        IV12: u1 = 0,
        /// IV11 [20:20]
        /// IV11
        IV11: u1 = 0,
        /// IV10 [21:21]
        /// IV10
        IV10: u1 = 0,
        /// IV9 [22:22]
        /// IV9
        IV9: u1 = 0,
        /// IV8 [23:23]
        /// IV8
        IV8: u1 = 0,
        /// IV7 [24:24]
        /// IV7
        IV7: u1 = 0,
        /// IV6 [25:25]
        /// IV6
        IV6: u1 = 0,
        /// IV5 [26:26]
        /// IV5
        IV5: u1 = 0,
        /// IV4 [27:27]
        /// IV4
        IV4: u1 = 0,
        /// IV3 [28:28]
        /// IV3
        IV3: u1 = 0,
        /// IV2 [29:29]
        /// IV2
        IV2: u1 = 0,
        /// IV1 [30:30]
        /// IV1
        IV1: u1 = 0,
        /// IV0 [31:31]
        /// IV0
        IV0: u1 = 0,
    };
    /// initialization vector
    pub const IV0LR = Register(IV0LR_val).init(base_address + 0x40);

    /// IV0RR
    const IV0RR_val = packed struct {
        /// IV63 [0:0]
        /// IV63
        IV63: u1 = 0,
        /// IV62 [1:1]
        /// IV62
        IV62: u1 = 0,
        /// IV61 [2:2]
        /// IV61
        IV61: u1 = 0,
        /// IV60 [3:3]
        /// IV60
        IV60: u1 = 0,
        /// IV59 [4:4]
        /// IV59
        IV59: u1 = 0,
        /// IV58 [5:5]
        /// IV58
        IV58: u1 = 0,
        /// IV57 [6:6]
        /// IV57
        IV57: u1 = 0,
        /// IV56 [7:7]
        /// IV56
        IV56: u1 = 0,
        /// IV55 [8:8]
        /// IV55
        IV55: u1 = 0,
        /// IV54 [9:9]
        /// IV54
        IV54: u1 = 0,
        /// IV53 [10:10]
        /// IV53
        IV53: u1 = 0,
        /// IV52 [11:11]
        /// IV52
        IV52: u1 = 0,
        /// IV51 [12:12]
        /// IV51
        IV51: u1 = 0,
        /// IV50 [13:13]
        /// IV50
        IV50: u1 = 0,
        /// IV49 [14:14]
        /// IV49
        IV49: u1 = 0,
        /// IV48 [15:15]
        /// IV48
        IV48: u1 = 0,
        /// IV47 [16:16]
        /// IV47
        IV47: u1 = 0,
        /// IV46 [17:17]
        /// IV46
        IV46: u1 = 0,
        /// IV45 [18:18]
        /// IV45
        IV45: u1 = 0,
        /// IV44 [19:19]
        /// IV44
        IV44: u1 = 0,
        /// IV43 [20:20]
        /// IV43
        IV43: u1 = 0,
        /// IV42 [21:21]
        /// IV42
        IV42: u1 = 0,
        /// IV41 [22:22]
        /// IV41
        IV41: u1 = 0,
        /// IV40 [23:23]
        /// IV40
        IV40: u1 = 0,
        /// IV39 [24:24]
        /// IV39
        IV39: u1 = 0,
        /// IV38 [25:25]
        /// IV38
        IV38: u1 = 0,
        /// IV37 [26:26]
        /// IV37
        IV37: u1 = 0,
        /// IV36 [27:27]
        /// IV36
        IV36: u1 = 0,
        /// IV35 [28:28]
        /// IV35
        IV35: u1 = 0,
        /// IV34 [29:29]
        /// IV34
        IV34: u1 = 0,
        /// IV33 [30:30]
        /// IV33
        IV33: u1 = 0,
        /// IV32 [31:31]
        /// IV32
        IV32: u1 = 0,
    };
    /// initialization vector
    pub const IV0RR = Register(IV0RR_val).init(base_address + 0x44);

    /// IV1LR
    const IV1LR_val = packed struct {
        /// IV95 [0:0]
        /// IV95
        IV95: u1 = 0,
        /// IV94 [1:1]
        /// IV94
        IV94: u1 = 0,
        /// IV93 [2:2]
        /// IV93
        IV93: u1 = 0,
        /// IV92 [3:3]
        /// IV92
        IV92: u1 = 0,
        /// IV91 [4:4]
        /// IV91
        IV91: u1 = 0,
        /// IV90 [5:5]
        /// IV90
        IV90: u1 = 0,
        /// IV89 [6:6]
        /// IV89
        IV89: u1 = 0,
        /// IV88 [7:7]
        /// IV88
        IV88: u1 = 0,
        /// IV87 [8:8]
        /// IV87
        IV87: u1 = 0,
        /// IV86 [9:9]
        /// IV86
        IV86: u1 = 0,
        /// IV85 [10:10]
        /// IV85
        IV85: u1 = 0,
        /// IV84 [11:11]
        /// IV84
        IV84: u1 = 0,
        /// IV83 [12:12]
        /// IV83
        IV83: u1 = 0,
        /// IV82 [13:13]
        /// IV82
        IV82: u1 = 0,
        /// IV81 [14:14]
        /// IV81
        IV81: u1 = 0,
        /// IV80 [15:15]
        /// IV80
        IV80: u1 = 0,
        /// IV79 [16:16]
        /// IV79
        IV79: u1 = 0,
        /// IV78 [17:17]
        /// IV78
        IV78: u1 = 0,
        /// IV77 [18:18]
        /// IV77
        IV77: u1 = 0,
        /// IV76 [19:19]
        /// IV76
        IV76: u1 = 0,
        /// IV75 [20:20]
        /// IV75
        IV75: u1 = 0,
        /// IV74 [21:21]
        /// IV74
        IV74: u1 = 0,
        /// IV73 [22:22]
        /// IV73
        IV73: u1 = 0,
        /// IV72 [23:23]
        /// IV72
        IV72: u1 = 0,
        /// IV71 [24:24]
        /// IV71
        IV71: u1 = 0,
        /// IV70 [25:25]
        /// IV70
        IV70: u1 = 0,
        /// IV69 [26:26]
        /// IV69
        IV69: u1 = 0,
        /// IV68 [27:27]
        /// IV68
        IV68: u1 = 0,
        /// IV67 [28:28]
        /// IV67
        IV67: u1 = 0,
        /// IV66 [29:29]
        /// IV66
        IV66: u1 = 0,
        /// IV65 [30:30]
        /// IV65
        IV65: u1 = 0,
        /// IV64 [31:31]
        /// IV64
        IV64: u1 = 0,
    };
    /// initialization vector
    pub const IV1LR = Register(IV1LR_val).init(base_address + 0x48);

    /// IV1RR
    const IV1RR_val = packed struct {
        /// IV127 [0:0]
        /// IV127
        IV127: u1 = 0,
        /// IV126 [1:1]
        /// IV126
        IV126: u1 = 0,
        /// IV125 [2:2]
        /// IV125
        IV125: u1 = 0,
        /// IV124 [3:3]
        /// IV124
        IV124: u1 = 0,
        /// IV123 [4:4]
        /// IV123
        IV123: u1 = 0,
        /// IV122 [5:5]
        /// IV122
        IV122: u1 = 0,
        /// IV121 [6:6]
        /// IV121
        IV121: u1 = 0,
        /// IV120 [7:7]
        /// IV120
        IV120: u1 = 0,
        /// IV119 [8:8]
        /// IV119
        IV119: u1 = 0,
        /// IV118 [9:9]
        /// IV118
        IV118: u1 = 0,
        /// IV117 [10:10]
        /// IV117
        IV117: u1 = 0,
        /// IV116 [11:11]
        /// IV116
        IV116: u1 = 0,
        /// IV115 [12:12]
        /// IV115
        IV115: u1 = 0,
        /// IV114 [13:13]
        /// IV114
        IV114: u1 = 0,
        /// IV113 [14:14]
        /// IV113
        IV113: u1 = 0,
        /// IV112 [15:15]
        /// IV112
        IV112: u1 = 0,
        /// IV111 [16:16]
        /// IV111
        IV111: u1 = 0,
        /// IV110 [17:17]
        /// IV110
        IV110: u1 = 0,
        /// IV109 [18:18]
        /// IV109
        IV109: u1 = 0,
        /// IV108 [19:19]
        /// IV108
        IV108: u1 = 0,
        /// IV107 [20:20]
        /// IV107
        IV107: u1 = 0,
        /// IV106 [21:21]
        /// IV106
        IV106: u1 = 0,
        /// IV105 [22:22]
        /// IV105
        IV105: u1 = 0,
        /// IV104 [23:23]
        /// IV104
        IV104: u1 = 0,
        /// IV103 [24:24]
        /// IV103
        IV103: u1 = 0,
        /// IV102 [25:25]
        /// IV102
        IV102: u1 = 0,
        /// IV101 [26:26]
        /// IV101
        IV101: u1 = 0,
        /// IV100 [27:27]
        /// IV100
        IV100: u1 = 0,
        /// IV99 [28:28]
        /// IV99
        IV99: u1 = 0,
        /// IV98 [29:29]
        /// IV98
        IV98: u1 = 0,
        /// IV97 [30:30]
        /// IV97
        IV97: u1 = 0,
        /// IV96 [31:31]
        /// IV96
        IV96: u1 = 0,
    };
    /// initialization vector
    pub const IV1RR = Register(IV1RR_val).init(base_address + 0x4c);

    /// CSGCMCCM0R
    const CSGCMCCM0R_val = packed struct {
        /// CSGCMCCM0R [0:31]
        /// CSGCMCCM0R
        CSGCMCCM0R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM0R = Register(CSGCMCCM0R_val).init(base_address + 0x50);

    /// CSGCMCCM1R
    const CSGCMCCM1R_val = packed struct {
        /// CSGCMCCM1R [0:31]
        /// CSGCMCCM1R
        CSGCMCCM1R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM1R = Register(CSGCMCCM1R_val).init(base_address + 0x54);

    /// CSGCMCCM2R
    const CSGCMCCM2R_val = packed struct {
        /// CSGCMCCM2R [0:31]
        /// CSGCMCCM2R
        CSGCMCCM2R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM2R = Register(CSGCMCCM2R_val).init(base_address + 0x58);

    /// CSGCMCCM3R
    const CSGCMCCM3R_val = packed struct {
        /// CSGCMCCM3R [0:31]
        /// CSGCMCCM3R
        CSGCMCCM3R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM3R = Register(CSGCMCCM3R_val).init(base_address + 0x5c);

    /// CSGCMCCM4R
    const CSGCMCCM4R_val = packed struct {
        /// CSGCMCCM4R [0:31]
        /// CSGCMCCM4R
        CSGCMCCM4R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM4R = Register(CSGCMCCM4R_val).init(base_address + 0x60);

    /// CSGCMCCM5R
    const CSGCMCCM5R_val = packed struct {
        /// CSGCMCCM5R [0:31]
        /// CSGCMCCM5R
        CSGCMCCM5R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM5R = Register(CSGCMCCM5R_val).init(base_address + 0x64);

    /// CSGCMCCM6R
    const CSGCMCCM6R_val = packed struct {
        /// CSGCMCCM6R [0:31]
        /// CSGCMCCM6R
        CSGCMCCM6R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM6R = Register(CSGCMCCM6R_val).init(base_address + 0x68);

    /// CSGCMCCM7R
    const CSGCMCCM7R_val = packed struct {
        /// CSGCMCCM7R [0:31]
        /// CSGCMCCM7R
        CSGCMCCM7R: u32 = 0,
    };
    /// context swap register
    pub const CSGCMCCM7R = Register(CSGCMCCM7R_val).init(base_address + 0x6c);

    /// CSGCM0R
    const CSGCM0R_val = packed struct {
        /// CSGCM0R [0:31]
        /// CSGCM0R
        CSGCM0R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM0R = Register(CSGCM0R_val).init(base_address + 0x70);

    /// CSGCM1R
    const CSGCM1R_val = packed struct {
        /// CSGCM1R [0:31]
        /// CSGCM1R
        CSGCM1R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM1R = Register(CSGCM1R_val).init(base_address + 0x74);

    /// CSGCM2R
    const CSGCM2R_val = packed struct {
        /// CSGCM2R [0:31]
        /// CSGCM2R
        CSGCM2R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM2R = Register(CSGCM2R_val).init(base_address + 0x78);

    /// CSGCM3R
    const CSGCM3R_val = packed struct {
        /// CSGCM3R [0:31]
        /// CSGCM3R
        CSGCM3R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM3R = Register(CSGCM3R_val).init(base_address + 0x7c);

    /// CSGCM4R
    const CSGCM4R_val = packed struct {
        /// CSGCM4R [0:31]
        /// CSGCM4R
        CSGCM4R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM4R = Register(CSGCM4R_val).init(base_address + 0x80);

    /// CSGCM5R
    const CSGCM5R_val = packed struct {
        /// CSGCM5R [0:31]
        /// CSGCM5R
        CSGCM5R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM5R = Register(CSGCM5R_val).init(base_address + 0x84);

    /// CSGCM6R
    const CSGCM6R_val = packed struct {
        /// CSGCM6R [0:31]
        /// CSGCM6R
        CSGCM6R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM6R = Register(CSGCM6R_val).init(base_address + 0x88);

    /// CSGCM7R
    const CSGCM7R_val = packed struct {
        /// CSGCM7R [0:31]
        /// CSGCM7R
        CSGCM7R: u32 = 0,
    };
    /// context swap register
    pub const CSGCM7R = Register(CSGCM7R_val).init(base_address + 0x8c);
};

/// Digital camera interface
pub const DCMI = struct {
    const base_address = 0x50050000;
    /// CR
    const CR_val = packed struct {
        /// CAPTURE [0:0]
        /// Capture enable
        CAPTURE: u1 = 0,
        /// CM [1:1]
        /// Capture mode
        CM: u1 = 0,
        /// CROP [2:2]
        /// Crop feature
        CROP: u1 = 0,
        /// JPEG [3:3]
        /// JPEG format
        JPEG: u1 = 0,
        /// ESS [4:4]
        /// Embedded synchronization
        ESS: u1 = 0,
        /// PCKPOL [5:5]
        /// Pixel clock polarity
        PCKPOL: u1 = 0,
        /// HSPOL [6:6]
        /// Horizontal synchronization
        HSPOL: u1 = 0,
        /// VSPOL [7:7]
        /// Vertical synchronization
        VSPOL: u1 = 0,
        /// FCRC [8:9]
        /// Frame capture rate control
        FCRC: u2 = 0,
        /// EDM [10:11]
        /// Extended data mode
        EDM: u2 = 0,
        /// unused [12:13]
        _unused12: u2 = 0,
        /// ENABLE [14:14]
        /// DCMI enable
        ENABLE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// SR
    const SR_val = packed struct {
        /// HSYNC [0:0]
        /// HSYNC
        HSYNC: u1 = 0,
        /// VSYNC [1:1]
        /// VSYNC
        VSYNC: u1 = 0,
        /// FNE [2:2]
        /// FIFO not empty
        FNE: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x4);

    /// RIS
    const RIS_val = packed struct {
        /// FRAME_RIS [0:0]
        /// Capture complete raw interrupt
        FRAME_RIS: u1 = 0,
        /// OVR_RIS [1:1]
        /// Overrun raw interrupt
        OVR_RIS: u1 = 0,
        /// ERR_RIS [2:2]
        /// Synchronization error raw interrupt
        ERR_RIS: u1 = 0,
        /// VSYNC_RIS [3:3]
        /// VSYNC raw interrupt status
        VSYNC_RIS: u1 = 0,
        /// LINE_RIS [4:4]
        /// Line raw interrupt status
        LINE_RIS: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// raw interrupt status register
    pub const RIS = Register(RIS_val).init(base_address + 0x8);

    /// IER
    const IER_val = packed struct {
        /// FRAME_IE [0:0]
        /// Capture complete interrupt
        FRAME_IE: u1 = 0,
        /// OVR_IE [1:1]
        /// Overrun interrupt enable
        OVR_IE: u1 = 0,
        /// ERR_IE [2:2]
        /// Synchronization error interrupt
        ERR_IE: u1 = 0,
        /// VSYNC_IE [3:3]
        /// VSYNC interrupt enable
        VSYNC_IE: u1 = 0,
        /// LINE_IE [4:4]
        /// Line interrupt enable
        LINE_IE: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IER = Register(IER_val).init(base_address + 0xc);

    /// MIS
    const MIS_val = packed struct {
        /// FRAME_MIS [0:0]
        /// Capture complete masked interrupt
        FRAME_MIS: u1 = 0,
        /// OVR_MIS [1:1]
        /// Overrun masked interrupt
        OVR_MIS: u1 = 0,
        /// ERR_MIS [2:2]
        /// Synchronization error masked interrupt
        ERR_MIS: u1 = 0,
        /// VSYNC_MIS [3:3]
        /// VSYNC masked interrupt
        VSYNC_MIS: u1 = 0,
        /// LINE_MIS [4:4]
        /// Line masked interrupt
        LINE_MIS: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// masked interrupt status
    pub const MIS = Register(MIS_val).init(base_address + 0x10);

    /// ICR
    const ICR_val = packed struct {
        /// FRAME_ISC [0:0]
        /// Capture complete interrupt status
        FRAME_ISC: u1 = 0,
        /// OVR_ISC [1:1]
        /// Overrun interrupt status
        OVR_ISC: u1 = 0,
        /// ERR_ISC [2:2]
        /// Synchronization error interrupt status
        ERR_ISC: u1 = 0,
        /// VSYNC_ISC [3:3]
        /// Vertical synch interrupt status
        VSYNC_ISC: u1 = 0,
        /// LINE_ISC [4:4]
        /// line interrupt status
        LINE_ISC: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x14);

    /// ESCR
    const ESCR_val = packed struct {
        /// FSC [0:7]
        /// Frame start delimiter code
        FSC: u8 = 0,
        /// LSC [8:15]
        /// Line start delimiter code
        LSC: u8 = 0,
        /// LEC [16:23]
        /// Line end delimiter code
        LEC: u8 = 0,
        /// FEC [24:31]
        /// Frame end delimiter code
        FEC: u8 = 0,
    };
    /// embedded synchronization code
    pub const ESCR = Register(ESCR_val).init(base_address + 0x18);

    /// ESUR
    const ESUR_val = packed struct {
        /// FSU [0:7]
        /// Frame start delimiter
        FSU: u8 = 0,
        /// LSU [8:15]
        /// Line start delimiter
        LSU: u8 = 0,
        /// LEU [16:23]
        /// Line end delimiter unmask
        LEU: u8 = 0,
        /// FEU [24:31]
        /// Frame end delimiter unmask
        FEU: u8 = 0,
    };
    /// embedded synchronization unmask
    pub const ESUR = Register(ESUR_val).init(base_address + 0x1c);

    /// CWSTRT
    const CWSTRT_val = packed struct {
        /// HOFFCNT [0:13]
        /// Horizontal offset count
        HOFFCNT: u14 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// VST [16:28]
        /// Vertical start line count
        VST: u13 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// crop window start
    pub const CWSTRT = Register(CWSTRT_val).init(base_address + 0x20);

    /// CWSIZE
    const CWSIZE_val = packed struct {
        /// CAPCNT [0:13]
        /// Capture count
        CAPCNT: u14 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// VLINE [16:29]
        /// Vertical line count
        VLINE: u14 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// crop window size
    pub const CWSIZE = Register(CWSIZE_val).init(base_address + 0x24);

    /// DR
    const DR_val = packed struct {
        /// Byte0 [0:7]
        /// Data byte 0
        Byte0: u8 = 0,
        /// Byte1 [8:15]
        /// Data byte 1
        Byte1: u8 = 0,
        /// Byte2 [16:23]
        /// Data byte 2
        Byte2: u8 = 0,
        /// Byte3 [24:31]
        /// Data byte 3
        Byte3: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0x28);
};

/// Flexible memory controller
pub const FMC = struct {
    const base_address = 0xa0000000;
    /// BCR1
    const BCR1_val = packed struct {
        /// MBKEN [0:0]
        /// MBKEN
        MBKEN: u1 = 0,
        /// MUXEN [1:1]
        /// MUXEN
        MUXEN: u1 = 0,
        /// MTYP [2:3]
        /// MTYP
        MTYP: u2 = 0,
        /// MWID [4:5]
        /// MWID
        MWID: u2 = 1,
        /// FACCEN [6:6]
        /// FACCEN
        FACCEN: u1 = 1,
        /// unused [7:7]
        _unused7: u1 = 1,
        /// BURSTEN [8:8]
        /// BURSTEN
        BURSTEN: u1 = 0,
        /// WAITPOL [9:9]
        /// WAITPOL
        WAITPOL: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// WAITCFG [11:11]
        /// WAITCFG
        WAITCFG: u1 = 0,
        /// WREN [12:12]
        /// WREN
        WREN: u1 = 1,
        /// WAITEN [13:13]
        /// WAITEN
        WAITEN: u1 = 1,
        /// EXTMOD [14:14]
        /// EXTMOD
        EXTMOD: u1 = 0,
        /// ASYNCWAIT [15:15]
        /// ASYNCWAIT
        ASYNCWAIT: u1 = 0,
        /// unused [16:18]
        _unused16: u3 = 0,
        /// CBURSTRW [19:19]
        /// CBURSTRW
        CBURSTRW: u1 = 0,
        /// CCLKEN [20:20]
        /// CCLKEN
        CCLKEN: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// SRAM/NOR-Flash chip-select control register
    pub const BCR1 = Register(BCR1_val).init(base_address + 0x0);

    /// BTR1
    const BTR1_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// BUSTURN [16:19]
        /// BUSTURN
        BUSTURN: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 3,
        /// unused [30:31]
        _unused30: u2 = 3,
    };
    /// SRAM/NOR-Flash chip-select timing register
    pub const BTR1 = Register(BTR1_val).init(base_address + 0x4);

    /// BCR2
    const BCR2_val = packed struct {
        /// MBKEN [0:0]
        /// MBKEN
        MBKEN: u1 = 0,
        /// MUXEN [1:1]
        /// MUXEN
        MUXEN: u1 = 0,
        /// MTYP [2:3]
        /// MTYP
        MTYP: u2 = 0,
        /// MWID [4:5]
        /// MWID
        MWID: u2 = 1,
        /// FACCEN [6:6]
        /// FACCEN
        FACCEN: u1 = 1,
        /// unused [7:7]
        _unused7: u1 = 1,
        /// BURSTEN [8:8]
        /// BURSTEN
        BURSTEN: u1 = 0,
        /// WAITPOL [9:9]
        /// WAITPOL
        WAITPOL: u1 = 0,
        /// WRAPMOD [10:10]
        /// WRAPMOD
        WRAPMOD: u1 = 0,
        /// WAITCFG [11:11]
        /// WAITCFG
        WAITCFG: u1 = 0,
        /// WREN [12:12]
        /// WREN
        WREN: u1 = 1,
        /// WAITEN [13:13]
        /// WAITEN
        WAITEN: u1 = 1,
        /// EXTMOD [14:14]
        /// EXTMOD
        EXTMOD: u1 = 0,
        /// ASYNCWAIT [15:15]
        /// ASYNCWAIT
        ASYNCWAIT: u1 = 0,
        /// unused [16:18]
        _unused16: u3 = 0,
        /// CBURSTRW [19:19]
        /// CBURSTRW
        CBURSTRW: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// SRAM/NOR-Flash chip-select control register
    pub const BCR2 = Register(BCR2_val).init(base_address + 0x8);

    /// BTR2
    const BTR2_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// BUSTURN [16:19]
        /// BUSTURN
        BUSTURN: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 3,
        /// unused [30:31]
        _unused30: u2 = 3,
    };
    /// SRAM/NOR-Flash chip-select timing register
    pub const BTR2 = Register(BTR2_val).init(base_address + 0xc);

    /// BCR3
    const BCR3_val = packed struct {
        /// MBKEN [0:0]
        /// MBKEN
        MBKEN: u1 = 0,
        /// MUXEN [1:1]
        /// MUXEN
        MUXEN: u1 = 0,
        /// MTYP [2:3]
        /// MTYP
        MTYP: u2 = 0,
        /// MWID [4:5]
        /// MWID
        MWID: u2 = 1,
        /// FACCEN [6:6]
        /// FACCEN
        FACCEN: u1 = 1,
        /// unused [7:7]
        _unused7: u1 = 1,
        /// BURSTEN [8:8]
        /// BURSTEN
        BURSTEN: u1 = 0,
        /// WAITPOL [9:9]
        /// WAITPOL
        WAITPOL: u1 = 0,
        /// WRAPMOD [10:10]
        /// WRAPMOD
        WRAPMOD: u1 = 0,
        /// WAITCFG [11:11]
        /// WAITCFG
        WAITCFG: u1 = 0,
        /// WREN [12:12]
        /// WREN
        WREN: u1 = 1,
        /// WAITEN [13:13]
        /// WAITEN
        WAITEN: u1 = 1,
        /// EXTMOD [14:14]
        /// EXTMOD
        EXTMOD: u1 = 0,
        /// ASYNCWAIT [15:15]
        /// ASYNCWAIT
        ASYNCWAIT: u1 = 0,
        /// unused [16:18]
        _unused16: u3 = 0,
        /// CBURSTRW [19:19]
        /// CBURSTRW
        CBURSTRW: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// SRAM/NOR-Flash chip-select control register
    pub const BCR3 = Register(BCR3_val).init(base_address + 0x10);

    /// BTR3
    const BTR3_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// BUSTURN [16:19]
        /// BUSTURN
        BUSTURN: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 3,
        /// unused [30:31]
        _unused30: u2 = 3,
    };
    /// SRAM/NOR-Flash chip-select timing register
    pub const BTR3 = Register(BTR3_val).init(base_address + 0x14);

    /// BCR4
    const BCR4_val = packed struct {
        /// MBKEN [0:0]
        /// MBKEN
        MBKEN: u1 = 0,
        /// MUXEN [1:1]
        /// MUXEN
        MUXEN: u1 = 0,
        /// MTYP [2:3]
        /// MTYP
        MTYP: u2 = 0,
        /// MWID [4:5]
        /// MWID
        MWID: u2 = 1,
        /// FACCEN [6:6]
        /// FACCEN
        FACCEN: u1 = 1,
        /// unused [7:7]
        _unused7: u1 = 1,
        /// BURSTEN [8:8]
        /// BURSTEN
        BURSTEN: u1 = 0,
        /// WAITPOL [9:9]
        /// WAITPOL
        WAITPOL: u1 = 0,
        /// WRAPMOD [10:10]
        /// WRAPMOD
        WRAPMOD: u1 = 0,
        /// WAITCFG [11:11]
        /// WAITCFG
        WAITCFG: u1 = 0,
        /// WREN [12:12]
        /// WREN
        WREN: u1 = 1,
        /// WAITEN [13:13]
        /// WAITEN
        WAITEN: u1 = 1,
        /// EXTMOD [14:14]
        /// EXTMOD
        EXTMOD: u1 = 0,
        /// ASYNCWAIT [15:15]
        /// ASYNCWAIT
        ASYNCWAIT: u1 = 0,
        /// unused [16:18]
        _unused16: u3 = 0,
        /// CBURSTRW [19:19]
        /// CBURSTRW
        CBURSTRW: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// SRAM/NOR-Flash chip-select control register
    pub const BCR4 = Register(BCR4_val).init(base_address + 0x18);

    /// BTR4
    const BTR4_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// BUSTURN [16:19]
        /// BUSTURN
        BUSTURN: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 3,
        /// unused [30:31]
        _unused30: u2 = 3,
    };
    /// SRAM/NOR-Flash chip-select timing register
    pub const BTR4 = Register(BTR4_val).init(base_address + 0x1c);

    /// PCR
    const PCR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// PWAITEN [1:1]
        /// PWAITEN
        PWAITEN: u1 = 0,
        /// PBKEN [2:2]
        /// PBKEN
        PBKEN: u1 = 0,
        /// PTYP [3:3]
        /// PTYP
        PTYP: u1 = 1,
        /// PWID [4:5]
        /// PWID
        PWID: u2 = 1,
        /// ECCEN [6:6]
        /// ECCEN
        ECCEN: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// TCLR [9:12]
        /// TCLR
        TCLR: u4 = 0,
        /// TAR [13:16]
        /// TAR
        TAR: u4 = 0,
        /// ECCPS [17:19]
        /// ECCPS
        ECCPS: u3 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// PC Card/NAND Flash control
    pub const PCR = Register(PCR_val).init(base_address + 0x80);

    /// SR
    const SR_val = packed struct {
        /// IRS [0:0]
        /// IRS
        IRS: u1 = 0,
        /// ILS [1:1]
        /// ILS
        ILS: u1 = 0,
        /// IFS [2:2]
        /// IFS
        IFS: u1 = 0,
        /// IREN [3:3]
        /// IREN
        IREN: u1 = 0,
        /// ILEN [4:4]
        /// ILEN
        ILEN: u1 = 0,
        /// IFEN [5:5]
        /// IFEN
        IFEN: u1 = 0,
        /// FEMPT [6:6]
        /// FEMPT
        FEMPT: u1 = 1,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// FIFO status and interrupt
    pub const SR = Register(SR_val).init(base_address + 0x84);

    /// PMEM
    const PMEM_val = packed struct {
        /// MEMSETx [0:7]
        /// MEMSETx
        MEMSETx: u8 = 252,
        /// MEMWAITx [8:15]
        /// MEMWAITx
        MEMWAITx: u8 = 252,
        /// MEMHOLDx [16:23]
        /// MEMHOLDx
        MEMHOLDx: u8 = 252,
        /// MEMHIZx [24:31]
        /// MEMHIZx
        MEMHIZx: u8 = 252,
    };
    /// Common memory space timing
    pub const PMEM = Register(PMEM_val).init(base_address + 0x88);

    /// PATT
    const PATT_val = packed struct {
        /// ATTSETx [0:7]
        /// ATTSETx
        ATTSETx: u8 = 252,
        /// ATTWAITx [8:15]
        /// ATTWAITx
        ATTWAITx: u8 = 252,
        /// ATTHOLDx [16:23]
        /// ATTHOLDx
        ATTHOLDx: u8 = 252,
        /// ATTHIZx [24:31]
        /// ATTHIZx
        ATTHIZx: u8 = 252,
    };
    /// Attribute memory space timing
    pub const PATT = Register(PATT_val).init(base_address + 0x8c);

    /// ECCR
    const ECCR_val = packed struct {
        /// ECCx [0:31]
        /// ECCx
        ECCx: u32 = 0,
    };
    /// ECC result register
    pub const ECCR = Register(ECCR_val).init(base_address + 0x94);

    /// BWTR1
    const BWTR1_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// unused [16:19]
        _unused16: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// SRAM/NOR-Flash write timing registers
    pub const BWTR1 = Register(BWTR1_val).init(base_address + 0x104);

    /// BWTR2
    const BWTR2_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// unused [16:19]
        _unused16: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// SRAM/NOR-Flash write timing registers
    pub const BWTR2 = Register(BWTR2_val).init(base_address + 0x10c);

    /// BWTR3
    const BWTR3_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// unused [16:19]
        _unused16: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// SRAM/NOR-Flash write timing registers
    pub const BWTR3 = Register(BWTR3_val).init(base_address + 0x114);

    /// BWTR4
    const BWTR4_val = packed struct {
        /// ADDSET [0:3]
        /// ADDSET
        ADDSET: u4 = 15,
        /// ADDHLD [4:7]
        /// ADDHLD
        ADDHLD: u4 = 15,
        /// DATAST [8:15]
        /// DATAST
        DATAST: u8 = 255,
        /// unused [16:19]
        _unused16: u4 = 15,
        /// CLKDIV [20:23]
        /// CLKDIV
        CLKDIV: u4 = 15,
        /// DATLAT [24:27]
        /// DATLAT
        DATLAT: u4 = 15,
        /// ACCMOD [28:29]
        /// ACCMOD
        ACCMOD: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// SRAM/NOR-Flash write timing registers
    pub const BWTR4 = Register(BWTR4_val).init(base_address + 0x11c);

    /// SDCR1
    const SDCR1_val = packed struct {
        /// NC [0:1]
        /// Number of column address
        NC: u2 = 0,
        /// NR [2:3]
        /// Number of row address bits
        NR: u2 = 0,
        /// MWID [4:5]
        /// Memory data bus width
        MWID: u2 = 1,
        /// NB [6:6]
        /// Number of internal banks
        NB: u1 = 1,
        /// CAS [7:8]
        /// CAS latency
        CAS: u2 = 1,
        /// WP [9:9]
        /// Write protection
        WP: u1 = 1,
        /// SDCLK [10:11]
        /// SDRAM clock configuration
        SDCLK: u2 = 0,
        /// RBURST [12:12]
        /// Burst read
        RBURST: u1 = 0,
        /// RPIPE [13:14]
        /// Read pipe
        RPIPE: u2 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDRAM Control Register 1
    pub const SDCR1 = Register(SDCR1_val).init(base_address + 0x140);

    /// SDCR2
    const SDCR2_val = packed struct {
        /// NC [0:1]
        /// Number of column address
        NC: u2 = 0,
        /// NR [2:3]
        /// Number of row address bits
        NR: u2 = 0,
        /// MWID [4:5]
        /// Memory data bus width
        MWID: u2 = 1,
        /// NB [6:6]
        /// Number of internal banks
        NB: u1 = 1,
        /// CAS [7:8]
        /// CAS latency
        CAS: u2 = 1,
        /// WP [9:9]
        /// Write protection
        WP: u1 = 1,
        /// SDCLK [10:11]
        /// SDRAM clock configuration
        SDCLK: u2 = 0,
        /// RBURST [12:12]
        /// Burst read
        RBURST: u1 = 0,
        /// RPIPE [13:14]
        /// Read pipe
        RPIPE: u2 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDRAM Control Register 2
    pub const SDCR2 = Register(SDCR2_val).init(base_address + 0x144);

    /// SDTR1
    const SDTR1_val = packed struct {
        /// TMRD [0:3]
        /// Load Mode Register to
        TMRD: u4 = 15,
        /// TXSR [4:7]
        /// Exit self-refresh delay
        TXSR: u4 = 15,
        /// TRAS [8:11]
        /// Self refresh time
        TRAS: u4 = 15,
        /// TRC [12:15]
        /// Row cycle delay
        TRC: u4 = 15,
        /// TWR [16:19]
        /// Recovery delay
        TWR: u4 = 15,
        /// TRP [20:23]
        /// Row precharge delay
        TRP: u4 = 15,
        /// TRCD [24:27]
        /// Row to column delay
        TRCD: u4 = 15,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// SDRAM Timing register 1
    pub const SDTR1 = Register(SDTR1_val).init(base_address + 0x148);

    /// SDTR2
    const SDTR2_val = packed struct {
        /// TMRD [0:3]
        /// Load Mode Register to
        TMRD: u4 = 15,
        /// TXSR [4:7]
        /// Exit self-refresh delay
        TXSR: u4 = 15,
        /// TRAS [8:11]
        /// Self refresh time
        TRAS: u4 = 15,
        /// TRC [12:15]
        /// Row cycle delay
        TRC: u4 = 15,
        /// TWR [16:19]
        /// Recovery delay
        TWR: u4 = 15,
        /// TRP [20:23]
        /// Row precharge delay
        TRP: u4 = 15,
        /// TRCD [24:27]
        /// Row to column delay
        TRCD: u4 = 15,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// SDRAM Timing register 2
    pub const SDTR2 = Register(SDTR2_val).init(base_address + 0x14c);

    /// SDCMR
    const SDCMR_val = packed struct {
        /// MODE [0:2]
        /// Command mode
        MODE: u3 = 0,
        /// CTB2 [3:3]
        /// Command target bank 2
        CTB2: u1 = 0,
        /// CTB1 [4:4]
        /// Command target bank 1
        CTB1: u1 = 0,
        /// NRFS [5:8]
        /// Number of Auto-refresh
        NRFS: u4 = 0,
        /// MRD [9:21]
        /// Mode Register definition
        MRD: u13 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// SDRAM Command Mode register
    pub const SDCMR = Register(SDCMR_val).init(base_address + 0x150);

    /// SDRTR
    const SDRTR_val = packed struct {
        /// CRE [0:0]
        /// Clear Refresh error flag
        CRE: u1 = 0,
        /// COUNT [1:13]
        /// Refresh Timer Count
        COUNT: u13 = 0,
        /// REIE [14:14]
        /// RES Interrupt Enable
        REIE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDRAM Refresh Timer register
    pub const SDRTR = Register(SDRTR_val).init(base_address + 0x154);

    /// SDSR
    const SDSR_val = packed struct {
        /// RE [0:0]
        /// Refresh error flag
        RE: u1 = 0,
        /// MODES1 [1:2]
        /// Status Mode for Bank 1
        MODES1: u2 = 0,
        /// MODES2 [3:4]
        /// Status Mode for Bank 2
        MODES2: u2 = 0,
        /// BUSY [5:5]
        /// Busy status
        BUSY: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDRAM Status register
    pub const SDSR = Register(SDSR_val).init(base_address + 0x158);
};

/// DMA controller
pub const DMA2 = struct {
    const base_address = 0x40026400;
    /// LISR
    const LISR_val = packed struct {
        /// FEIF0 [0:0]
        /// Stream x FIFO error interrupt flag
        FEIF0: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DMEIF0 [2:2]
        /// Stream x direct mode error interrupt
        DMEIF0: u1 = 0,
        /// TEIF0 [3:3]
        /// Stream x transfer error interrupt flag
        TEIF0: u1 = 0,
        /// HTIF0 [4:4]
        /// Stream x half transfer interrupt flag
        HTIF0: u1 = 0,
        /// TCIF0 [5:5]
        /// Stream x transfer complete interrupt
        TCIF0: u1 = 0,
        /// FEIF1 [6:6]
        /// Stream x FIFO error interrupt flag
        FEIF1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DMEIF1 [8:8]
        /// Stream x direct mode error interrupt
        DMEIF1: u1 = 0,
        /// TEIF1 [9:9]
        /// Stream x transfer error interrupt flag
        TEIF1: u1 = 0,
        /// HTIF1 [10:10]
        /// Stream x half transfer interrupt flag
        HTIF1: u1 = 0,
        /// TCIF1 [11:11]
        /// Stream x transfer complete interrupt
        TCIF1: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FEIF2 [16:16]
        /// Stream x FIFO error interrupt flag
        FEIF2: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// DMEIF2 [18:18]
        /// Stream x direct mode error interrupt
        DMEIF2: u1 = 0,
        /// TEIF2 [19:19]
        /// Stream x transfer error interrupt flag
        TEIF2: u1 = 0,
        /// HTIF2 [20:20]
        /// Stream x half transfer interrupt flag
        HTIF2: u1 = 0,
        /// TCIF2 [21:21]
        /// Stream x transfer complete interrupt
        TCIF2: u1 = 0,
        /// FEIF3 [22:22]
        /// Stream x FIFO error interrupt flag
        FEIF3: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// DMEIF3 [24:24]
        /// Stream x direct mode error interrupt
        DMEIF3: u1 = 0,
        /// TEIF3 [25:25]
        /// Stream x transfer error interrupt flag
        TEIF3: u1 = 0,
        /// HTIF3 [26:26]
        /// Stream x half transfer interrupt flag
        HTIF3: u1 = 0,
        /// TCIF3 [27:27]
        /// Stream x transfer complete interrupt
        TCIF3: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// low interrupt status register
    pub const LISR = Register(LISR_val).init(base_address + 0x0);

    /// HISR
    const HISR_val = packed struct {
        /// FEIF4 [0:0]
        /// Stream x FIFO error interrupt flag
        FEIF4: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DMEIF4 [2:2]
        /// Stream x direct mode error interrupt
        DMEIF4: u1 = 0,
        /// TEIF4 [3:3]
        /// Stream x transfer error interrupt flag
        TEIF4: u1 = 0,
        /// HTIF4 [4:4]
        /// Stream x half transfer interrupt flag
        HTIF4: u1 = 0,
        /// TCIF4 [5:5]
        /// Stream x transfer complete interrupt
        TCIF4: u1 = 0,
        /// FEIF5 [6:6]
        /// Stream x FIFO error interrupt flag
        FEIF5: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DMEIF5 [8:8]
        /// Stream x direct mode error interrupt
        DMEIF5: u1 = 0,
        /// TEIF5 [9:9]
        /// Stream x transfer error interrupt flag
        TEIF5: u1 = 0,
        /// HTIF5 [10:10]
        /// Stream x half transfer interrupt flag
        HTIF5: u1 = 0,
        /// TCIF5 [11:11]
        /// Stream x transfer complete interrupt
        TCIF5: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FEIF6 [16:16]
        /// Stream x FIFO error interrupt flag
        FEIF6: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// DMEIF6 [18:18]
        /// Stream x direct mode error interrupt
        DMEIF6: u1 = 0,
        /// TEIF6 [19:19]
        /// Stream x transfer error interrupt flag
        TEIF6: u1 = 0,
        /// HTIF6 [20:20]
        /// Stream x half transfer interrupt flag
        HTIF6: u1 = 0,
        /// TCIF6 [21:21]
        /// Stream x transfer complete interrupt
        TCIF6: u1 = 0,
        /// FEIF7 [22:22]
        /// Stream x FIFO error interrupt flag
        FEIF7: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// DMEIF7 [24:24]
        /// Stream x direct mode error interrupt
        DMEIF7: u1 = 0,
        /// TEIF7 [25:25]
        /// Stream x transfer error interrupt flag
        TEIF7: u1 = 0,
        /// HTIF7 [26:26]
        /// Stream x half transfer interrupt flag
        HTIF7: u1 = 0,
        /// TCIF7 [27:27]
        /// Stream x transfer complete interrupt
        TCIF7: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// high interrupt status register
    pub const HISR = Register(HISR_val).init(base_address + 0x4);

    /// LIFCR
    const LIFCR_val = packed struct {
        /// CFEIF0 [0:0]
        /// Stream x clear FIFO error interrupt flag
        CFEIF0: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CDMEIF0 [2:2]
        /// Stream x clear direct mode error
        CDMEIF0: u1 = 0,
        /// CTEIF0 [3:3]
        /// Stream x clear transfer error interrupt
        CTEIF0: u1 = 0,
        /// CHTIF0 [4:4]
        /// Stream x clear half transfer interrupt
        CHTIF0: u1 = 0,
        /// CTCIF0 [5:5]
        /// Stream x clear transfer complete
        CTCIF0: u1 = 0,
        /// CFEIF1 [6:6]
        /// Stream x clear FIFO error interrupt flag
        CFEIF1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CDMEIF1 [8:8]
        /// Stream x clear direct mode error
        CDMEIF1: u1 = 0,
        /// CTEIF1 [9:9]
        /// Stream x clear transfer error interrupt
        CTEIF1: u1 = 0,
        /// CHTIF1 [10:10]
        /// Stream x clear half transfer interrupt
        CHTIF1: u1 = 0,
        /// CTCIF1 [11:11]
        /// Stream x clear transfer complete
        CTCIF1: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// CFEIF2 [16:16]
        /// Stream x clear FIFO error interrupt flag
        CFEIF2: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// CDMEIF2 [18:18]
        /// Stream x clear direct mode error
        CDMEIF2: u1 = 0,
        /// CTEIF2 [19:19]
        /// Stream x clear transfer error interrupt
        CTEIF2: u1 = 0,
        /// CHTIF2 [20:20]
        /// Stream x clear half transfer interrupt
        CHTIF2: u1 = 0,
        /// CTCIF2 [21:21]
        /// Stream x clear transfer complete
        CTCIF2: u1 = 0,
        /// CFEIF3 [22:22]
        /// Stream x clear FIFO error interrupt flag
        CFEIF3: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// CDMEIF3 [24:24]
        /// Stream x clear direct mode error
        CDMEIF3: u1 = 0,
        /// CTEIF3 [25:25]
        /// Stream x clear transfer error interrupt
        CTEIF3: u1 = 0,
        /// CHTIF3 [26:26]
        /// Stream x clear half transfer interrupt
        CHTIF3: u1 = 0,
        /// CTCIF3 [27:27]
        /// Stream x clear transfer complete
        CTCIF3: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// low interrupt flag clear
    pub const LIFCR = Register(LIFCR_val).init(base_address + 0x8);

    /// HIFCR
    const HIFCR_val = packed struct {
        /// CFEIF4 [0:0]
        /// Stream x clear FIFO error interrupt flag
        CFEIF4: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CDMEIF4 [2:2]
        /// Stream x clear direct mode error
        CDMEIF4: u1 = 0,
        /// CTEIF4 [3:3]
        /// Stream x clear transfer error interrupt
        CTEIF4: u1 = 0,
        /// CHTIF4 [4:4]
        /// Stream x clear half transfer interrupt
        CHTIF4: u1 = 0,
        /// CTCIF4 [5:5]
        /// Stream x clear transfer complete
        CTCIF4: u1 = 0,
        /// CFEIF5 [6:6]
        /// Stream x clear FIFO error interrupt flag
        CFEIF5: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CDMEIF5 [8:8]
        /// Stream x clear direct mode error
        CDMEIF5: u1 = 0,
        /// CTEIF5 [9:9]
        /// Stream x clear transfer error interrupt
        CTEIF5: u1 = 0,
        /// CHTIF5 [10:10]
        /// Stream x clear half transfer interrupt
        CHTIF5: u1 = 0,
        /// CTCIF5 [11:11]
        /// Stream x clear transfer complete
        CTCIF5: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// CFEIF6 [16:16]
        /// Stream x clear FIFO error interrupt flag
        CFEIF6: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// CDMEIF6 [18:18]
        /// Stream x clear direct mode error
        CDMEIF6: u1 = 0,
        /// CTEIF6 [19:19]
        /// Stream x clear transfer error interrupt
        CTEIF6: u1 = 0,
        /// CHTIF6 [20:20]
        /// Stream x clear half transfer interrupt
        CHTIF6: u1 = 0,
        /// CTCIF6 [21:21]
        /// Stream x clear transfer complete
        CTCIF6: u1 = 0,
        /// CFEIF7 [22:22]
        /// Stream x clear FIFO error interrupt flag
        CFEIF7: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// CDMEIF7 [24:24]
        /// Stream x clear direct mode error
        CDMEIF7: u1 = 0,
        /// CTEIF7 [25:25]
        /// Stream x clear transfer error interrupt
        CTEIF7: u1 = 0,
        /// CHTIF7 [26:26]
        /// Stream x clear half transfer interrupt
        CHTIF7: u1 = 0,
        /// CTCIF7 [27:27]
        /// Stream x clear transfer complete
        CTCIF7: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// high interrupt flag clear
    pub const HIFCR = Register(HIFCR_val).init(base_address + 0xc);

    /// S0CR
    const S0CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S0CR = Register(S0CR_val).init(base_address + 0x10);

    /// S0NDTR
    const S0NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S0NDTR = Register(S0NDTR_val).init(base_address + 0x14);

    /// S0PAR
    const S0PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S0PAR = Register(S0PAR_val).init(base_address + 0x18);

    /// S0M0AR
    const S0M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S0M0AR = Register(S0M0AR_val).init(base_address + 0x1c);

    /// S0M1AR
    const S0M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S0M1AR = Register(S0M1AR_val).init(base_address + 0x20);

    /// S0FCR
    const S0FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S0FCR = Register(S0FCR_val).init(base_address + 0x24);

    /// S1CR
    const S1CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S1CR = Register(S1CR_val).init(base_address + 0x28);

    /// S1NDTR
    const S1NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S1NDTR = Register(S1NDTR_val).init(base_address + 0x2c);

    /// S1PAR
    const S1PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S1PAR = Register(S1PAR_val).init(base_address + 0x30);

    /// S1M0AR
    const S1M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S1M0AR = Register(S1M0AR_val).init(base_address + 0x34);

    /// S1M1AR
    const S1M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S1M1AR = Register(S1M1AR_val).init(base_address + 0x38);

    /// S1FCR
    const S1FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S1FCR = Register(S1FCR_val).init(base_address + 0x3c);

    /// S2CR
    const S2CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S2CR = Register(S2CR_val).init(base_address + 0x40);

    /// S2NDTR
    const S2NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S2NDTR = Register(S2NDTR_val).init(base_address + 0x44);

    /// S2PAR
    const S2PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S2PAR = Register(S2PAR_val).init(base_address + 0x48);

    /// S2M0AR
    const S2M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S2M0AR = Register(S2M0AR_val).init(base_address + 0x4c);

    /// S2M1AR
    const S2M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S2M1AR = Register(S2M1AR_val).init(base_address + 0x50);

    /// S2FCR
    const S2FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S2FCR = Register(S2FCR_val).init(base_address + 0x54);

    /// S3CR
    const S3CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S3CR = Register(S3CR_val).init(base_address + 0x58);

    /// S3NDTR
    const S3NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S3NDTR = Register(S3NDTR_val).init(base_address + 0x5c);

    /// S3PAR
    const S3PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S3PAR = Register(S3PAR_val).init(base_address + 0x60);

    /// S3M0AR
    const S3M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S3M0AR = Register(S3M0AR_val).init(base_address + 0x64);

    /// S3M1AR
    const S3M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S3M1AR = Register(S3M1AR_val).init(base_address + 0x68);

    /// S3FCR
    const S3FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S3FCR = Register(S3FCR_val).init(base_address + 0x6c);

    /// S4CR
    const S4CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:27]
        /// Channel selection
        CHSEL: u3 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// stream x configuration
    pub const S4CR = Register(S4CR_val).init(base_address + 0x70);

    /// S4NDTR
    const S4NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S4NDTR = Register(S4NDTR_val).init(base_address + 0x74);

    /// S4PAR
    const S4PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S4PAR = Register(S4PAR_val).init(base_address + 0x78);

    /// S4M0AR
    const S4M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S4M0AR = Register(S4M0AR_val).init(base_address + 0x7c);

    /// S4M1AR
    const S4M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S4M1AR = Register(S4M1AR_val).init(base_address + 0x80);

    /// S4FCR
    const S4FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S4FCR = Register(S4FCR_val).init(base_address + 0x84);

    /// S5CR
    const S5CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S5CR = Register(S5CR_val).init(base_address + 0x88);

    /// S5NDTR
    const S5NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S5NDTR = Register(S5NDTR_val).init(base_address + 0x8c);

    /// S5PAR
    const S5PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S5PAR = Register(S5PAR_val).init(base_address + 0x90);

    /// S5M0AR
    const S5M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S5M0AR = Register(S5M0AR_val).init(base_address + 0x94);

    /// S5M1AR
    const S5M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S5M1AR = Register(S5M1AR_val).init(base_address + 0x98);

    /// S5FCR
    const S5FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S5FCR = Register(S5FCR_val).init(base_address + 0x9c);

    /// S6CR
    const S6CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S6CR = Register(S6CR_val).init(base_address + 0xa0);

    /// S6NDTR
    const S6NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S6NDTR = Register(S6NDTR_val).init(base_address + 0xa4);

    /// S6PAR
    const S6PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S6PAR = Register(S6PAR_val).init(base_address + 0xa8);

    /// S6M0AR
    const S6M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S6M0AR = Register(S6M0AR_val).init(base_address + 0xac);

    /// S6M1AR
    const S6M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S6M1AR = Register(S6M1AR_val).init(base_address + 0xb0);

    /// S6FCR
    const S6FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S6FCR = Register(S6FCR_val).init(base_address + 0xb4);

    /// S7CR
    const S7CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S7CR = Register(S7CR_val).init(base_address + 0xb8);

    /// S7NDTR
    const S7NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S7NDTR = Register(S7NDTR_val).init(base_address + 0xbc);

    /// S7PAR
    const S7PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S7PAR = Register(S7PAR_val).init(base_address + 0xc0);

    /// S7M0AR
    const S7M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S7M0AR = Register(S7M0AR_val).init(base_address + 0xc4);

    /// S7M1AR
    const S7M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S7M1AR = Register(S7M1AR_val).init(base_address + 0xc8);

    /// S7FCR
    const S7FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S7FCR = Register(S7FCR_val).init(base_address + 0xcc);
};

/// DMA controller
pub const DMA1 = struct {
    const base_address = 0x40026000;
    /// LISR
    const LISR_val = packed struct {
        /// FEIF0 [0:0]
        /// Stream x FIFO error interrupt flag
        FEIF0: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DMEIF0 [2:2]
        /// Stream x direct mode error interrupt
        DMEIF0: u1 = 0,
        /// TEIF0 [3:3]
        /// Stream x transfer error interrupt flag
        TEIF0: u1 = 0,
        /// HTIF0 [4:4]
        /// Stream x half transfer interrupt flag
        HTIF0: u1 = 0,
        /// TCIF0 [5:5]
        /// Stream x transfer complete interrupt
        TCIF0: u1 = 0,
        /// FEIF1 [6:6]
        /// Stream x FIFO error interrupt flag
        FEIF1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DMEIF1 [8:8]
        /// Stream x direct mode error interrupt
        DMEIF1: u1 = 0,
        /// TEIF1 [9:9]
        /// Stream x transfer error interrupt flag
        TEIF1: u1 = 0,
        /// HTIF1 [10:10]
        /// Stream x half transfer interrupt flag
        HTIF1: u1 = 0,
        /// TCIF1 [11:11]
        /// Stream x transfer complete interrupt
        TCIF1: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FEIF2 [16:16]
        /// Stream x FIFO error interrupt flag
        FEIF2: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// DMEIF2 [18:18]
        /// Stream x direct mode error interrupt
        DMEIF2: u1 = 0,
        /// TEIF2 [19:19]
        /// Stream x transfer error interrupt flag
        TEIF2: u1 = 0,
        /// HTIF2 [20:20]
        /// Stream x half transfer interrupt flag
        HTIF2: u1 = 0,
        /// TCIF2 [21:21]
        /// Stream x transfer complete interrupt
        TCIF2: u1 = 0,
        /// FEIF3 [22:22]
        /// Stream x FIFO error interrupt flag
        FEIF3: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// DMEIF3 [24:24]
        /// Stream x direct mode error interrupt
        DMEIF3: u1 = 0,
        /// TEIF3 [25:25]
        /// Stream x transfer error interrupt flag
        TEIF3: u1 = 0,
        /// HTIF3 [26:26]
        /// Stream x half transfer interrupt flag
        HTIF3: u1 = 0,
        /// TCIF3 [27:27]
        /// Stream x transfer complete interrupt
        TCIF3: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// low interrupt status register
    pub const LISR = Register(LISR_val).init(base_address + 0x0);

    /// HISR
    const HISR_val = packed struct {
        /// FEIF4 [0:0]
        /// Stream x FIFO error interrupt flag
        FEIF4: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// DMEIF4 [2:2]
        /// Stream x direct mode error interrupt
        DMEIF4: u1 = 0,
        /// TEIF4 [3:3]
        /// Stream x transfer error interrupt flag
        TEIF4: u1 = 0,
        /// HTIF4 [4:4]
        /// Stream x half transfer interrupt flag
        HTIF4: u1 = 0,
        /// TCIF4 [5:5]
        /// Stream x transfer complete interrupt
        TCIF4: u1 = 0,
        /// FEIF5 [6:6]
        /// Stream x FIFO error interrupt flag
        FEIF5: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DMEIF5 [8:8]
        /// Stream x direct mode error interrupt
        DMEIF5: u1 = 0,
        /// TEIF5 [9:9]
        /// Stream x transfer error interrupt flag
        TEIF5: u1 = 0,
        /// HTIF5 [10:10]
        /// Stream x half transfer interrupt flag
        HTIF5: u1 = 0,
        /// TCIF5 [11:11]
        /// Stream x transfer complete interrupt
        TCIF5: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// FEIF6 [16:16]
        /// Stream x FIFO error interrupt flag
        FEIF6: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// DMEIF6 [18:18]
        /// Stream x direct mode error interrupt
        DMEIF6: u1 = 0,
        /// TEIF6 [19:19]
        /// Stream x transfer error interrupt flag
        TEIF6: u1 = 0,
        /// HTIF6 [20:20]
        /// Stream x half transfer interrupt flag
        HTIF6: u1 = 0,
        /// TCIF6 [21:21]
        /// Stream x transfer complete interrupt
        TCIF6: u1 = 0,
        /// FEIF7 [22:22]
        /// Stream x FIFO error interrupt flag
        FEIF7: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// DMEIF7 [24:24]
        /// Stream x direct mode error interrupt
        DMEIF7: u1 = 0,
        /// TEIF7 [25:25]
        /// Stream x transfer error interrupt flag
        TEIF7: u1 = 0,
        /// HTIF7 [26:26]
        /// Stream x half transfer interrupt flag
        HTIF7: u1 = 0,
        /// TCIF7 [27:27]
        /// Stream x transfer complete interrupt
        TCIF7: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// high interrupt status register
    pub const HISR = Register(HISR_val).init(base_address + 0x4);

    /// LIFCR
    const LIFCR_val = packed struct {
        /// CFEIF0 [0:0]
        /// Stream x clear FIFO error interrupt flag
        CFEIF0: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CDMEIF0 [2:2]
        /// Stream x clear direct mode error
        CDMEIF0: u1 = 0,
        /// CTEIF0 [3:3]
        /// Stream x clear transfer error interrupt
        CTEIF0: u1 = 0,
        /// CHTIF0 [4:4]
        /// Stream x clear half transfer interrupt
        CHTIF0: u1 = 0,
        /// CTCIF0 [5:5]
        /// Stream x clear transfer complete
        CTCIF0: u1 = 0,
        /// CFEIF1 [6:6]
        /// Stream x clear FIFO error interrupt flag
        CFEIF1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CDMEIF1 [8:8]
        /// Stream x clear direct mode error
        CDMEIF1: u1 = 0,
        /// CTEIF1 [9:9]
        /// Stream x clear transfer error interrupt
        CTEIF1: u1 = 0,
        /// CHTIF1 [10:10]
        /// Stream x clear half transfer interrupt
        CHTIF1: u1 = 0,
        /// CTCIF1 [11:11]
        /// Stream x clear transfer complete
        CTCIF1: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// CFEIF2 [16:16]
        /// Stream x clear FIFO error interrupt flag
        CFEIF2: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// CDMEIF2 [18:18]
        /// Stream x clear direct mode error
        CDMEIF2: u1 = 0,
        /// CTEIF2 [19:19]
        /// Stream x clear transfer error interrupt
        CTEIF2: u1 = 0,
        /// CHTIF2 [20:20]
        /// Stream x clear half transfer interrupt
        CHTIF2: u1 = 0,
        /// CTCIF2 [21:21]
        /// Stream x clear transfer complete
        CTCIF2: u1 = 0,
        /// CFEIF3 [22:22]
        /// Stream x clear FIFO error interrupt flag
        CFEIF3: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// CDMEIF3 [24:24]
        /// Stream x clear direct mode error
        CDMEIF3: u1 = 0,
        /// CTEIF3 [25:25]
        /// Stream x clear transfer error interrupt
        CTEIF3: u1 = 0,
        /// CHTIF3 [26:26]
        /// Stream x clear half transfer interrupt
        CHTIF3: u1 = 0,
        /// CTCIF3 [27:27]
        /// Stream x clear transfer complete
        CTCIF3: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// low interrupt flag clear
    pub const LIFCR = Register(LIFCR_val).init(base_address + 0x8);

    /// HIFCR
    const HIFCR_val = packed struct {
        /// CFEIF4 [0:0]
        /// Stream x clear FIFO error interrupt flag
        CFEIF4: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CDMEIF4 [2:2]
        /// Stream x clear direct mode error
        CDMEIF4: u1 = 0,
        /// CTEIF4 [3:3]
        /// Stream x clear transfer error interrupt
        CTEIF4: u1 = 0,
        /// CHTIF4 [4:4]
        /// Stream x clear half transfer interrupt
        CHTIF4: u1 = 0,
        /// CTCIF4 [5:5]
        /// Stream x clear transfer complete
        CTCIF4: u1 = 0,
        /// CFEIF5 [6:6]
        /// Stream x clear FIFO error interrupt flag
        CFEIF5: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CDMEIF5 [8:8]
        /// Stream x clear direct mode error
        CDMEIF5: u1 = 0,
        /// CTEIF5 [9:9]
        /// Stream x clear transfer error interrupt
        CTEIF5: u1 = 0,
        /// CHTIF5 [10:10]
        /// Stream x clear half transfer interrupt
        CHTIF5: u1 = 0,
        /// CTCIF5 [11:11]
        /// Stream x clear transfer complete
        CTCIF5: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// CFEIF6 [16:16]
        /// Stream x clear FIFO error interrupt flag
        CFEIF6: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// CDMEIF6 [18:18]
        /// Stream x clear direct mode error
        CDMEIF6: u1 = 0,
        /// CTEIF6 [19:19]
        /// Stream x clear transfer error interrupt
        CTEIF6: u1 = 0,
        /// CHTIF6 [20:20]
        /// Stream x clear half transfer interrupt
        CHTIF6: u1 = 0,
        /// CTCIF6 [21:21]
        /// Stream x clear transfer complete
        CTCIF6: u1 = 0,
        /// CFEIF7 [22:22]
        /// Stream x clear FIFO error interrupt flag
        CFEIF7: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// CDMEIF7 [24:24]
        /// Stream x clear direct mode error
        CDMEIF7: u1 = 0,
        /// CTEIF7 [25:25]
        /// Stream x clear transfer error interrupt
        CTEIF7: u1 = 0,
        /// CHTIF7 [26:26]
        /// Stream x clear half transfer interrupt
        CHTIF7: u1 = 0,
        /// CTCIF7 [27:27]
        /// Stream x clear transfer complete
        CTCIF7: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// high interrupt flag clear
    pub const HIFCR = Register(HIFCR_val).init(base_address + 0xc);

    /// S0CR
    const S0CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S0CR = Register(S0CR_val).init(base_address + 0x10);

    /// S0NDTR
    const S0NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S0NDTR = Register(S0NDTR_val).init(base_address + 0x14);

    /// S0PAR
    const S0PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S0PAR = Register(S0PAR_val).init(base_address + 0x18);

    /// S0M0AR
    const S0M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S0M0AR = Register(S0M0AR_val).init(base_address + 0x1c);

    /// S0M1AR
    const S0M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S0M1AR = Register(S0M1AR_val).init(base_address + 0x20);

    /// S0FCR
    const S0FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S0FCR = Register(S0FCR_val).init(base_address + 0x24);

    /// S1CR
    const S1CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S1CR = Register(S1CR_val).init(base_address + 0x28);

    /// S1NDTR
    const S1NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S1NDTR = Register(S1NDTR_val).init(base_address + 0x2c);

    /// S1PAR
    const S1PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S1PAR = Register(S1PAR_val).init(base_address + 0x30);

    /// S1M0AR
    const S1M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S1M0AR = Register(S1M0AR_val).init(base_address + 0x34);

    /// S1M1AR
    const S1M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S1M1AR = Register(S1M1AR_val).init(base_address + 0x38);

    /// S1FCR
    const S1FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S1FCR = Register(S1FCR_val).init(base_address + 0x3c);

    /// S2CR
    const S2CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S2CR = Register(S2CR_val).init(base_address + 0x40);

    /// S2NDTR
    const S2NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S2NDTR = Register(S2NDTR_val).init(base_address + 0x44);

    /// S2PAR
    const S2PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S2PAR = Register(S2PAR_val).init(base_address + 0x48);

    /// S2M0AR
    const S2M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S2M0AR = Register(S2M0AR_val).init(base_address + 0x4c);

    /// S2M1AR
    const S2M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S2M1AR = Register(S2M1AR_val).init(base_address + 0x50);

    /// S2FCR
    const S2FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S2FCR = Register(S2FCR_val).init(base_address + 0x54);

    /// S3CR
    const S3CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S3CR = Register(S3CR_val).init(base_address + 0x58);

    /// S3NDTR
    const S3NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S3NDTR = Register(S3NDTR_val).init(base_address + 0x5c);

    /// S3PAR
    const S3PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S3PAR = Register(S3PAR_val).init(base_address + 0x60);

    /// S3M0AR
    const S3M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S3M0AR = Register(S3M0AR_val).init(base_address + 0x64);

    /// S3M1AR
    const S3M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S3M1AR = Register(S3M1AR_val).init(base_address + 0x68);

    /// S3FCR
    const S3FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S3FCR = Register(S3FCR_val).init(base_address + 0x6c);

    /// S4CR
    const S4CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:27]
        /// Channel selection
        CHSEL: u3 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// stream x configuration
    pub const S4CR = Register(S4CR_val).init(base_address + 0x70);

    /// S4NDTR
    const S4NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S4NDTR = Register(S4NDTR_val).init(base_address + 0x74);

    /// S4PAR
    const S4PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S4PAR = Register(S4PAR_val).init(base_address + 0x78);

    /// S4M0AR
    const S4M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S4M0AR = Register(S4M0AR_val).init(base_address + 0x7c);

    /// S4M1AR
    const S4M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S4M1AR = Register(S4M1AR_val).init(base_address + 0x80);

    /// S4FCR
    const S4FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S4FCR = Register(S4FCR_val).init(base_address + 0x84);

    /// S5CR
    const S5CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S5CR = Register(S5CR_val).init(base_address + 0x88);

    /// S5NDTR
    const S5NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S5NDTR = Register(S5NDTR_val).init(base_address + 0x8c);

    /// S5PAR
    const S5PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S5PAR = Register(S5PAR_val).init(base_address + 0x90);

    /// S5M0AR
    const S5M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S5M0AR = Register(S5M0AR_val).init(base_address + 0x94);

    /// S5M1AR
    const S5M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S5M1AR = Register(S5M1AR_val).init(base_address + 0x98);

    /// S5FCR
    const S5FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S5FCR = Register(S5FCR_val).init(base_address + 0x9c);

    /// S6CR
    const S6CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S6CR = Register(S6CR_val).init(base_address + 0xa0);

    /// S6NDTR
    const S6NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S6NDTR = Register(S6NDTR_val).init(base_address + 0xa4);

    /// S6PAR
    const S6PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S6PAR = Register(S6PAR_val).init(base_address + 0xa8);

    /// S6M0AR
    const S6M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S6M0AR = Register(S6M0AR_val).init(base_address + 0xac);

    /// S6M1AR
    const S6M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S6M1AR = Register(S6M1AR_val).init(base_address + 0xb0);

    /// S6FCR
    const S6FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S6FCR = Register(S6FCR_val).init(base_address + 0xb4);

    /// S7CR
    const S7CR_val = packed struct {
        /// EN [0:0]
        /// Stream enable / flag stream ready when
        EN: u1 = 0,
        /// DMEIE [1:1]
        /// Direct mode error interrupt
        DMEIE: u1 = 0,
        /// TEIE [2:2]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// HTIE [3:3]
        /// Half transfer interrupt
        HTIE: u1 = 0,
        /// TCIE [4:4]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// PFCTRL [5:5]
        /// Peripheral flow controller
        PFCTRL: u1 = 0,
        /// DIR [6:7]
        /// Data transfer direction
        DIR: u2 = 0,
        /// CIRC [8:8]
        /// Circular mode
        CIRC: u1 = 0,
        /// PINC [9:9]
        /// Peripheral increment mode
        PINC: u1 = 0,
        /// MINC [10:10]
        /// Memory increment mode
        MINC: u1 = 0,
        /// PSIZE [11:12]
        /// Peripheral data size
        PSIZE: u2 = 0,
        /// MSIZE [13:14]
        /// Memory data size
        MSIZE: u2 = 0,
        /// PINCOS [15:15]
        /// Peripheral increment offset
        PINCOS: u1 = 0,
        /// PL [16:17]
        /// Priority level
        PL: u2 = 0,
        /// DBM [18:18]
        /// Double buffer mode
        DBM: u1 = 0,
        /// CT [19:19]
        /// Current target (only in double buffer
        CT: u1 = 0,
        /// ACK [20:20]
        /// ACK
        ACK: u1 = 0,
        /// PBURST [21:22]
        /// Peripheral burst transfer
        PBURST: u2 = 0,
        /// MBURST [23:24]
        /// Memory burst transfer
        MBURST: u2 = 0,
        /// CHSEL [25:28]
        /// Channel selection
        CHSEL: u4 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// stream x configuration
    pub const S7CR = Register(S7CR_val).init(base_address + 0xb8);

    /// S7NDTR
    const S7NDTR_val = packed struct {
        /// NDT [0:15]
        /// Number of data items to
        NDT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x number of data
    pub const S7NDTR = Register(S7NDTR_val).init(base_address + 0xbc);

    /// S7PAR
    const S7PAR_val = packed struct {
        /// PA [0:31]
        /// Peripheral address
        PA: u32 = 0,
    };
    /// stream x peripheral address
    pub const S7PAR = Register(S7PAR_val).init(base_address + 0xc0);

    /// S7M0AR
    const S7M0AR_val = packed struct {
        /// M0A [0:31]
        /// Memory 0 address
        M0A: u32 = 0,
    };
    /// stream x memory 0 address
    pub const S7M0AR = Register(S7M0AR_val).init(base_address + 0xc4);

    /// S7M1AR
    const S7M1AR_val = packed struct {
        /// M1A [0:31]
        /// Memory 1 address (used in case of Double
        M1A: u32 = 0,
    };
    /// stream x memory 1 address
    pub const S7M1AR = Register(S7M1AR_val).init(base_address + 0xc8);

    /// S7FCR
    const S7FCR_val = packed struct {
        /// FTH [0:1]
        /// FIFO threshold selection
        FTH: u2 = 1,
        /// DMDIS [2:2]
        /// Direct mode disable
        DMDIS: u1 = 0,
        /// FS [3:5]
        /// FIFO status
        FS: u3 = 4,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// FEIE [7:7]
        /// FIFO error interrupt
        FEIE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// stream x FIFO control register
    pub const S7FCR = Register(S7FCR_val).init(base_address + 0xcc);
};

/// Reset and clock control
pub const RCC = struct {
    const base_address = 0x40023800;
    /// CR
    const CR_val = packed struct {
        /// HSION [0:0]
        /// Internal high-speed clock
        HSION: u1 = 1,
        /// HSIRDY [1:1]
        /// Internal high-speed clock ready
        HSIRDY: u1 = 1,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// HSITRIM [3:7]
        /// Internal high-speed clock
        HSITRIM: u5 = 16,
        /// HSICAL [8:15]
        /// Internal high-speed clock
        HSICAL: u8 = 0,
        /// HSEON [16:16]
        /// HSE clock enable
        HSEON: u1 = 0,
        /// HSERDY [17:17]
        /// HSE clock ready flag
        HSERDY: u1 = 0,
        /// HSEBYP [18:18]
        /// HSE clock bypass
        HSEBYP: u1 = 0,
        /// CSSON [19:19]
        /// Clock security system
        CSSON: u1 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// PLLON [24:24]
        /// Main PLL (PLL) enable
        PLLON: u1 = 0,
        /// PLLRDY [25:25]
        /// Main PLL (PLL) clock ready
        PLLRDY: u1 = 0,
        /// PLLI2SON [26:26]
        /// PLLI2S enable
        PLLI2SON: u1 = 0,
        /// PLLI2SRDY [27:27]
        /// PLLI2S clock ready flag
        PLLI2SRDY: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// clock control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// PLLCFGR
    const PLLCFGR_val = packed struct {
        /// PLLM0 [0:0]
        /// Division factor for the main PLL (PLL)
        PLLM0: u1 = 0,
        /// PLLM1 [1:1]
        /// Division factor for the main PLL (PLL)
        PLLM1: u1 = 0,
        /// PLLM2 [2:2]
        /// Division factor for the main PLL (PLL)
        PLLM2: u1 = 0,
        /// PLLM3 [3:3]
        /// Division factor for the main PLL (PLL)
        PLLM3: u1 = 0,
        /// PLLM4 [4:4]
        /// Division factor for the main PLL (PLL)
        PLLM4: u1 = 1,
        /// PLLM5 [5:5]
        /// Division factor for the main PLL (PLL)
        PLLM5: u1 = 0,
        /// PLLN0 [6:6]
        /// Main PLL (PLL) multiplication factor for
        PLLN0: u1 = 0,
        /// PLLN1 [7:7]
        /// Main PLL (PLL) multiplication factor for
        PLLN1: u1 = 0,
        /// PLLN2 [8:8]
        /// Main PLL (PLL) multiplication factor for
        PLLN2: u1 = 0,
        /// PLLN3 [9:9]
        /// Main PLL (PLL) multiplication factor for
        PLLN3: u1 = 0,
        /// PLLN4 [10:10]
        /// Main PLL (PLL) multiplication factor for
        PLLN4: u1 = 0,
        /// PLLN5 [11:11]
        /// Main PLL (PLL) multiplication factor for
        PLLN5: u1 = 0,
        /// PLLN6 [12:12]
        /// Main PLL (PLL) multiplication factor for
        PLLN6: u1 = 1,
        /// PLLN7 [13:13]
        /// Main PLL (PLL) multiplication factor for
        PLLN7: u1 = 1,
        /// PLLN8 [14:14]
        /// Main PLL (PLL) multiplication factor for
        PLLN8: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// PLLP0 [16:16]
        /// Main PLL (PLL) division factor for main
        PLLP0: u1 = 0,
        /// PLLP1 [17:17]
        /// Main PLL (PLL) division factor for main
        PLLP1: u1 = 0,
        /// unused [18:21]
        _unused18: u4 = 0,
        /// PLLSRC [22:22]
        /// Main PLL(PLL) and audio PLL (PLLI2S)
        PLLSRC: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// PLLQ0 [24:24]
        /// Main PLL (PLL) division factor for USB
        PLLQ0: u1 = 0,
        /// PLLQ1 [25:25]
        /// Main PLL (PLL) division factor for USB
        PLLQ1: u1 = 0,
        /// PLLQ2 [26:26]
        /// Main PLL (PLL) division factor for USB
        PLLQ2: u1 = 1,
        /// PLLQ3 [27:27]
        /// Main PLL (PLL) division factor for USB
        PLLQ3: u1 = 0,
        /// PPLR0 [28:28]
        PPLR0: u1 = 0,
        /// PPLR1 [29:29]
        PPLR1: u1 = 0,
        /// PPLR1 [30:30]
        PPLR2: u1 = 0,
        /// PPLR1 [31:31]
        _unused31: u1 = 0,
    };
    /// PLL configuration register
    pub const PLLCFGR = Register(PLLCFGR_val).init(base_address + 0x4);

    /// CFGR
    const CFGR_val = packed struct {
        /// SW0 [0:0]
        /// System clock switch
        SW0: u1 = 0,
        /// SW1 [1:1]
        /// System clock switch
        SW1: u1 = 0,
        /// SWS0 [2:2]
        /// System clock switch status
        SWS0: u1 = 0,
        /// SWS1 [3:3]
        /// System clock switch status
        SWS1: u1 = 0,
        /// HPRE [4:7]
        /// AHB prescaler
        HPRE: u4 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// PPRE1 [10:12]
        /// APB Low speed prescaler
        PPRE1: u3 = 0,
        /// PPRE2 [13:15]
        /// APB high-speed prescaler
        PPRE2: u3 = 0,
        /// RTCPRE [16:20]
        /// HSE division factor for RTC
        RTCPRE: u5 = 0,
        /// MCO1 [21:22]
        /// Microcontroller clock output
        MCO1: u2 = 0,
        /// I2SSRC [23:23]
        /// I2S clock selection
        I2SSRC: u1 = 0,
        /// MCO1PRE [24:26]
        /// MCO1 prescaler
        MCO1PRE: u3 = 0,
        /// MCO2PRE [27:29]
        /// MCO2 prescaler
        MCO2PRE: u3 = 0,
        /// MCO2 [30:31]
        /// Microcontroller clock output
        MCO2: u2 = 0,
    };
    /// clock configuration register
    pub const CFGR = Register(CFGR_val).init(base_address + 0x8);

    /// CIR
    const CIR_val = packed struct {
        /// LSIRDYF [0:0]
        /// LSI ready interrupt flag
        LSIRDYF: u1 = 0,
        /// LSERDYF [1:1]
        /// LSE ready interrupt flag
        LSERDYF: u1 = 0,
        /// HSIRDYF [2:2]
        /// HSI ready interrupt flag
        HSIRDYF: u1 = 0,
        /// HSERDYF [3:3]
        /// HSE ready interrupt flag
        HSERDYF: u1 = 0,
        /// PLLRDYF [4:4]
        /// Main PLL (PLL) ready interrupt
        PLLRDYF: u1 = 0,
        /// PLLI2SRDYF [5:5]
        /// PLLI2S ready interrupt
        PLLI2SRDYF: u1 = 0,
        /// PLLSAIRDYF [6:6]
        /// PLLSAI ready interrupt
        PLLSAIRDYF: u1 = 0,
        /// CSSF [7:7]
        /// Clock security system interrupt
        CSSF: u1 = 0,
        /// LSIRDYIE [8:8]
        /// LSI ready interrupt enable
        LSIRDYIE: u1 = 0,
        /// LSERDYIE [9:9]
        /// LSE ready interrupt enable
        LSERDYIE: u1 = 0,
        /// HSIRDYIE [10:10]
        /// HSI ready interrupt enable
        HSIRDYIE: u1 = 0,
        /// HSERDYIE [11:11]
        /// HSE ready interrupt enable
        HSERDYIE: u1 = 0,
        /// PLLRDYIE [12:12]
        /// Main PLL (PLL) ready interrupt
        PLLRDYIE: u1 = 0,
        /// PLLI2SRDYIE [13:13]
        /// PLLI2S ready interrupt
        PLLI2SRDYIE: u1 = 0,
        /// PLLSAIRDYIE [14:14]
        /// PLLSAI Ready Interrupt
        PLLSAIRDYIE: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// LSIRDYC [16:16]
        /// LSI ready interrupt clear
        LSIRDYC: u1 = 0,
        /// LSERDYC [17:17]
        /// LSE ready interrupt clear
        LSERDYC: u1 = 0,
        /// HSIRDYC [18:18]
        /// HSI ready interrupt clear
        HSIRDYC: u1 = 0,
        /// HSERDYC [19:19]
        /// HSE ready interrupt clear
        HSERDYC: u1 = 0,
        /// PLLRDYC [20:20]
        /// Main PLL(PLL) ready interrupt
        PLLRDYC: u1 = 0,
        /// PLLI2SRDYC [21:21]
        /// PLLI2S ready interrupt
        PLLI2SRDYC: u1 = 0,
        /// PLLSAIRDYC [22:22]
        /// PLLSAI Ready Interrupt
        PLLSAIRDYC: u1 = 0,
        /// CSSC [23:23]
        /// Clock security system interrupt
        CSSC: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// clock interrupt register
    pub const CIR = Register(CIR_val).init(base_address + 0xc);

    /// AHB1RSTR
    const AHB1RSTR_val = packed struct {
        /// GPIOARST [0:0]
        /// IO port A reset
        GPIOARST: u1 = 0,
        /// GPIOBRST [1:1]
        /// IO port B reset
        GPIOBRST: u1 = 0,
        /// GPIOCRST [2:2]
        /// IO port C reset
        GPIOCRST: u1 = 0,
        /// GPIODRST [3:3]
        /// IO port D reset
        GPIODRST: u1 = 0,
        /// GPIOERST [4:4]
        /// IO port E reset
        GPIOERST: u1 = 0,
        /// GPIOFRST [5:5]
        /// IO port F reset
        GPIOFRST: u1 = 0,
        /// GPIOGRST [6:6]
        /// IO port G reset
        GPIOGRST: u1 = 0,
        /// GPIOHRST [7:7]
        /// IO port H reset
        GPIOHRST: u1 = 0,
        /// GPIOIRST [8:8]
        /// IO port I reset
        GPIOIRST: u1 = 0,
        /// GPIOJRST [9:9]
        /// IO port J reset
        GPIOJRST: u1 = 0,
        /// GPIOKRST [10:10]
        /// IO port K reset
        GPIOKRST: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// CRCRST [12:12]
        /// CRC reset
        CRCRST: u1 = 0,
        /// unused [13:20]
        _unused13: u3 = 0,
        _unused16: u5 = 0,
        /// DMA1RST [21:21]
        /// DMA2 reset
        DMA1RST: u1 = 0,
        /// DMA2RST [22:22]
        /// DMA2 reset
        DMA2RST: u1 = 0,
        /// DMA2DRST [23:23]
        /// DMA2D reset
        DMA2DRST: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// ETHMACRST [25:25]
        /// Ethernet MAC reset
        ETHMACRST: u1 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// OTGHSRST [29:29]
        /// USB OTG HS module reset
        OTGHSRST: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// AHB1 peripheral reset register
    pub const AHB1RSTR = Register(AHB1RSTR_val).init(base_address + 0x10);

    /// AHB2RSTR
    const AHB2RSTR_val = packed struct {
        /// DCMIRST [0:0]
        /// Camera interface reset
        DCMIRST: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// CRYPRST [4:4]
        /// Cryptographic module reset
        CRYPRST: u1 = 0,
        /// HSAHRST [5:5]
        /// Hash module reset
        HSAHRST: u1 = 0,
        /// RNGRST [6:6]
        /// Random number generator module
        RNGRST: u1 = 0,
        /// OTGFSRST [7:7]
        /// USB OTG FS module reset
        OTGFSRST: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB2 peripheral reset register
    pub const AHB2RSTR = Register(AHB2RSTR_val).init(base_address + 0x14);

    /// AHB3RSTR
    const AHB3RSTR_val = packed struct {
        /// FMCRST [0:0]
        /// Flexible memory controller module
        FMCRST: u1 = 0,
        /// QSPIRST [1:1]
        /// Quad SPI memory controller
        QSPIRST: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB3 peripheral reset register
    pub const AHB3RSTR = Register(AHB3RSTR_val).init(base_address + 0x18);

    /// APB1RSTR
    const APB1RSTR_val = packed struct {
        /// TIM2RST [0:0]
        /// TIM2 reset
        TIM2RST: u1 = 0,
        /// TIM3RST [1:1]
        /// TIM3 reset
        TIM3RST: u1 = 0,
        /// TIM4RST [2:2]
        /// TIM4 reset
        TIM4RST: u1 = 0,
        /// TIM5RST [3:3]
        /// TIM5 reset
        TIM5RST: u1 = 0,
        /// TIM6RST [4:4]
        /// TIM6 reset
        TIM6RST: u1 = 0,
        /// TIM7RST [5:5]
        /// TIM7 reset
        TIM7RST: u1 = 0,
        /// TIM12RST [6:6]
        /// TIM12 reset
        TIM12RST: u1 = 0,
        /// TIM13RST [7:7]
        /// TIM13 reset
        TIM13RST: u1 = 0,
        /// TIM14RST [8:8]
        /// TIM14 reset
        TIM14RST: u1 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// WWDGRST [11:11]
        /// Window watchdog reset
        WWDGRST: u1 = 0,
        /// unused [12:13]
        _unused12: u2 = 0,
        /// SPI2RST [14:14]
        /// SPI 2 reset
        SPI2RST: u1 = 0,
        /// SPI3RST [15:15]
        /// SPI 3 reset
        SPI3RST: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// UART2RST [17:17]
        /// USART 2 reset
        UART2RST: u1 = 0,
        /// UART3RST [18:18]
        /// USART 3 reset
        UART3RST: u1 = 0,
        /// UART4RST [19:19]
        /// USART 4 reset
        UART4RST: u1 = 0,
        /// UART5RST [20:20]
        /// USART 5 reset
        UART5RST: u1 = 0,
        /// I2C1RST [21:21]
        /// I2C 1 reset
        I2C1RST: u1 = 0,
        /// I2C2RST [22:22]
        /// I2C 2 reset
        I2C2RST: u1 = 0,
        /// I2C3RST [23:23]
        /// I2C3 reset
        I2C3RST: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// CAN1RST [25:25]
        /// CAN1 reset
        CAN1RST: u1 = 0,
        /// CAN2RST [26:26]
        /// CAN2 reset
        CAN2RST: u1 = 0,
        /// unused [27:27]
        _unused27: u1 = 0,
        /// PWRRST [28:28]
        /// Power interface reset
        PWRRST: u1 = 0,
        /// DACRST [29:29]
        /// DAC reset
        DACRST: u1 = 0,
        /// UART7RST [30:30]
        /// UART7 reset
        UART7RST: u1 = 0,
        /// UART8RST [31:31]
        /// UART8 reset
        UART8RST: u1 = 0,
    };
    /// APB1 peripheral reset register
    pub const APB1RSTR = Register(APB1RSTR_val).init(base_address + 0x20);

    /// APB2RSTR
    const APB2RSTR_val = packed struct {
        /// TIM1RST [0:0]
        /// TIM1 reset
        TIM1RST: u1 = 0,
        /// TIM8RST [1:1]
        /// TIM8 reset
        TIM8RST: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// USART1RST [4:4]
        /// USART1 reset
        USART1RST: u1 = 0,
        /// USART6RST [5:5]
        /// USART6 reset
        USART6RST: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// ADCRST [8:8]
        /// ADC interface reset (common to all
        ADCRST: u1 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// SDMMC1RST [11:11]
        /// SDMMC1 reset
        SDMMC1RST: u1 = 0,
        /// SPI1RST [12:12]
        /// SPI 1 reset
        SPI1RST: u1 = 0,
        /// SPI4RST [13:13]
        /// SPI4 reset
        SPI4RST: u1 = 0,
        /// SYSCFGRST [14:14]
        /// System configuration controller
        SYSCFGRST: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// TIM9RST [16:16]
        /// TIM9 reset
        TIM9RST: u1 = 0,
        /// TIM10RST [17:17]
        /// TIM10 reset
        TIM10RST: u1 = 0,
        /// TIM11RST [18:18]
        /// TIM11 reset
        TIM11RST: u1 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// SPI5RST [20:20]
        /// SPI5 reset
        SPI5RST: u1 = 0,
        /// SPI6RST [21:21]
        /// SPI6 reset
        SPI6RST: u1 = 0,
        /// SAI1RST [22:22]
        /// SAI1 reset
        SAI1RST: u1 = 0,
        /// SAI2RST [23:23]
        /// SAI2 reset
        SAI2RST: u1 = 0,
        /// unused [24:25]
        _unused24: u2 = 0,
        /// LTDCRST [26:26]
        /// LTDC reset
        LTDCRST: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// APB2 peripheral reset register
    pub const APB2RSTR = Register(APB2RSTR_val).init(base_address + 0x24);

    /// AHB1ENR
    const AHB1ENR_val = packed struct {
        /// GPIOAEN [0:0]
        /// IO port A clock enable
        GPIOAEN: u1 = 0,
        /// GPIOBEN [1:1]
        /// IO port B clock enable
        GPIOBEN: u1 = 0,
        /// GPIOCEN [2:2]
        /// IO port C clock enable
        GPIOCEN: u1 = 0,
        /// GPIODEN [3:3]
        /// IO port D clock enable
        GPIODEN: u1 = 0,
        /// GPIOEEN [4:4]
        /// IO port E clock enable
        GPIOEEN: u1 = 0,
        /// GPIOFEN [5:5]
        /// IO port F clock enable
        GPIOFEN: u1 = 0,
        /// GPIOGEN [6:6]
        /// IO port G clock enable
        GPIOGEN: u1 = 0,
        /// GPIOHEN [7:7]
        /// IO port H clock enable
        GPIOHEN: u1 = 0,
        /// GPIOIEN [8:8]
        /// IO port I clock enable
        GPIOIEN: u1 = 0,
        /// GPIOJEN [9:9]
        /// IO port J clock enable
        GPIOJEN: u1 = 0,
        /// GPIOKEN [10:10]
        /// IO port K clock enable
        GPIOKEN: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// CRCEN [12:12]
        /// CRC clock enable
        CRCEN: u1 = 0,
        /// unused [13:17]
        _unused13: u3 = 0,
        _unused16: u2 = 0,
        /// BKPSRAMEN [18:18]
        /// Backup SRAM interface clock
        BKPSRAMEN: u1 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// CCMDATARAMEN [20:20]
        /// CCM data RAM clock enable
        CCMDATARAMEN: u1 = 1,
        /// DMA1EN [21:21]
        /// DMA1 clock enable
        DMA1EN: u1 = 0,
        /// DMA2EN [22:22]
        /// DMA2 clock enable
        DMA2EN: u1 = 0,
        /// DMA2DEN [23:23]
        /// DMA2D clock enable
        DMA2DEN: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// ETHMACEN [25:25]
        /// Ethernet MAC clock enable
        ETHMACEN: u1 = 0,
        /// ETHMACTXEN [26:26]
        /// Ethernet Transmission clock
        ETHMACTXEN: u1 = 0,
        /// ETHMACRXEN [27:27]
        /// Ethernet Reception clock
        ETHMACRXEN: u1 = 0,
        /// ETHMACPTPEN [28:28]
        /// Ethernet PTP clock enable
        ETHMACPTPEN: u1 = 0,
        /// OTGHSEN [29:29]
        /// USB OTG HS clock enable
        OTGHSEN: u1 = 0,
        /// OTGHSULPIEN [30:30]
        /// USB OTG HSULPI clock
        OTGHSULPIEN: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// AHB1 peripheral clock register
    pub const AHB1ENR = Register(AHB1ENR_val).init(base_address + 0x30);

    /// AHB2ENR
    const AHB2ENR_val = packed struct {
        /// DCMIEN [0:0]
        /// Camera interface enable
        DCMIEN: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// CRYPEN [4:4]
        /// Cryptographic modules clock
        CRYPEN: u1 = 0,
        /// HASHEN [5:5]
        /// Hash modules clock enable
        HASHEN: u1 = 0,
        /// RNGEN [6:6]
        /// Random number generator clock
        RNGEN: u1 = 0,
        /// OTGFSEN [7:7]
        /// USB OTG FS clock enable
        OTGFSEN: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB2 peripheral clock enable
    pub const AHB2ENR = Register(AHB2ENR_val).init(base_address + 0x34);

    /// AHB3ENR
    const AHB3ENR_val = packed struct {
        /// FMCEN [0:0]
        /// Flexible memory controller module clock
        FMCEN: u1 = 0,
        /// QSPIEN [1:1]
        /// Quad SPI memory controller clock
        QSPIEN: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB3 peripheral clock enable
    pub const AHB3ENR = Register(AHB3ENR_val).init(base_address + 0x38);

    /// APB1ENR
    const APB1ENR_val = packed struct {
        /// TIM2EN [0:0]
        /// TIM2 clock enable
        TIM2EN: u1 = 0,
        /// TIM3EN [1:1]
        /// TIM3 clock enable
        TIM3EN: u1 = 0,
        /// TIM4EN [2:2]
        /// TIM4 clock enable
        TIM4EN: u1 = 0,
        /// TIM5EN [3:3]
        /// TIM5 clock enable
        TIM5EN: u1 = 0,
        /// TIM6EN [4:4]
        /// TIM6 clock enable
        TIM6EN: u1 = 0,
        /// TIM7EN [5:5]
        /// TIM7 clock enable
        TIM7EN: u1 = 0,
        /// TIM12EN [6:6]
        /// TIM12 clock enable
        TIM12EN: u1 = 0,
        /// TIM13EN [7:7]
        /// TIM13 clock enable
        TIM13EN: u1 = 0,
        /// TIM14EN [8:8]
        /// TIM14 clock enable
        TIM14EN: u1 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// WWDGEN [11:11]
        /// Window watchdog clock
        WWDGEN: u1 = 0,
        /// unused [12:13]
        _unused12: u2 = 0,
        /// SPI2EN [14:14]
        /// SPI2 clock enable
        SPI2EN: u1 = 0,
        /// SPI3EN [15:15]
        /// SPI3 clock enable
        SPI3EN: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// USART2EN [17:17]
        /// USART 2 clock enable
        USART2EN: u1 = 0,
        /// USART3EN [18:18]
        /// USART3 clock enable
        USART3EN: u1 = 0,
        /// UART4EN [19:19]
        /// UART4 clock enable
        UART4EN: u1 = 0,
        /// UART5EN [20:20]
        /// UART5 clock enable
        UART5EN: u1 = 0,
        /// I2C1EN [21:21]
        /// I2C1 clock enable
        I2C1EN: u1 = 0,
        /// I2C2EN [22:22]
        /// I2C2 clock enable
        I2C2EN: u1 = 0,
        /// I2C3EN [23:23]
        /// I2C3 clock enable
        I2C3EN: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// CAN1EN [25:25]
        /// CAN 1 clock enable
        CAN1EN: u1 = 0,
        /// CAN2EN [26:26]
        /// CAN 2 clock enable
        CAN2EN: u1 = 0,
        /// unused [27:27]
        _unused27: u1 = 0,
        /// PWREN [28:28]
        /// Power interface clock
        PWREN: u1 = 0,
        /// DACEN [29:29]
        /// DAC interface clock enable
        DACEN: u1 = 0,
        /// UART7ENR [30:30]
        /// UART7 clock enable
        UART7ENR: u1 = 0,
        /// UART8ENR [31:31]
        /// UART8 clock enable
        UART8ENR: u1 = 0,
    };
    /// APB1 peripheral clock enable
    pub const APB1ENR = Register(APB1ENR_val).init(base_address + 0x40);

    /// APB2ENR
    const APB2ENR_val = packed struct {
        /// TIM1EN [0:0]
        /// TIM1 clock enable
        TIM1EN: u1 = 0,
        /// TIM8EN [1:1]
        /// TIM8 clock enable
        TIM8EN: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// USART1EN [4:4]
        /// USART1 clock enable
        USART1EN: u1 = 0,
        /// USART6EN [5:5]
        /// USART6 clock enable
        USART6EN: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// ADC1EN [8:8]
        /// ADC1 clock enable
        ADC1EN: u1 = 0,
        /// ADC2EN [9:9]
        /// ADC2 clock enable
        ADC2EN: u1 = 0,
        /// ADC3EN [10:10]
        /// ADC3 clock enable
        ADC3EN: u1 = 0,
        /// SDMMC1EN [11:11]
        /// SDMMC1 clock enable
        SDMMC1EN: u1 = 0,
        /// SPI1EN [12:12]
        /// SPI1 clock enable
        SPI1EN: u1 = 0,
        /// SPI4ENR [13:13]
        /// SPI4 clock enable
        SPI4ENR: u1 = 0,
        /// SYSCFGEN [14:14]
        /// System configuration controller clock
        SYSCFGEN: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// TIM9EN [16:16]
        /// TIM9 clock enable
        TIM9EN: u1 = 0,
        /// TIM10EN [17:17]
        /// TIM10 clock enable
        TIM10EN: u1 = 0,
        /// TIM11EN [18:18]
        /// TIM11 clock enable
        TIM11EN: u1 = 0,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// SPI5ENR [20:20]
        /// SPI5 clock enable
        SPI5ENR: u1 = 0,
        /// SPI6ENR [21:21]
        /// SPI6 clock enable
        SPI6ENR: u1 = 0,
        /// SAI1EN [22:22]
        /// SAI1 clock enable
        SAI1EN: u1 = 0,
        /// SAI2EN [23:23]
        /// SAI2 clock enable
        SAI2EN: u1 = 0,
        /// unused [24:25]
        _unused24: u2 = 0,
        /// LTDCEN [26:26]
        /// LTDC clock enable
        LTDCEN: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// APB2 peripheral clock enable
    pub const APB2ENR = Register(APB2ENR_val).init(base_address + 0x44);

    /// AHB1LPENR
    const AHB1LPENR_val = packed struct {
        /// GPIOALPEN [0:0]
        /// IO port A clock enable during sleep
        GPIOALPEN: u1 = 1,
        /// GPIOBLPEN [1:1]
        /// IO port B clock enable during Sleep
        GPIOBLPEN: u1 = 1,
        /// GPIOCLPEN [2:2]
        /// IO port C clock enable during Sleep
        GPIOCLPEN: u1 = 1,
        /// GPIODLPEN [3:3]
        /// IO port D clock enable during Sleep
        GPIODLPEN: u1 = 1,
        /// GPIOELPEN [4:4]
        /// IO port E clock enable during Sleep
        GPIOELPEN: u1 = 1,
        /// GPIOFLPEN [5:5]
        /// IO port F clock enable during Sleep
        GPIOFLPEN: u1 = 1,
        /// GPIOGLPEN [6:6]
        /// IO port G clock enable during Sleep
        GPIOGLPEN: u1 = 1,
        /// GPIOHLPEN [7:7]
        /// IO port H clock enable during Sleep
        GPIOHLPEN: u1 = 1,
        /// GPIOILPEN [8:8]
        /// IO port I clock enable during Sleep
        GPIOILPEN: u1 = 1,
        /// GPIOJLPEN [9:9]
        /// IO port J clock enable during Sleep
        GPIOJLPEN: u1 = 0,
        /// GPIOKLPEN [10:10]
        /// IO port K clock enable during Sleep
        GPIOKLPEN: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// CRCLPEN [12:12]
        /// CRC clock enable during Sleep
        CRCLPEN: u1 = 1,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// FLITFLPEN [15:15]
        /// Flash interface clock enable during
        FLITFLPEN: u1 = 1,
        /// SRAM1LPEN [16:16]
        /// SRAM 1interface clock enable during
        SRAM1LPEN: u1 = 1,
        /// SRAM2LPEN [17:17]
        /// SRAM 2 interface clock enable during
        SRAM2LPEN: u1 = 1,
        /// BKPSRAMLPEN [18:18]
        /// Backup SRAM interface clock enable
        BKPSRAMLPEN: u1 = 1,
        /// SRAM3LPEN [19:19]
        /// SRAM 3 interface clock enable during
        SRAM3LPEN: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// DMA1LPEN [21:21]
        /// DMA1 clock enable during Sleep
        DMA1LPEN: u1 = 1,
        /// DMA2LPEN [22:22]
        /// DMA2 clock enable during Sleep
        DMA2LPEN: u1 = 1,
        /// DMA2DLPEN [23:23]
        /// DMA2D clock enable during Sleep
        DMA2DLPEN: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// ETHMACLPEN [25:25]
        /// Ethernet MAC clock enable during Sleep
        ETHMACLPEN: u1 = 1,
        /// ETHMACTXLPEN [26:26]
        /// Ethernet transmission clock enable
        ETHMACTXLPEN: u1 = 1,
        /// ETHMACRXLPEN [27:27]
        /// Ethernet reception clock enable during
        ETHMACRXLPEN: u1 = 1,
        /// ETHMACPTPLPEN [28:28]
        /// Ethernet PTP clock enable during Sleep
        ETHMACPTPLPEN: u1 = 1,
        /// OTGHSLPEN [29:29]
        /// USB OTG HS clock enable during Sleep
        OTGHSLPEN: u1 = 1,
        /// OTGHSULPILPEN [30:30]
        /// USB OTG HS ULPI clock enable during
        OTGHSULPILPEN: u1 = 1,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// AHB1 peripheral clock enable in low power
    pub const AHB1LPENR = Register(AHB1LPENR_val).init(base_address + 0x50);

    /// AHB2LPENR
    const AHB2LPENR_val = packed struct {
        /// DCMILPEN [0:0]
        /// Camera interface enable during Sleep
        DCMILPEN: u1 = 1,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// CRYPLPEN [4:4]
        /// Cryptography modules clock enable during
        CRYPLPEN: u1 = 1,
        /// HASHLPEN [5:5]
        /// Hash modules clock enable during Sleep
        HASHLPEN: u1 = 1,
        /// RNGLPEN [6:6]
        /// Random number generator clock enable
        RNGLPEN: u1 = 1,
        /// OTGFSLPEN [7:7]
        /// USB OTG FS clock enable during Sleep
        OTGFSLPEN: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB2 peripheral clock enable in low power
    pub const AHB2LPENR = Register(AHB2LPENR_val).init(base_address + 0x54);

    /// AHB3LPENR
    const AHB3LPENR_val = packed struct {
        /// FMCLPEN [0:0]
        /// Flexible memory controller module clock
        FMCLPEN: u1 = 1,
        /// QSPILPEN [1:1]
        /// Quand SPI memory controller clock enable
        QSPILPEN: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB3 peripheral clock enable in low power
    pub const AHB3LPENR = Register(AHB3LPENR_val).init(base_address + 0x58);

    /// APB1LPENR
    const APB1LPENR_val = packed struct {
        /// TIM2LPEN [0:0]
        /// TIM2 clock enable during Sleep
        TIM2LPEN: u1 = 1,
        /// TIM3LPEN [1:1]
        /// TIM3 clock enable during Sleep
        TIM3LPEN: u1 = 1,
        /// TIM4LPEN [2:2]
        /// TIM4 clock enable during Sleep
        TIM4LPEN: u1 = 1,
        /// TIM5LPEN [3:3]
        /// TIM5 clock enable during Sleep
        TIM5LPEN: u1 = 1,
        /// TIM6LPEN [4:4]
        /// TIM6 clock enable during Sleep
        TIM6LPEN: u1 = 1,
        /// TIM7LPEN [5:5]
        /// TIM7 clock enable during Sleep
        TIM7LPEN: u1 = 1,
        /// TIM12LPEN [6:6]
        /// TIM12 clock enable during Sleep
        TIM12LPEN: u1 = 1,
        /// TIM13LPEN [7:7]
        /// TIM13 clock enable during Sleep
        TIM13LPEN: u1 = 1,
        /// TIM14LPEN [8:8]
        /// TIM14 clock enable during Sleep
        TIM14LPEN: u1 = 1,
        /// LPTIM1LPEN [9:9]
        /// low power timer 1 clock enable during
        LPTIM1LPEN: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// WWDGLPEN [11:11]
        /// Window watchdog clock enable during
        WWDGLPEN: u1 = 1,
        /// unused [12:13]
        _unused12: u2 = 0,
        /// SPI2LPEN [14:14]
        /// SPI2 clock enable during Sleep
        SPI2LPEN: u1 = 1,
        /// SPI3LPEN [15:15]
        /// SPI3 clock enable during Sleep
        SPI3LPEN: u1 = 1,
        /// SPDIFRXLPEN [16:16]
        /// SPDIF-RX clock enable during sleep
        SPDIFRXLPEN: u1 = 0,
        /// USART2LPEN [17:17]
        /// USART2 clock enable during Sleep
        USART2LPEN: u1 = 1,
        /// USART3LPEN [18:18]
        /// USART3 clock enable during Sleep
        USART3LPEN: u1 = 1,
        /// UART4LPEN [19:19]
        /// UART4 clock enable during Sleep
        UART4LPEN: u1 = 1,
        /// UART5LPEN [20:20]
        /// UART5 clock enable during Sleep
        UART5LPEN: u1 = 1,
        /// I2C1LPEN [21:21]
        /// I2C1 clock enable during Sleep
        I2C1LPEN: u1 = 1,
        /// I2C2LPEN [22:22]
        /// I2C2 clock enable during Sleep
        I2C2LPEN: u1 = 1,
        /// I2C3LPEN [23:23]
        /// I2C3 clock enable during Sleep
        I2C3LPEN: u1 = 1,
        /// I2C4LPEN [24:24]
        /// I2C4 clock enable during Sleep
        I2C4LPEN: u1 = 0,
        /// CAN1LPEN [25:25]
        /// CAN 1 clock enable during Sleep
        CAN1LPEN: u1 = 1,
        /// CAN2LPEN [26:26]
        /// CAN 2 clock enable during Sleep
        CAN2LPEN: u1 = 1,
        /// CECLPEN [27:27]
        /// HDMI-CEN clock enable during Sleep
        CECLPEN: u1 = 0,
        /// PWRLPEN [28:28]
        /// Power interface clock enable during
        PWRLPEN: u1 = 1,
        /// DACLPEN [29:29]
        /// DAC interface clock enable during Sleep
        DACLPEN: u1 = 1,
        /// UART7LPEN [30:30]
        /// UART7 clock enable during Sleep
        UART7LPEN: u1 = 0,
        /// UART8LPEN [31:31]
        /// UART8 clock enable during Sleep
        UART8LPEN: u1 = 0,
    };
    /// APB1 peripheral clock enable in low power
    pub const APB1LPENR = Register(APB1LPENR_val).init(base_address + 0x60);

    /// APB2LPENR
    const APB2LPENR_val = packed struct {
        /// TIM1LPEN [0:0]
        /// TIM1 clock enable during Sleep
        TIM1LPEN: u1 = 1,
        /// TIM8LPEN [1:1]
        /// TIM8 clock enable during Sleep
        TIM8LPEN: u1 = 1,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// USART1LPEN [4:4]
        /// USART1 clock enable during Sleep
        USART1LPEN: u1 = 1,
        /// USART6LPEN [5:5]
        /// USART6 clock enable during Sleep
        USART6LPEN: u1 = 1,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// ADC1LPEN [8:8]
        /// ADC1 clock enable during Sleep
        ADC1LPEN: u1 = 1,
        /// ADC2LPEN [9:9]
        /// ADC2 clock enable during Sleep
        ADC2LPEN: u1 = 1,
        /// ADC3LPEN [10:10]
        /// ADC 3 clock enable during Sleep
        ADC3LPEN: u1 = 1,
        /// SDMMC1LPEN [11:11]
        /// SDMMC1 clock enable during Sleep
        SDMMC1LPEN: u1 = 1,
        /// SPI1LPEN [12:12]
        /// SPI 1 clock enable during Sleep
        SPI1LPEN: u1 = 1,
        /// SPI4LPEN [13:13]
        /// SPI 4 clock enable during Sleep
        SPI4LPEN: u1 = 0,
        /// SYSCFGLPEN [14:14]
        /// System configuration controller clock
        SYSCFGLPEN: u1 = 1,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// TIM9LPEN [16:16]
        /// TIM9 clock enable during sleep
        TIM9LPEN: u1 = 1,
        /// TIM10LPEN [17:17]
        /// TIM10 clock enable during Sleep
        TIM10LPEN: u1 = 1,
        /// TIM11LPEN [18:18]
        /// TIM11 clock enable during Sleep
        TIM11LPEN: u1 = 1,
        /// unused [19:19]
        _unused19: u1 = 0,
        /// SPI5LPEN [20:20]
        /// SPI 5 clock enable during Sleep
        SPI5LPEN: u1 = 0,
        /// SPI6LPEN [21:21]
        /// SPI 6 clock enable during Sleep
        SPI6LPEN: u1 = 0,
        /// SAI1LPEN [22:22]
        /// SAI1 clock enable during sleep
        SAI1LPEN: u1 = 0,
        /// SAI2LPEN [23:23]
        /// SAI2 clock enable during sleep
        SAI2LPEN: u1 = 0,
        /// unused [24:25]
        _unused24: u2 = 0,
        /// LTDCLPEN [26:26]
        /// LTDC clock enable during sleep
        LTDCLPEN: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// APB2 peripheral clock enabled in low power
    pub const APB2LPENR = Register(APB2LPENR_val).init(base_address + 0x64);

    /// BDCR
    const BDCR_val = packed struct {
        /// LSEON [0:0]
        /// External low-speed oscillator
        LSEON: u1 = 0,
        /// LSERDY [1:1]
        /// External low-speed oscillator
        LSERDY: u1 = 0,
        /// LSEBYP [2:2]
        /// External low-speed oscillator
        LSEBYP: u1 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// RTCSEL0 [8:8]
        /// RTC clock source selection
        RTCSEL0: u1 = 0,
        /// RTCSEL1 [9:9]
        /// RTC clock source selection
        RTCSEL1: u1 = 0,
        /// unused [10:14]
        _unused10: u5 = 0,
        /// RTCEN [15:15]
        /// RTC clock enable
        RTCEN: u1 = 0,
        /// BDRST [16:16]
        /// Backup domain software
        BDRST: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Backup domain control register
    pub const BDCR = Register(BDCR_val).init(base_address + 0x70);

    /// CSR
    const CSR_val = packed struct {
        /// LSION [0:0]
        /// Internal low-speed oscillator
        LSION: u1 = 0,
        /// LSIRDY [1:1]
        /// Internal low-speed oscillator
        LSIRDY: u1 = 0,
        /// unused [2:23]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        /// RMVF [24:24]
        /// Remove reset flag
        RMVF: u1 = 0,
        /// BORRSTF [25:25]
        /// BOR reset flag
        BORRSTF: u1 = 1,
        /// PADRSTF [26:26]
        /// PIN reset flag
        PADRSTF: u1 = 1,
        /// PORRSTF [27:27]
        /// POR/PDR reset flag
        PORRSTF: u1 = 1,
        /// SFTRSTF [28:28]
        /// Software reset flag
        SFTRSTF: u1 = 0,
        /// WDGRSTF [29:29]
        /// Independent watchdog reset
        WDGRSTF: u1 = 0,
        /// WWDGRSTF [30:30]
        /// Window watchdog reset flag
        WWDGRSTF: u1 = 0,
        /// LPWRRSTF [31:31]
        /// Low-power reset flag
        LPWRRSTF: u1 = 0,
    };
    /// clock control &amp; status
    pub const CSR = Register(CSR_val).init(base_address + 0x74);

    /// SSCGR
    const SSCGR_val = packed struct {
        /// MODPER [0:12]
        /// Modulation period
        MODPER: u13 = 0,
        /// INCSTEP [13:27]
        /// Incrementation step
        INCSTEP: u15 = 0,
        /// unused [28:29]
        _unused28: u2 = 0,
        /// SPREADSEL [30:30]
        /// Spread Select
        SPREADSEL: u1 = 0,
        /// SSCGEN [31:31]
        /// Spread spectrum modulation
        SSCGEN: u1 = 0,
    };
    /// spread spectrum clock generation
    pub const SSCGR = Register(SSCGR_val).init(base_address + 0x80);

    /// PLLI2SCFGR
    const PLLI2SCFGR_val = packed struct {
        /// unused [0:5]
        _unused0: u6 = 0,
        /// PLLI2SN [6:14]
        /// PLLI2S multiplication factor for
        PLLI2SN: u9 = 192,
        /// unused [15:23]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        /// PLLI2SQ [24:27]
        /// PLLI2S division factor for SAI1
        PLLI2SQ: u4 = 0,
        /// PLLI2SR [28:30]
        /// PLLI2S division factor for I2S
        PLLI2SR: u3 = 2,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// PLLI2S configuration register
    pub const PLLI2SCFGR = Register(PLLI2SCFGR_val).init(base_address + 0x84);

    /// PLLSAICFGR
    const PLLSAICFGR_val = packed struct {
        /// unused [0:5]
        _unused0: u6 = 0,
        /// PLLSAIN [6:14]
        /// PLLSAI division factor for
        PLLSAIN: u9 = 192,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// PLLSAIP [16:17]
        /// PLLSAI division factor for 48MHz
        PLLSAIP: u2 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// PLLSAIQ [24:27]
        /// PLLSAI division factor for SAI
        PLLSAIQ: u4 = 0,
        /// PLLSAIR [28:30]
        /// PLLSAI division factor for LCD
        PLLSAIR: u3 = 2,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// PLL configuration register
    pub const PLLSAICFGR = Register(PLLSAICFGR_val).init(base_address + 0x88);

    /// DKCFGR1
    const DKCFGR1_val = packed struct {
        /// PLLI2SDIV [0:4]
        /// PLLI2S division factor for SAI1
        PLLI2SDIV: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// PLLSAIDIVQ [8:12]
        /// PLLSAI division factor for SAI1
        PLLSAIDIVQ: u5 = 16,
        /// unused [13:15]
        _unused13: u3 = 1,
        /// PLLSAIDIVR [16:17]
        /// division factor for
        PLLSAIDIVR: u2 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// SAI1SEL [20:21]
        /// SAI1 clock source
        SAI1SEL: u2 = 0,
        /// SAI2SEL [22:23]
        /// SAI2 clock source
        SAI2SEL: u2 = 0,
        /// TIMPRE [24:24]
        /// Timers clocks prescalers
        TIMPRE: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 16,
    };
    /// dedicated clocks configuration
    pub const DKCFGR1 = Register(DKCFGR1_val).init(base_address + 0x8c);

    /// DKCFGR2
    const DKCFGR2_val = packed struct {
        /// USART1SEL [0:1]
        /// USART 1 clock source
        USART1SEL: u2 = 0,
        /// USART2SEL [2:3]
        /// USART 2 clock source
        USART2SEL: u2 = 0,
        /// USART3SEL [4:5]
        /// USART 3 clock source
        USART3SEL: u2 = 0,
        /// UART4SEL [6:7]
        /// UART 4 clock source
        UART4SEL: u2 = 0,
        /// UART5SEL [8:9]
        /// UART 5 clock source
        UART5SEL: u2 = 0,
        /// USART6SEL [10:11]
        /// USART 6 clock source
        USART6SEL: u2 = 0,
        /// UART7SEL [12:13]
        /// UART 7 clock source
        UART7SEL: u2 = 3,
        /// UART8SEL [14:15]
        /// UART 8 clock source
        UART8SEL: u2 = 0,
        /// I2C1SEL [16:17]
        /// I2C1 clock source
        I2C1SEL: u2 = 0,
        /// I2C2SEL [18:19]
        /// I2C2 clock source
        I2C2SEL: u2 = 0,
        /// I2C3SEL [20:21]
        /// I2C3 clock source
        I2C3SEL: u2 = 0,
        /// I2C4SEL [22:23]
        /// I2C4 clock source
        I2C4SEL: u2 = 0,
        /// LPTIM1SEL [24:25]
        /// Low power timer 1 clock source
        LPTIM1SEL: u2 = 0,
        /// CECSEL [26:26]
        /// HDMI-CEC clock source
        CECSEL: u1 = 0,
        /// CK48MSEL [27:27]
        /// 48MHz clock source
        CK48MSEL: u1 = 0,
        /// SDMMC1SEL [28:28]
        /// SDMMC1 clock source
        SDMMC1SEL: u1 = 0,
        /// SDMMC2SEL [29:29]
        /// SDMMC2 clock source
        SDMMC2SEL: u1 = 1,
        /// DSISEL [30:30]
        /// DSI clock source selection
        DSISEL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// dedicated clocks configuration
    pub const DKCFGR2 = Register(DKCFGR2_val).init(base_address + 0x90);
};

/// General-purpose I/Os
pub const GPIOD = struct {
    const base_address = 0x40020c00;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOC = struct {
    const base_address = 0x40020800;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOK = struct {
    const base_address = 0x40022800;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOJ = struct {
    const base_address = 0x40022400;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOI = struct {
    const base_address = 0x40022000;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOH = struct {
    const base_address = 0x40021c00;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOG = struct {
    const base_address = 0x40021800;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOF = struct {
    const base_address = 0x40021400;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOE = struct {
    const base_address = 0x40021000;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port D Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port D Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port D Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port D Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port D Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port D Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port D Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port D Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port D Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port D Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port D Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port D Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port D Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port D Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port D Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port D Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOB = struct {
    const base_address = 0x40020400;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 2,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 2,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 0,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 0,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 0,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 3,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 1,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 0,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 0,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 0,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function low
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port B Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port B Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port B Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port B Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port B Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port B Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port B Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port B Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port B Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port B Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port B Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port B Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port B Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port B Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port B Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port B Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// General-purpose I/Os
pub const GPIOA = struct {
    const base_address = 0x40020000;
    /// MODER
    const MODER_val = packed struct {
        /// MODER0 [0:1]
        /// Port x configuration bits (y =
        MODER0: u2 = 0,
        /// MODER1 [2:3]
        /// Port x configuration bits (y =
        MODER1: u2 = 0,
        /// MODER2 [4:5]
        /// Port x configuration bits (y =
        MODER2: u2 = 0,
        /// MODER3 [6:7]
        /// Port x configuration bits (y =
        MODER3: u2 = 0,
        /// MODER4 [8:9]
        /// Port x configuration bits (y =
        MODER4: u2 = 0,
        /// MODER5 [10:11]
        /// Port x configuration bits (y =
        MODER5: u2 = 0,
        /// MODER6 [12:13]
        /// Port x configuration bits (y =
        MODER6: u2 = 0,
        /// MODER7 [14:15]
        /// Port x configuration bits (y =
        MODER7: u2 = 0,
        /// MODER8 [16:17]
        /// Port x configuration bits (y =
        MODER8: u2 = 0,
        /// MODER9 [18:19]
        /// Port x configuration bits (y =
        MODER9: u2 = 0,
        /// MODER10 [20:21]
        /// Port x configuration bits (y =
        MODER10: u2 = 0,
        /// MODER11 [22:23]
        /// Port x configuration bits (y =
        MODER11: u2 = 0,
        /// MODER12 [24:25]
        /// Port x configuration bits (y =
        MODER12: u2 = 0,
        /// MODER13 [26:27]
        /// Port x configuration bits (y =
        MODER13: u2 = 2,
        /// MODER14 [28:29]
        /// Port x configuration bits (y =
        MODER14: u2 = 2,
        /// MODER15 [30:31]
        /// Port x configuration bits (y =
        MODER15: u2 = 2,
    };
    /// GPIO port mode register
    pub const MODER = Register(MODER_val).init(base_address + 0x0);

    /// OTYPER
    const OTYPER_val = packed struct {
        /// OT0 [0:0]
        /// Port x configuration bits (y =
        OT0: u1 = 0,
        /// OT1 [1:1]
        /// Port x configuration bits (y =
        OT1: u1 = 0,
        /// OT2 [2:2]
        /// Port x configuration bits (y =
        OT2: u1 = 0,
        /// OT3 [3:3]
        /// Port x configuration bits (y =
        OT3: u1 = 0,
        /// OT4 [4:4]
        /// Port x configuration bits (y =
        OT4: u1 = 0,
        /// OT5 [5:5]
        /// Port x configuration bits (y =
        OT5: u1 = 0,
        /// OT6 [6:6]
        /// Port x configuration bits (y =
        OT6: u1 = 0,
        /// OT7 [7:7]
        /// Port x configuration bits (y =
        OT7: u1 = 0,
        /// OT8 [8:8]
        /// Port x configuration bits (y =
        OT8: u1 = 0,
        /// OT9 [9:9]
        /// Port x configuration bits (y =
        OT9: u1 = 0,
        /// OT10 [10:10]
        /// Port x configuration bits (y =
        OT10: u1 = 0,
        /// OT11 [11:11]
        /// Port x configuration bits (y =
        OT11: u1 = 0,
        /// OT12 [12:12]
        /// Port x configuration bits (y =
        OT12: u1 = 0,
        /// OT13 [13:13]
        /// Port x configuration bits (y =
        OT13: u1 = 0,
        /// OT14 [14:14]
        /// Port x configuration bits (y =
        OT14: u1 = 0,
        /// OT15 [15:15]
        /// Port x configuration bits (y =
        OT15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output type register
    pub const OTYPER = Register(OTYPER_val).init(base_address + 0x4);

    /// OSPEEDR
    const OSPEEDR_val = packed struct {
        /// OSPEEDR0 [0:1]
        /// Port x configuration bits (y =
        OSPEEDR0: u2 = 0,
        /// OSPEEDR1 [2:3]
        /// Port x configuration bits (y =
        OSPEEDR1: u2 = 0,
        /// OSPEEDR2 [4:5]
        /// Port x configuration bits (y =
        OSPEEDR2: u2 = 0,
        /// OSPEEDR3 [6:7]
        /// Port x configuration bits (y =
        OSPEEDR3: u2 = 0,
        /// OSPEEDR4 [8:9]
        /// Port x configuration bits (y =
        OSPEEDR4: u2 = 0,
        /// OSPEEDR5 [10:11]
        /// Port x configuration bits (y =
        OSPEEDR5: u2 = 0,
        /// OSPEEDR6 [12:13]
        /// Port x configuration bits (y =
        OSPEEDR6: u2 = 0,
        /// OSPEEDR7 [14:15]
        /// Port x configuration bits (y =
        OSPEEDR7: u2 = 0,
        /// OSPEEDR8 [16:17]
        /// Port x configuration bits (y =
        OSPEEDR8: u2 = 0,
        /// OSPEEDR9 [18:19]
        /// Port x configuration bits (y =
        OSPEEDR9: u2 = 0,
        /// OSPEEDR10 [20:21]
        /// Port x configuration bits (y =
        OSPEEDR10: u2 = 0,
        /// OSPEEDR11 [22:23]
        /// Port x configuration bits (y =
        OSPEEDR11: u2 = 0,
        /// OSPEEDR12 [24:25]
        /// Port x configuration bits (y =
        OSPEEDR12: u2 = 0,
        /// OSPEEDR13 [26:27]
        /// Port x configuration bits (y =
        OSPEEDR13: u2 = 0,
        /// OSPEEDR14 [28:29]
        /// Port x configuration bits (y =
        OSPEEDR14: u2 = 0,
        /// OSPEEDR15 [30:31]
        /// Port x configuration bits (y =
        OSPEEDR15: u2 = 0,
    };
    /// GPIO port output speed
    pub const OSPEEDR = Register(OSPEEDR_val).init(base_address + 0x8);

    /// PUPDR
    const PUPDR_val = packed struct {
        /// PUPDR0 [0:1]
        /// Port x configuration bits (y =
        PUPDR0: u2 = 0,
        /// PUPDR1 [2:3]
        /// Port x configuration bits (y =
        PUPDR1: u2 = 0,
        /// PUPDR2 [4:5]
        /// Port x configuration bits (y =
        PUPDR2: u2 = 0,
        /// PUPDR3 [6:7]
        /// Port x configuration bits (y =
        PUPDR3: u2 = 0,
        /// PUPDR4 [8:9]
        /// Port x configuration bits (y =
        PUPDR4: u2 = 0,
        /// PUPDR5 [10:11]
        /// Port x configuration bits (y =
        PUPDR5: u2 = 0,
        /// PUPDR6 [12:13]
        /// Port x configuration bits (y =
        PUPDR6: u2 = 0,
        /// PUPDR7 [14:15]
        /// Port x configuration bits (y =
        PUPDR7: u2 = 0,
        /// PUPDR8 [16:17]
        /// Port x configuration bits (y =
        PUPDR8: u2 = 0,
        /// PUPDR9 [18:19]
        /// Port x configuration bits (y =
        PUPDR9: u2 = 0,
        /// PUPDR10 [20:21]
        /// Port x configuration bits (y =
        PUPDR10: u2 = 0,
        /// PUPDR11 [22:23]
        /// Port x configuration bits (y =
        PUPDR11: u2 = 0,
        /// PUPDR12 [24:25]
        /// Port x configuration bits (y =
        PUPDR12: u2 = 0,
        /// PUPDR13 [26:27]
        /// Port x configuration bits (y =
        PUPDR13: u2 = 1,
        /// PUPDR14 [28:29]
        /// Port x configuration bits (y =
        PUPDR14: u2 = 2,
        /// PUPDR15 [30:31]
        /// Port x configuration bits (y =
        PUPDR15: u2 = 1,
    };
    /// GPIO port pull-up/pull-down
    pub const PUPDR = Register(PUPDR_val).init(base_address + 0xc);

    /// IDR
    const IDR_val = packed struct {
        /// IDR0 [0:0]
        /// Port input data (y =
        IDR0: u1 = 0,
        /// IDR1 [1:1]
        /// Port input data (y =
        IDR1: u1 = 0,
        /// IDR2 [2:2]
        /// Port input data (y =
        IDR2: u1 = 0,
        /// IDR3 [3:3]
        /// Port input data (y =
        IDR3: u1 = 0,
        /// IDR4 [4:4]
        /// Port input data (y =
        IDR4: u1 = 0,
        /// IDR5 [5:5]
        /// Port input data (y =
        IDR5: u1 = 0,
        /// IDR6 [6:6]
        /// Port input data (y =
        IDR6: u1 = 0,
        /// IDR7 [7:7]
        /// Port input data (y =
        IDR7: u1 = 0,
        /// IDR8 [8:8]
        /// Port input data (y =
        IDR8: u1 = 0,
        /// IDR9 [9:9]
        /// Port input data (y =
        IDR9: u1 = 0,
        /// IDR10 [10:10]
        /// Port input data (y =
        IDR10: u1 = 0,
        /// IDR11 [11:11]
        /// Port input data (y =
        IDR11: u1 = 0,
        /// IDR12 [12:12]
        /// Port input data (y =
        IDR12: u1 = 0,
        /// IDR13 [13:13]
        /// Port input data (y =
        IDR13: u1 = 0,
        /// IDR14 [14:14]
        /// Port input data (y =
        IDR14: u1 = 0,
        /// IDR15 [15:15]
        /// Port input data (y =
        IDR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port input data register
    pub const IDR = Register(IDR_val).init(base_address + 0x10);

    /// ODR
    const ODR_val = packed struct {
        /// ODR0 [0:0]
        /// Port output data (y =
        ODR0: u1 = 0,
        /// ODR1 [1:1]
        /// Port output data (y =
        ODR1: u1 = 0,
        /// ODR2 [2:2]
        /// Port output data (y =
        ODR2: u1 = 0,
        /// ODR3 [3:3]
        /// Port output data (y =
        ODR3: u1 = 0,
        /// ODR4 [4:4]
        /// Port output data (y =
        ODR4: u1 = 0,
        /// ODR5 [5:5]
        /// Port output data (y =
        ODR5: u1 = 0,
        /// ODR6 [6:6]
        /// Port output data (y =
        ODR6: u1 = 0,
        /// ODR7 [7:7]
        /// Port output data (y =
        ODR7: u1 = 0,
        /// ODR8 [8:8]
        /// Port output data (y =
        ODR8: u1 = 0,
        /// ODR9 [9:9]
        /// Port output data (y =
        ODR9: u1 = 0,
        /// ODR10 [10:10]
        /// Port output data (y =
        ODR10: u1 = 0,
        /// ODR11 [11:11]
        /// Port output data (y =
        ODR11: u1 = 0,
        /// ODR12 [12:12]
        /// Port output data (y =
        ODR12: u1 = 0,
        /// ODR13 [13:13]
        /// Port output data (y =
        ODR13: u1 = 0,
        /// ODR14 [14:14]
        /// Port output data (y =
        ODR14: u1 = 0,
        /// ODR15 [15:15]
        /// Port output data (y =
        ODR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port output data register
    pub const ODR = Register(ODR_val).init(base_address + 0x14);

    /// BSRR
    const BSRR_val = packed struct {
        /// BS0 [0:0]
        /// Port x set bit y (y=
        BS0: u1 = 0,
        /// BS1 [1:1]
        /// Port x set bit y (y=
        BS1: u1 = 0,
        /// BS2 [2:2]
        /// Port x set bit y (y=
        BS2: u1 = 0,
        /// BS3 [3:3]
        /// Port x set bit y (y=
        BS3: u1 = 0,
        /// BS4 [4:4]
        /// Port x set bit y (y=
        BS4: u1 = 0,
        /// BS5 [5:5]
        /// Port x set bit y (y=
        BS5: u1 = 0,
        /// BS6 [6:6]
        /// Port x set bit y (y=
        BS6: u1 = 0,
        /// BS7 [7:7]
        /// Port x set bit y (y=
        BS7: u1 = 0,
        /// BS8 [8:8]
        /// Port x set bit y (y=
        BS8: u1 = 0,
        /// BS9 [9:9]
        /// Port x set bit y (y=
        BS9: u1 = 0,
        /// BS10 [10:10]
        /// Port x set bit y (y=
        BS10: u1 = 0,
        /// BS11 [11:11]
        /// Port x set bit y (y=
        BS11: u1 = 0,
        /// BS12 [12:12]
        /// Port x set bit y (y=
        BS12: u1 = 0,
        /// BS13 [13:13]
        /// Port x set bit y (y=
        BS13: u1 = 0,
        /// BS14 [14:14]
        /// Port x set bit y (y=
        BS14: u1 = 0,
        /// BS15 [15:15]
        /// Port x set bit y (y=
        BS15: u1 = 0,
        /// BR0 [16:16]
        /// Port x set bit y (y=
        BR0: u1 = 0,
        /// BR1 [17:17]
        /// Port x reset bit y (y =
        BR1: u1 = 0,
        /// BR2 [18:18]
        /// Port x reset bit y (y =
        BR2: u1 = 0,
        /// BR3 [19:19]
        /// Port x reset bit y (y =
        BR3: u1 = 0,
        /// BR4 [20:20]
        /// Port x reset bit y (y =
        BR4: u1 = 0,
        /// BR5 [21:21]
        /// Port x reset bit y (y =
        BR5: u1 = 0,
        /// BR6 [22:22]
        /// Port x reset bit y (y =
        BR6: u1 = 0,
        /// BR7 [23:23]
        /// Port x reset bit y (y =
        BR7: u1 = 0,
        /// BR8 [24:24]
        /// Port x reset bit y (y =
        BR8: u1 = 0,
        /// BR9 [25:25]
        /// Port x reset bit y (y =
        BR9: u1 = 0,
        /// BR10 [26:26]
        /// Port x reset bit y (y =
        BR10: u1 = 0,
        /// BR11 [27:27]
        /// Port x reset bit y (y =
        BR11: u1 = 0,
        /// BR12 [28:28]
        /// Port x reset bit y (y =
        BR12: u1 = 0,
        /// BR13 [29:29]
        /// Port x reset bit y (y =
        BR13: u1 = 0,
        /// BR14 [30:30]
        /// Port x reset bit y (y =
        BR14: u1 = 0,
        /// BR15 [31:31]
        /// Port x reset bit y (y =
        BR15: u1 = 0,
    };
    /// GPIO port bit set/reset
    pub const BSRR = Register(BSRR_val).init(base_address + 0x18);

    /// LCKR
    const LCKR_val = packed struct {
        /// LCK0 [0:0]
        /// Port x lock bit y (y=
        LCK0: u1 = 0,
        /// LCK1 [1:1]
        /// Port x lock bit y (y=
        LCK1: u1 = 0,
        /// LCK2 [2:2]
        /// Port x lock bit y (y=
        LCK2: u1 = 0,
        /// LCK3 [3:3]
        /// Port x lock bit y (y=
        LCK3: u1 = 0,
        /// LCK4 [4:4]
        /// Port x lock bit y (y=
        LCK4: u1 = 0,
        /// LCK5 [5:5]
        /// Port x lock bit y (y=
        LCK5: u1 = 0,
        /// LCK6 [6:6]
        /// Port x lock bit y (y=
        LCK6: u1 = 0,
        /// LCK7 [7:7]
        /// Port x lock bit y (y=
        LCK7: u1 = 0,
        /// LCK8 [8:8]
        /// Port x lock bit y (y=
        LCK8: u1 = 0,
        /// LCK9 [9:9]
        /// Port x lock bit y (y=
        LCK9: u1 = 0,
        /// LCK10 [10:10]
        /// Port x lock bit y (y=
        LCK10: u1 = 0,
        /// LCK11 [11:11]
        /// Port x lock bit y (y=
        LCK11: u1 = 0,
        /// LCK12 [12:12]
        /// Port x lock bit y (y=
        LCK12: u1 = 0,
        /// LCK13 [13:13]
        /// Port x lock bit y (y=
        LCK13: u1 = 0,
        /// LCK14 [14:14]
        /// Port x lock bit y (y=
        LCK14: u1 = 0,
        /// LCK15 [15:15]
        /// Port x lock bit y (y=
        LCK15: u1 = 0,
        /// LCKK [16:16]
        /// Port x lock bit y (y=
        LCKK: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port configuration lock
    pub const LCKR = Register(LCKR_val).init(base_address + 0x1c);

    /// AFRL
    const AFRL_val = packed struct {
        /// AFRL0 [0:3]
        /// Alternate function selection for port x
        AFRL0: u4 = 0,
        /// AFRL1 [4:7]
        /// Alternate function selection for port x
        AFRL1: u4 = 0,
        /// AFRL2 [8:11]
        /// Alternate function selection for port x
        AFRL2: u4 = 0,
        /// AFRL3 [12:15]
        /// Alternate function selection for port x
        AFRL3: u4 = 0,
        /// AFRL4 [16:19]
        /// Alternate function selection for port x
        AFRL4: u4 = 0,
        /// AFRL5 [20:23]
        /// Alternate function selection for port x
        AFRL5: u4 = 0,
        /// AFRL6 [24:27]
        /// Alternate function selection for port x
        AFRL6: u4 = 0,
        /// AFRL7 [28:31]
        /// Alternate function selection for port x
        AFRL7: u4 = 0,
    };
    /// GPIO alternate function low
    pub const AFRL = Register(AFRL_val).init(base_address + 0x20);

    /// AFRH
    const AFRH_val = packed struct {
        /// AFRH8 [0:3]
        /// Alternate function selection for port x
        AFRH8: u4 = 0,
        /// AFRH9 [4:7]
        /// Alternate function selection for port x
        AFRH9: u4 = 0,
        /// AFRH10 [8:11]
        /// Alternate function selection for port x
        AFRH10: u4 = 0,
        /// AFRH11 [12:15]
        /// Alternate function selection for port x
        AFRH11: u4 = 0,
        /// AFRH12 [16:19]
        /// Alternate function selection for port x
        AFRH12: u4 = 0,
        /// AFRH13 [20:23]
        /// Alternate function selection for port x
        AFRH13: u4 = 0,
        /// AFRH14 [24:27]
        /// Alternate function selection for port x
        AFRH14: u4 = 0,
        /// AFRH15 [28:31]
        /// Alternate function selection for port x
        AFRH15: u4 = 0,
    };
    /// GPIO alternate function high
    pub const AFRH = Register(AFRH_val).init(base_address + 0x24);

    /// BRR
    const BRR_val = packed struct {
        /// BR0 [0:0]
        /// Port A Reset bit 0
        BR0: u1 = 0,
        /// BR1 [1:1]
        /// Port A Reset bit 1
        BR1: u1 = 0,
        /// BR2 [2:2]
        /// Port A Reset bit 2
        BR2: u1 = 0,
        /// BR3 [3:3]
        /// Port A Reset bit 3
        BR3: u1 = 0,
        /// BR4 [4:4]
        /// Port A Reset bit 4
        BR4: u1 = 0,
        /// BR5 [5:5]
        /// Port A Reset bit 5
        BR5: u1 = 0,
        /// BR6 [6:6]
        /// Port A Reset bit 6
        BR6: u1 = 0,
        /// BR7 [7:7]
        /// Port A Reset bit 7
        BR7: u1 = 0,
        /// BR8 [8:8]
        /// Port A Reset bit 8
        BR8: u1 = 0,
        /// BR9 [9:9]
        /// Port A Reset bit 9
        BR9: u1 = 0,
        /// BR10 [10:10]
        /// Port A Reset bit 10
        BR10: u1 = 0,
        /// BR11 [11:11]
        /// Port A Reset bit 11
        BR11: u1 = 0,
        /// BR12 [12:12]
        /// Port A Reset bit 12
        BR12: u1 = 0,
        /// BR13 [13:13]
        /// Port A Reset bit 13
        BR13: u1 = 0,
        /// BR14 [14:14]
        /// Port A Reset bit 14
        BR14: u1 = 0,
        /// BR15 [15:15]
        /// Port A Reset bit 15
        BR15: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// GPIO port bit reset register
    pub const BRR = Register(BRR_val).init(base_address + 0x28);
};

/// System configuration controller
pub const SYSCFG = struct {
    const base_address = 0x40013800;
    /// MEMRM
    const MEMRM_val = packed struct {
        /// MEM_MODE [0:2]
        /// Memory mapping selection
        MEM_MODE: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// FB_MODE [8:8]
        /// Flash bank mode selection
        FB_MODE: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// SWP_FMC [10:11]
        /// FMC memory mapping swap
        SWP_FMC: u2 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// memory remap register
    pub const MEMRM = Register(MEMRM_val).init(base_address + 0x0);

    /// PMC
    const PMC_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// ADC1DC2 [16:16]
        /// ADC1DC2
        ADC1DC2: u1 = 0,
        /// ADC2DC2 [17:17]
        /// ADC2DC2
        ADC2DC2: u1 = 0,
        /// ADC3DC2 [18:18]
        /// ADC3DC2
        ADC3DC2: u1 = 0,
        /// unused [19:22]
        _unused19: u4 = 0,
        /// MII_RMII_SEL [23:23]
        /// Ethernet PHY interface
        MII_RMII_SEL: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// peripheral mode configuration
    pub const PMC = Register(PMC_val).init(base_address + 0x4);

    /// EXTICR1
    const EXTICR1_val = packed struct {
        /// EXTI0 [0:3]
        /// EXTI x configuration (x = 0 to
        EXTI0: u4 = 0,
        /// EXTI1 [4:7]
        /// EXTI x configuration (x = 0 to
        EXTI1: u4 = 0,
        /// EXTI2 [8:11]
        /// EXTI x configuration (x = 0 to
        EXTI2: u4 = 0,
        /// EXTI3 [12:15]
        /// EXTI x configuration (x = 0 to
        EXTI3: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// external interrupt configuration register
    pub const EXTICR1 = Register(EXTICR1_val).init(base_address + 0x8);

    /// EXTICR2
    const EXTICR2_val = packed struct {
        /// EXTI4 [0:3]
        /// EXTI x configuration (x = 4 to
        EXTI4: u4 = 0,
        /// EXTI5 [4:7]
        /// EXTI x configuration (x = 4 to
        EXTI5: u4 = 0,
        /// EXTI6 [8:11]
        /// EXTI x configuration (x = 4 to
        EXTI6: u4 = 0,
        /// EXTI7 [12:15]
        /// EXTI x configuration (x = 4 to
        EXTI7: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// external interrupt configuration register
    pub const EXTICR2 = Register(EXTICR2_val).init(base_address + 0xc);

    /// EXTICR3
    const EXTICR3_val = packed struct {
        /// EXTI8 [0:3]
        /// EXTI x configuration (x = 8 to
        EXTI8: u4 = 0,
        /// EXTI9 [4:7]
        /// EXTI x configuration (x = 8 to
        EXTI9: u4 = 0,
        /// EXTI10 [8:11]
        /// EXTI10
        EXTI10: u4 = 0,
        /// EXTI11 [12:15]
        /// EXTI x configuration (x = 8 to
        EXTI11: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// external interrupt configuration register
    pub const EXTICR3 = Register(EXTICR3_val).init(base_address + 0x10);

    /// EXTICR4
    const EXTICR4_val = packed struct {
        /// EXTI12 [0:3]
        /// EXTI x configuration (x = 12 to
        EXTI12: u4 = 0,
        /// EXTI13 [4:7]
        /// EXTI x configuration (x = 12 to
        EXTI13: u4 = 0,
        /// EXTI14 [8:11]
        /// EXTI x configuration (x = 12 to
        EXTI14: u4 = 0,
        /// EXTI15 [12:15]
        /// EXTI x configuration (x = 12 to
        EXTI15: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// external interrupt configuration register
    pub const EXTICR4 = Register(EXTICR4_val).init(base_address + 0x14);

    /// CMPCR
    const CMPCR_val = packed struct {
        /// CMP_PD [0:0]
        /// Compensation cell
        CMP_PD: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// READY [8:8]
        /// READY
        READY: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Compensation cell control
    pub const CMPCR = Register(CMPCR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI1 = struct {
    const base_address = 0x40013000;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI2 = struct {
    const base_address = 0x40003800;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI4 = struct {
    const base_address = 0x40013400;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI5 = struct {
    const base_address = 0x40015000;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI3 = struct {
    const base_address = 0x40003c00;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Serial peripheral interface
pub const SPI6 = struct {
    const base_address = 0x40015400;
    /// CR1
    const CR1_val = packed struct {
        /// CPHA [0:0]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [1:1]
        /// Clock polarity
        CPOL: u1 = 0,
        /// MSTR [2:2]
        /// Master selection
        MSTR: u1 = 0,
        /// BR [3:5]
        /// Baud rate control
        BR: u3 = 0,
        /// SPE [6:6]
        /// SPI enable
        SPE: u1 = 0,
        /// LSBFIRST [7:7]
        /// Frame format
        LSBFIRST: u1 = 0,
        /// SSI [8:8]
        /// Internal slave select
        SSI: u1 = 0,
        /// SSM [9:9]
        /// Software slave management
        SSM: u1 = 0,
        /// RXONLY [10:10]
        /// Receive only
        RXONLY: u1 = 0,
        /// CRCL [11:11]
        /// CRC length
        CRCL: u1 = 0,
        /// CRCNEXT [12:12]
        /// CRC transfer next
        CRCNEXT: u1 = 0,
        /// CRCEN [13:13]
        /// Hardware CRC calculation
        CRCEN: u1 = 0,
        /// BIDIOE [14:14]
        /// Output enable in bidirectional
        BIDIOE: u1 = 0,
        /// BIDIMODE [15:15]
        /// Bidirectional data mode
        BIDIMODE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// RXDMAEN [0:0]
        /// Rx buffer DMA enable
        RXDMAEN: u1 = 0,
        /// TXDMAEN [1:1]
        /// Tx buffer DMA enable
        TXDMAEN: u1 = 0,
        /// SSOE [2:2]
        /// SS output enable
        SSOE: u1 = 0,
        /// NSSP [3:3]
        /// NSS pulse management
        NSSP: u1 = 0,
        /// FRF [4:4]
        /// Frame format
        FRF: u1 = 0,
        /// ERRIE [5:5]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// RXNEIE [6:6]
        /// RX buffer not empty interrupt
        RXNEIE: u1 = 0,
        /// TXEIE [7:7]
        /// Tx buffer empty interrupt
        TXEIE: u1 = 0,
        /// DS [8:11]
        /// Data size
        DS: u4 = 7,
        /// FRXTH [12:12]
        /// FIFO reception threshold
        FRXTH: u1 = 0,
        /// LDMA_RX [13:13]
        /// Last DMA transfer for
        LDMA_RX: u1 = 0,
        /// LDMA_TX [14:14]
        /// Last DMA transfer for
        LDMA_TX: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Receive buffer not empty
        RXNE: u1 = 0,
        /// TXE [1:1]
        /// Transmit buffer empty
        TXE: u1 = 1,
        /// CHSIDE [2:2]
        /// Channel side
        CHSIDE: u1 = 0,
        /// UDR [3:3]
        /// Underrun flag
        UDR: u1 = 0,
        /// CRCERR [4:4]
        /// CRC error flag
        CRCERR: u1 = 0,
        /// MODF [5:5]
        /// Mode fault
        MODF: u1 = 0,
        /// OVR [6:6]
        /// Overrun flag
        OVR: u1 = 0,
        /// BSY [7:7]
        /// Busy flag
        BSY: u1 = 0,
        /// FRE [8:8]
        /// Frame format error
        FRE: u1 = 0,
        /// FRLVL [9:10]
        /// FIFO reception level
        FRLVL: u2 = 0,
        /// FTLVL [11:12]
        /// FIFO Transmission Level
        FTLVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// DR
    const DR_val = packed struct {
        /// DR [0:15]
        /// Data register
        DR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0xc);

    /// CRCPR
    const CRCPR_val = packed struct {
        /// CRCPOLY [0:15]
        /// CRC polynomial register
        CRCPOLY: u16 = 7,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// CRC polynomial register
    pub const CRCPR = Register(CRCPR_val).init(base_address + 0x10);

    /// RXCRCR
    const RXCRCR_val = packed struct {
        /// RxCRC [0:15]
        /// Rx CRC register
        RxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// RX CRC register
    pub const RXCRCR = Register(RXCRCR_val).init(base_address + 0x14);

    /// TXCRCR
    const TXCRCR_val = packed struct {
        /// TxCRC [0:15]
        /// Tx CRC register
        TxCRC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TX CRC register
    pub const TXCRCR = Register(TXCRCR_val).init(base_address + 0x18);

    /// I2SCFGR
    const I2SCFGR_val = packed struct {
        /// CHLEN [0:0]
        /// Channel length (number of bits per audio
        CHLEN: u1 = 0,
        /// DATLEN [1:2]
        /// Data length to be
        DATLEN: u2 = 0,
        /// CKPOL [3:3]
        /// Steady state clock
        CKPOL: u1 = 0,
        /// I2SSTD [4:5]
        /// I2S standard selection
        I2SSTD: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// PCMSYNC [7:7]
        /// PCM frame synchronization
        PCMSYNC: u1 = 0,
        /// I2SCFG [8:9]
        /// I2S configuration mode
        I2SCFG: u2 = 0,
        /// I2SE [10:10]
        /// I2S Enable
        I2SE: u1 = 0,
        /// I2SMOD [11:11]
        /// I2S mode selection
        I2SMOD: u1 = 0,
        /// ASTRTEN [12:12]
        /// Asynchronous start enable
        ASTRTEN: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S configuration register
    pub const I2SCFGR = Register(I2SCFGR_val).init(base_address + 0x1c);

    /// I2SPR
    const I2SPR_val = packed struct {
        /// I2SDIV [0:7]
        /// I2S Linear prescaler
        I2SDIV: u8 = 16,
        /// ODD [8:8]
        /// Odd factor for the
        ODD: u1 = 0,
        /// MCKOE [9:9]
        /// Master clock output enable
        MCKOE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// I2S prescaler register
    pub const I2SPR = Register(I2SPR_val).init(base_address + 0x20);
};

/// Analog-to-digital converter
pub const ADC1 = struct {
    const base_address = 0x40012000;
    /// SR
    const SR_val = packed struct {
        /// AWD [0:0]
        /// Analog watchdog flag
        AWD: u1 = 0,
        /// EOC [1:1]
        /// Regular channel end of
        EOC: u1 = 0,
        /// JEOC [2:2]
        /// Injected channel end of
        JEOC: u1 = 0,
        /// JSTRT [3:3]
        /// Injected channel start
        JSTRT: u1 = 0,
        /// STRT [4:4]
        /// Regular channel start flag
        STRT: u1 = 0,
        /// OVR [5:5]
        /// Overrun
        OVR: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x0);

    /// CR1
    const CR1_val = packed struct {
        /// AWDCH [0:4]
        /// Analog watchdog channel select
        AWDCH: u5 = 0,
        /// EOCIE [5:5]
        /// Interrupt enable for EOC
        EOCIE: u1 = 0,
        /// AWDIE [6:6]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// JEOCIE [7:7]
        /// Interrupt enable for injected
        JEOCIE: u1 = 0,
        /// SCAN [8:8]
        /// Scan mode
        SCAN: u1 = 0,
        /// AWDSGL [9:9]
        /// Enable the watchdog on a single channel
        AWDSGL: u1 = 0,
        /// JAUTO [10:10]
        /// Automatic injected group
        JAUTO: u1 = 0,
        /// DISCEN [11:11]
        /// Discontinuous mode on regular
        DISCEN: u1 = 0,
        /// JDISCEN [12:12]
        /// Discontinuous mode on injected
        JDISCEN: u1 = 0,
        /// DISCNUM [13:15]
        /// Discontinuous mode channel
        DISCNUM: u3 = 0,
        /// unused [16:21]
        _unused16: u6 = 0,
        /// JAWDEN [22:22]
        /// Analog watchdog enable on injected
        JAWDEN: u1 = 0,
        /// AWDEN [23:23]
        /// Analog watchdog enable on regular
        AWDEN: u1 = 0,
        /// RES [24:25]
        /// Resolution
        RES: u2 = 0,
        /// OVRIE [26:26]
        /// Overrun interrupt enable
        OVRIE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x4);

    /// CR2
    const CR2_val = packed struct {
        /// ADON [0:0]
        /// A/D Converter ON / OFF
        ADON: u1 = 0,
        /// CONT [1:1]
        /// Continuous conversion
        CONT: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// DMA [8:8]
        /// Direct memory access mode (for single
        DMA: u1 = 0,
        /// DDS [9:9]
        /// DMA disable selection (for single ADC
        DDS: u1 = 0,
        /// EOCS [10:10]
        /// End of conversion
        EOCS: u1 = 0,
        /// ALIGN [11:11]
        /// Data alignment
        ALIGN: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// JEXTSEL [16:19]
        /// External event select for injected
        JEXTSEL: u4 = 0,
        /// JEXTEN [20:21]
        /// External trigger enable for injected
        JEXTEN: u2 = 0,
        /// JSWSTART [22:22]
        /// Start conversion of injected
        JSWSTART: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// EXTSEL [24:27]
        /// External event select for regular
        EXTSEL: u4 = 0,
        /// EXTEN [28:29]
        /// External trigger enable for regular
        EXTEN: u2 = 0,
        /// SWSTART [30:30]
        /// Start conversion of regular
        SWSTART: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x8);

    /// SMPR1
    const SMPR1_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 1
    pub const SMPR1 = Register(SMPR1_val).init(base_address + 0xc);

    /// SMPR2
    const SMPR2_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 2
    pub const SMPR2 = Register(SMPR2_val).init(base_address + 0x10);

    /// JOFR1
    const JOFR1_val = packed struct {
        /// JOFFSET1 [0:11]
        /// Data offset for injected channel
        JOFFSET1: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR1 = Register(JOFR1_val).init(base_address + 0x14);

    /// JOFR2
    const JOFR2_val = packed struct {
        /// JOFFSET2 [0:11]
        /// Data offset for injected channel
        JOFFSET2: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR2 = Register(JOFR2_val).init(base_address + 0x18);

    /// JOFR3
    const JOFR3_val = packed struct {
        /// JOFFSET3 [0:11]
        /// Data offset for injected channel
        JOFFSET3: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR3 = Register(JOFR3_val).init(base_address + 0x1c);

    /// JOFR4
    const JOFR4_val = packed struct {
        /// JOFFSET4 [0:11]
        /// Data offset for injected channel
        JOFFSET4: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR4 = Register(JOFR4_val).init(base_address + 0x20);

    /// HTR
    const HTR_val = packed struct {
        /// HT [0:11]
        /// Analog watchdog higher
        HT: u12 = 4095,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog higher threshold
    pub const HTR = Register(HTR_val).init(base_address + 0x24);

    /// LTR
    const LTR_val = packed struct {
        /// LT [0:11]
        /// Analog watchdog lower
        LT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog lower threshold
    pub const LTR = Register(LTR_val).init(base_address + 0x28);

    /// SQR1
    const SQR1_val = packed struct {
        /// SQ13 [0:4]
        /// 13th conversion in regular
        SQ13: u5 = 0,
        /// SQ14 [5:9]
        /// 14th conversion in regular
        SQ14: u5 = 0,
        /// SQ15 [10:14]
        /// 15th conversion in regular
        SQ15: u5 = 0,
        /// SQ16 [15:19]
        /// 16th conversion in regular
        SQ16: u5 = 0,
        /// L [20:23]
        /// Regular channel sequence
        L: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// regular sequence register 1
    pub const SQR1 = Register(SQR1_val).init(base_address + 0x2c);

    /// SQR2
    const SQR2_val = packed struct {
        /// SQ7 [0:4]
        /// 7th conversion in regular
        SQ7: u5 = 0,
        /// SQ8 [5:9]
        /// 8th conversion in regular
        SQ8: u5 = 0,
        /// SQ9 [10:14]
        /// 9th conversion in regular
        SQ9: u5 = 0,
        /// SQ10 [15:19]
        /// 10th conversion in regular
        SQ10: u5 = 0,
        /// SQ11 [20:24]
        /// 11th conversion in regular
        SQ11: u5 = 0,
        /// SQ12 [25:29]
        /// 12th conversion in regular
        SQ12: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 2
    pub const SQR2 = Register(SQR2_val).init(base_address + 0x30);

    /// SQR3
    const SQR3_val = packed struct {
        /// SQ1 [0:4]
        /// 1st conversion in regular
        SQ1: u5 = 0,
        /// SQ2 [5:9]
        /// 2nd conversion in regular
        SQ2: u5 = 0,
        /// SQ3 [10:14]
        /// 3rd conversion in regular
        SQ3: u5 = 0,
        /// SQ4 [15:19]
        /// 4th conversion in regular
        SQ4: u5 = 0,
        /// SQ5 [20:24]
        /// 5th conversion in regular
        SQ5: u5 = 0,
        /// SQ6 [25:29]
        /// 6th conversion in regular
        SQ6: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 3
    pub const SQR3 = Register(SQR3_val).init(base_address + 0x34);

    /// JSQR
    const JSQR_val = packed struct {
        /// JSQ1 [0:4]
        /// 1st conversion in injected
        JSQ1: u5 = 0,
        /// JSQ2 [5:9]
        /// 2nd conversion in injected
        JSQ2: u5 = 0,
        /// JSQ3 [10:14]
        /// 3rd conversion in injected
        JSQ3: u5 = 0,
        /// JSQ4 [15:19]
        /// 4th conversion in injected
        JSQ4: u5 = 0,
        /// JL [20:21]
        /// Injected sequence length
        JL: u2 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// injected sequence register
    pub const JSQR = Register(JSQR_val).init(base_address + 0x38);

    /// JDR1
    const JDR1_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR1 = Register(JDR1_val).init(base_address + 0x3c);

    /// JDR2
    const JDR2_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR2 = Register(JDR2_val).init(base_address + 0x40);

    /// JDR3
    const JDR3_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR3 = Register(JDR3_val).init(base_address + 0x44);

    /// JDR4
    const JDR4_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR4 = Register(JDR4_val).init(base_address + 0x48);

    /// DR
    const DR_val = packed struct {
        /// DATA [0:15]
        /// Regular data
        DATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// regular data register
    pub const DR = Register(DR_val).init(base_address + 0x4c);
};

/// Analog-to-digital converter
pub const ADC2 = struct {
    const base_address = 0x40012100;
    /// SR
    const SR_val = packed struct {
        /// AWD [0:0]
        /// Analog watchdog flag
        AWD: u1 = 0,
        /// EOC [1:1]
        /// Regular channel end of
        EOC: u1 = 0,
        /// JEOC [2:2]
        /// Injected channel end of
        JEOC: u1 = 0,
        /// JSTRT [3:3]
        /// Injected channel start
        JSTRT: u1 = 0,
        /// STRT [4:4]
        /// Regular channel start flag
        STRT: u1 = 0,
        /// OVR [5:5]
        /// Overrun
        OVR: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x0);

    /// CR1
    const CR1_val = packed struct {
        /// AWDCH [0:4]
        /// Analog watchdog channel select
        AWDCH: u5 = 0,
        /// EOCIE [5:5]
        /// Interrupt enable for EOC
        EOCIE: u1 = 0,
        /// AWDIE [6:6]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// JEOCIE [7:7]
        /// Interrupt enable for injected
        JEOCIE: u1 = 0,
        /// SCAN [8:8]
        /// Scan mode
        SCAN: u1 = 0,
        /// AWDSGL [9:9]
        /// Enable the watchdog on a single channel
        AWDSGL: u1 = 0,
        /// JAUTO [10:10]
        /// Automatic injected group
        JAUTO: u1 = 0,
        /// DISCEN [11:11]
        /// Discontinuous mode on regular
        DISCEN: u1 = 0,
        /// JDISCEN [12:12]
        /// Discontinuous mode on injected
        JDISCEN: u1 = 0,
        /// DISCNUM [13:15]
        /// Discontinuous mode channel
        DISCNUM: u3 = 0,
        /// unused [16:21]
        _unused16: u6 = 0,
        /// JAWDEN [22:22]
        /// Analog watchdog enable on injected
        JAWDEN: u1 = 0,
        /// AWDEN [23:23]
        /// Analog watchdog enable on regular
        AWDEN: u1 = 0,
        /// RES [24:25]
        /// Resolution
        RES: u2 = 0,
        /// OVRIE [26:26]
        /// Overrun interrupt enable
        OVRIE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x4);

    /// CR2
    const CR2_val = packed struct {
        /// ADON [0:0]
        /// A/D Converter ON / OFF
        ADON: u1 = 0,
        /// CONT [1:1]
        /// Continuous conversion
        CONT: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// DMA [8:8]
        /// Direct memory access mode (for single
        DMA: u1 = 0,
        /// DDS [9:9]
        /// DMA disable selection (for single ADC
        DDS: u1 = 0,
        /// EOCS [10:10]
        /// End of conversion
        EOCS: u1 = 0,
        /// ALIGN [11:11]
        /// Data alignment
        ALIGN: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// JEXTSEL [16:19]
        /// External event select for injected
        JEXTSEL: u4 = 0,
        /// JEXTEN [20:21]
        /// External trigger enable for injected
        JEXTEN: u2 = 0,
        /// JSWSTART [22:22]
        /// Start conversion of injected
        JSWSTART: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// EXTSEL [24:27]
        /// External event select for regular
        EXTSEL: u4 = 0,
        /// EXTEN [28:29]
        /// External trigger enable for regular
        EXTEN: u2 = 0,
        /// SWSTART [30:30]
        /// Start conversion of regular
        SWSTART: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x8);

    /// SMPR1
    const SMPR1_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 1
    pub const SMPR1 = Register(SMPR1_val).init(base_address + 0xc);

    /// SMPR2
    const SMPR2_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 2
    pub const SMPR2 = Register(SMPR2_val).init(base_address + 0x10);

    /// JOFR1
    const JOFR1_val = packed struct {
        /// JOFFSET1 [0:11]
        /// Data offset for injected channel
        JOFFSET1: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR1 = Register(JOFR1_val).init(base_address + 0x14);

    /// JOFR2
    const JOFR2_val = packed struct {
        /// JOFFSET2 [0:11]
        /// Data offset for injected channel
        JOFFSET2: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR2 = Register(JOFR2_val).init(base_address + 0x18);

    /// JOFR3
    const JOFR3_val = packed struct {
        /// JOFFSET3 [0:11]
        /// Data offset for injected channel
        JOFFSET3: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR3 = Register(JOFR3_val).init(base_address + 0x1c);

    /// JOFR4
    const JOFR4_val = packed struct {
        /// JOFFSET4 [0:11]
        /// Data offset for injected channel
        JOFFSET4: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR4 = Register(JOFR4_val).init(base_address + 0x20);

    /// HTR
    const HTR_val = packed struct {
        /// HT [0:11]
        /// Analog watchdog higher
        HT: u12 = 4095,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog higher threshold
    pub const HTR = Register(HTR_val).init(base_address + 0x24);

    /// LTR
    const LTR_val = packed struct {
        /// LT [0:11]
        /// Analog watchdog lower
        LT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog lower threshold
    pub const LTR = Register(LTR_val).init(base_address + 0x28);

    /// SQR1
    const SQR1_val = packed struct {
        /// SQ13 [0:4]
        /// 13th conversion in regular
        SQ13: u5 = 0,
        /// SQ14 [5:9]
        /// 14th conversion in regular
        SQ14: u5 = 0,
        /// SQ15 [10:14]
        /// 15th conversion in regular
        SQ15: u5 = 0,
        /// SQ16 [15:19]
        /// 16th conversion in regular
        SQ16: u5 = 0,
        /// L [20:23]
        /// Regular channel sequence
        L: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// regular sequence register 1
    pub const SQR1 = Register(SQR1_val).init(base_address + 0x2c);

    /// SQR2
    const SQR2_val = packed struct {
        /// SQ7 [0:4]
        /// 7th conversion in regular
        SQ7: u5 = 0,
        /// SQ8 [5:9]
        /// 8th conversion in regular
        SQ8: u5 = 0,
        /// SQ9 [10:14]
        /// 9th conversion in regular
        SQ9: u5 = 0,
        /// SQ10 [15:19]
        /// 10th conversion in regular
        SQ10: u5 = 0,
        /// SQ11 [20:24]
        /// 11th conversion in regular
        SQ11: u5 = 0,
        /// SQ12 [25:29]
        /// 12th conversion in regular
        SQ12: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 2
    pub const SQR2 = Register(SQR2_val).init(base_address + 0x30);

    /// SQR3
    const SQR3_val = packed struct {
        /// SQ1 [0:4]
        /// 1st conversion in regular
        SQ1: u5 = 0,
        /// SQ2 [5:9]
        /// 2nd conversion in regular
        SQ2: u5 = 0,
        /// SQ3 [10:14]
        /// 3rd conversion in regular
        SQ3: u5 = 0,
        /// SQ4 [15:19]
        /// 4th conversion in regular
        SQ4: u5 = 0,
        /// SQ5 [20:24]
        /// 5th conversion in regular
        SQ5: u5 = 0,
        /// SQ6 [25:29]
        /// 6th conversion in regular
        SQ6: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 3
    pub const SQR3 = Register(SQR3_val).init(base_address + 0x34);

    /// JSQR
    const JSQR_val = packed struct {
        /// JSQ1 [0:4]
        /// 1st conversion in injected
        JSQ1: u5 = 0,
        /// JSQ2 [5:9]
        /// 2nd conversion in injected
        JSQ2: u5 = 0,
        /// JSQ3 [10:14]
        /// 3rd conversion in injected
        JSQ3: u5 = 0,
        /// JSQ4 [15:19]
        /// 4th conversion in injected
        JSQ4: u5 = 0,
        /// JL [20:21]
        /// Injected sequence length
        JL: u2 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// injected sequence register
    pub const JSQR = Register(JSQR_val).init(base_address + 0x38);

    /// JDR1
    const JDR1_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR1 = Register(JDR1_val).init(base_address + 0x3c);

    /// JDR2
    const JDR2_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR2 = Register(JDR2_val).init(base_address + 0x40);

    /// JDR3
    const JDR3_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR3 = Register(JDR3_val).init(base_address + 0x44);

    /// JDR4
    const JDR4_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR4 = Register(JDR4_val).init(base_address + 0x48);

    /// DR
    const DR_val = packed struct {
        /// DATA [0:15]
        /// Regular data
        DATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// regular data register
    pub const DR = Register(DR_val).init(base_address + 0x4c);
};

/// Analog-to-digital converter
pub const ADC3 = struct {
    const base_address = 0x40012200;
    /// SR
    const SR_val = packed struct {
        /// AWD [0:0]
        /// Analog watchdog flag
        AWD: u1 = 0,
        /// EOC [1:1]
        /// Regular channel end of
        EOC: u1 = 0,
        /// JEOC [2:2]
        /// Injected channel end of
        JEOC: u1 = 0,
        /// JSTRT [3:3]
        /// Injected channel start
        JSTRT: u1 = 0,
        /// STRT [4:4]
        /// Regular channel start flag
        STRT: u1 = 0,
        /// OVR [5:5]
        /// Overrun
        OVR: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x0);

    /// CR1
    const CR1_val = packed struct {
        /// AWDCH [0:4]
        /// Analog watchdog channel select
        AWDCH: u5 = 0,
        /// EOCIE [5:5]
        /// Interrupt enable for EOC
        EOCIE: u1 = 0,
        /// AWDIE [6:6]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// JEOCIE [7:7]
        /// Interrupt enable for injected
        JEOCIE: u1 = 0,
        /// SCAN [8:8]
        /// Scan mode
        SCAN: u1 = 0,
        /// AWDSGL [9:9]
        /// Enable the watchdog on a single channel
        AWDSGL: u1 = 0,
        /// JAUTO [10:10]
        /// Automatic injected group
        JAUTO: u1 = 0,
        /// DISCEN [11:11]
        /// Discontinuous mode on regular
        DISCEN: u1 = 0,
        /// JDISCEN [12:12]
        /// Discontinuous mode on injected
        JDISCEN: u1 = 0,
        /// DISCNUM [13:15]
        /// Discontinuous mode channel
        DISCNUM: u3 = 0,
        /// unused [16:21]
        _unused16: u6 = 0,
        /// JAWDEN [22:22]
        /// Analog watchdog enable on injected
        JAWDEN: u1 = 0,
        /// AWDEN [23:23]
        /// Analog watchdog enable on regular
        AWDEN: u1 = 0,
        /// RES [24:25]
        /// Resolution
        RES: u2 = 0,
        /// OVRIE [26:26]
        /// Overrun interrupt enable
        OVRIE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x4);

    /// CR2
    const CR2_val = packed struct {
        /// ADON [0:0]
        /// A/D Converter ON / OFF
        ADON: u1 = 0,
        /// CONT [1:1]
        /// Continuous conversion
        CONT: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// DMA [8:8]
        /// Direct memory access mode (for single
        DMA: u1 = 0,
        /// DDS [9:9]
        /// DMA disable selection (for single ADC
        DDS: u1 = 0,
        /// EOCS [10:10]
        /// End of conversion
        EOCS: u1 = 0,
        /// ALIGN [11:11]
        /// Data alignment
        ALIGN: u1 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// JEXTSEL [16:19]
        /// External event select for injected
        JEXTSEL: u4 = 0,
        /// JEXTEN [20:21]
        /// External trigger enable for injected
        JEXTEN: u2 = 0,
        /// JSWSTART [22:22]
        /// Start conversion of injected
        JSWSTART: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// EXTSEL [24:27]
        /// External event select for regular
        EXTSEL: u4 = 0,
        /// EXTEN [28:29]
        /// External trigger enable for regular
        EXTEN: u2 = 0,
        /// SWSTART [30:30]
        /// Start conversion of regular
        SWSTART: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x8);

    /// SMPR1
    const SMPR1_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 1
    pub const SMPR1 = Register(SMPR1_val).init(base_address + 0xc);

    /// SMPR2
    const SMPR2_val = packed struct {
        /// SMPx_x [0:31]
        /// Sample time bits
        SMPx_x: u32 = 0,
    };
    /// sample time register 2
    pub const SMPR2 = Register(SMPR2_val).init(base_address + 0x10);

    /// JOFR1
    const JOFR1_val = packed struct {
        /// JOFFSET1 [0:11]
        /// Data offset for injected channel
        JOFFSET1: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR1 = Register(JOFR1_val).init(base_address + 0x14);

    /// JOFR2
    const JOFR2_val = packed struct {
        /// JOFFSET2 [0:11]
        /// Data offset for injected channel
        JOFFSET2: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR2 = Register(JOFR2_val).init(base_address + 0x18);

    /// JOFR3
    const JOFR3_val = packed struct {
        /// JOFFSET3 [0:11]
        /// Data offset for injected channel
        JOFFSET3: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR3 = Register(JOFR3_val).init(base_address + 0x1c);

    /// JOFR4
    const JOFR4_val = packed struct {
        /// JOFFSET4 [0:11]
        /// Data offset for injected channel
        JOFFSET4: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected channel data offset register
    pub const JOFR4 = Register(JOFR4_val).init(base_address + 0x20);

    /// HTR
    const HTR_val = packed struct {
        /// HT [0:11]
        /// Analog watchdog higher
        HT: u12 = 4095,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog higher threshold
    pub const HTR = Register(HTR_val).init(base_address + 0x24);

    /// LTR
    const LTR_val = packed struct {
        /// LT [0:11]
        /// Analog watchdog lower
        LT: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// watchdog lower threshold
    pub const LTR = Register(LTR_val).init(base_address + 0x28);

    /// SQR1
    const SQR1_val = packed struct {
        /// SQ13 [0:4]
        /// 13th conversion in regular
        SQ13: u5 = 0,
        /// SQ14 [5:9]
        /// 14th conversion in regular
        SQ14: u5 = 0,
        /// SQ15 [10:14]
        /// 15th conversion in regular
        SQ15: u5 = 0,
        /// SQ16 [15:19]
        /// 16th conversion in regular
        SQ16: u5 = 0,
        /// L [20:23]
        /// Regular channel sequence
        L: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// regular sequence register 1
    pub const SQR1 = Register(SQR1_val).init(base_address + 0x2c);

    /// SQR2
    const SQR2_val = packed struct {
        /// SQ7 [0:4]
        /// 7th conversion in regular
        SQ7: u5 = 0,
        /// SQ8 [5:9]
        /// 8th conversion in regular
        SQ8: u5 = 0,
        /// SQ9 [10:14]
        /// 9th conversion in regular
        SQ9: u5 = 0,
        /// SQ10 [15:19]
        /// 10th conversion in regular
        SQ10: u5 = 0,
        /// SQ11 [20:24]
        /// 11th conversion in regular
        SQ11: u5 = 0,
        /// SQ12 [25:29]
        /// 12th conversion in regular
        SQ12: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 2
    pub const SQR2 = Register(SQR2_val).init(base_address + 0x30);

    /// SQR3
    const SQR3_val = packed struct {
        /// SQ1 [0:4]
        /// 1st conversion in regular
        SQ1: u5 = 0,
        /// SQ2 [5:9]
        /// 2nd conversion in regular
        SQ2: u5 = 0,
        /// SQ3 [10:14]
        /// 3rd conversion in regular
        SQ3: u5 = 0,
        /// SQ4 [15:19]
        /// 4th conversion in regular
        SQ4: u5 = 0,
        /// SQ5 [20:24]
        /// 5th conversion in regular
        SQ5: u5 = 0,
        /// SQ6 [25:29]
        /// 6th conversion in regular
        SQ6: u5 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// regular sequence register 3
    pub const SQR3 = Register(SQR3_val).init(base_address + 0x34);

    /// JSQR
    const JSQR_val = packed struct {
        /// JSQ1 [0:4]
        /// 1st conversion in injected
        JSQ1: u5 = 0,
        /// JSQ2 [5:9]
        /// 2nd conversion in injected
        JSQ2: u5 = 0,
        /// JSQ3 [10:14]
        /// 3rd conversion in injected
        JSQ3: u5 = 0,
        /// JSQ4 [15:19]
        /// 4th conversion in injected
        JSQ4: u5 = 0,
        /// JL [20:21]
        /// Injected sequence length
        JL: u2 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// injected sequence register
    pub const JSQR = Register(JSQR_val).init(base_address + 0x38);

    /// JDR1
    const JDR1_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR1 = Register(JDR1_val).init(base_address + 0x3c);

    /// JDR2
    const JDR2_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR2 = Register(JDR2_val).init(base_address + 0x40);

    /// JDR3
    const JDR3_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR3 = Register(JDR3_val).init(base_address + 0x44);

    /// JDR4
    const JDR4_val = packed struct {
        /// JDATA [0:15]
        /// Injected data
        JDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// injected data register x
    pub const JDR4 = Register(JDR4_val).init(base_address + 0x48);

    /// DR
    const DR_val = packed struct {
        /// DATA [0:15]
        /// Regular data
        DATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// regular data register
    pub const DR = Register(DR_val).init(base_address + 0x4c);
};

/// Digital-to-analog converter
pub const DAC = struct {
    const base_address = 0x40007400;
    /// CR
    const CR_val = packed struct {
        /// EN1 [0:0]
        /// DAC channel1 enable
        EN1: u1 = 0,
        /// BOFF1 [1:1]
        /// DAC channel1 output buffer
        BOFF1: u1 = 0,
        /// TEN1 [2:2]
        /// DAC channel1 trigger
        TEN1: u1 = 0,
        /// TSEL1 [3:5]
        /// DAC channel1 trigger
        TSEL1: u3 = 0,
        /// WAVE1 [6:7]
        /// DAC channel1 noise/triangle wave
        WAVE1: u2 = 0,
        /// MAMP1 [8:11]
        /// DAC channel1 mask/amplitude
        MAMP1: u4 = 0,
        /// DMAEN1 [12:12]
        /// DAC channel1 DMA enable
        DMAEN1: u1 = 0,
        /// DMAUDRIE1 [13:13]
        /// DAC channel1 DMA Underrun Interrupt
        DMAUDRIE1: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// EN2 [16:16]
        /// DAC channel2 enable
        EN2: u1 = 0,
        /// BOFF2 [17:17]
        /// DAC channel2 output buffer
        BOFF2: u1 = 0,
        /// TEN2 [18:18]
        /// DAC channel2 trigger
        TEN2: u1 = 0,
        /// TSEL2 [19:21]
        /// DAC channel2 trigger
        TSEL2: u3 = 0,
        /// WAVE2 [22:23]
        /// DAC channel2 noise/triangle wave
        WAVE2: u2 = 0,
        /// MAMP2 [24:27]
        /// DAC channel2 mask/amplitude
        MAMP2: u4 = 0,
        /// DMAEN2 [28:28]
        /// DAC channel2 DMA enable
        DMAEN2: u1 = 0,
        /// DMAUDRIE2 [29:29]
        /// DAC channel2 DMA underrun interrupt
        DMAUDRIE2: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// SWTRIGR
    const SWTRIGR_val = packed struct {
        /// SWTRIG1 [0:0]
        /// DAC channel1 software
        SWTRIG1: u1 = 0,
        /// SWTRIG2 [1:1]
        /// DAC channel2 software
        SWTRIG2: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// software trigger register
    pub const SWTRIGR = Register(SWTRIGR_val).init(base_address + 0x4);

    /// DHR12R1
    const DHR12R1_val = packed struct {
        /// DACC1DHR [0:11]
        /// DAC channel1 12-bit right-aligned
        DACC1DHR: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel1 12-bit right-aligned data holding
    pub const DHR12R1 = Register(DHR12R1_val).init(base_address + 0x8);

    /// DHR12L1
    const DHR12L1_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// DACC1DHR [4:15]
        /// DAC channel1 12-bit left-aligned
        DACC1DHR: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel1 12-bit left aligned data holding
    pub const DHR12L1 = Register(DHR12L1_val).init(base_address + 0xc);

    /// DHR8R1
    const DHR8R1_val = packed struct {
        /// DACC1DHR [0:7]
        /// DAC channel1 8-bit right-aligned
        DACC1DHR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel1 8-bit right aligned data holding
    pub const DHR8R1 = Register(DHR8R1_val).init(base_address + 0x10);

    /// DHR12R2
    const DHR12R2_val = packed struct {
        /// DACC2DHR [0:11]
        /// DAC channel2 12-bit right-aligned
        DACC2DHR: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel2 12-bit right aligned data holding
    pub const DHR12R2 = Register(DHR12R2_val).init(base_address + 0x14);

    /// DHR12L2
    const DHR12L2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// DACC2DHR [4:15]
        /// DAC channel2 12-bit left-aligned
        DACC2DHR: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel2 12-bit left aligned data holding
    pub const DHR12L2 = Register(DHR12L2_val).init(base_address + 0x18);

    /// DHR8R2
    const DHR8R2_val = packed struct {
        /// DACC2DHR [0:7]
        /// DAC channel2 8-bit right-aligned
        DACC2DHR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel2 8-bit right-aligned data holding
    pub const DHR8R2 = Register(DHR8R2_val).init(base_address + 0x1c);

    /// DHR12RD
    const DHR12RD_val = packed struct {
        /// DACC1DHR [0:11]
        /// DAC channel1 12-bit right-aligned
        DACC1DHR: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// DACC2DHR [16:27]
        /// DAC channel2 12-bit right-aligned
        DACC2DHR: u12 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Dual DAC 12-bit right-aligned data holding
    pub const DHR12RD = Register(DHR12RD_val).init(base_address + 0x20);

    /// DHR12LD
    const DHR12LD_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// DACC1DHR [4:15]
        /// DAC channel1 12-bit left-aligned
        DACC1DHR: u12 = 0,
        /// unused [16:19]
        _unused16: u4 = 0,
        /// DACC2DHR [20:31]
        /// DAC channel2 12-bit left-aligned
        DACC2DHR: u12 = 0,
    };
    /// DUAL DAC 12-bit left aligned data holding
    pub const DHR12LD = Register(DHR12LD_val).init(base_address + 0x24);

    /// DHR8RD
    const DHR8RD_val = packed struct {
        /// DACC1DHR [0:7]
        /// DAC channel1 8-bit right-aligned
        DACC1DHR: u8 = 0,
        /// DACC2DHR [8:15]
        /// DAC channel2 8-bit right-aligned
        DACC2DHR: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DUAL DAC 8-bit right aligned data holding
    pub const DHR8RD = Register(DHR8RD_val).init(base_address + 0x28);

    /// DOR1
    const DOR1_val = packed struct {
        /// DACC1DOR [0:11]
        /// DAC channel1 data output
        DACC1DOR: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel1 data output register
    pub const DOR1 = Register(DOR1_val).init(base_address + 0x2c);

    /// DOR2
    const DOR2_val = packed struct {
        /// DACC2DOR [0:11]
        /// DAC channel2 data output
        DACC2DOR: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// channel2 data output register
    pub const DOR2 = Register(DOR2_val).init(base_address + 0x30);

    /// SR
    const SR_val = packed struct {
        /// unused [0:12]
        _unused0: u8 = 0,
        _unused8: u5 = 0,
        /// DMAUDR1 [13:13]
        /// DAC channel1 DMA underrun
        DMAUDR1: u1 = 0,
        /// unused [14:28]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// DMAUDR2 [29:29]
        /// DAC channel2 DMA underrun
        DMAUDR2: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x34);
};

/// Power control
pub const PWR = struct {
    const base_address = 0x40007000;
    /// CR1
    const CR1_val = packed struct {
        /// LPDS [0:0]
        /// Low-power deep sleep
        LPDS: u1 = 0,
        /// PDDS [1:1]
        /// Power down deepsleep
        PDDS: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CSBF [3:3]
        /// Clear standby flag
        CSBF: u1 = 0,
        /// PVDE [4:4]
        /// Power voltage detector
        PVDE: u1 = 0,
        /// PLS [5:7]
        /// PVD level selection
        PLS: u3 = 0,
        /// DBP [8:8]
        /// Disable backup domain write
        DBP: u1 = 0,
        /// FPDS [9:9]
        /// Flash power down in Stop
        FPDS: u1 = 0,
        /// LPUDS [10:10]
        /// Low-power regulator in deepsleep
        LPUDS: u1 = 0,
        /// MRUDS [11:11]
        /// Main regulator in deepsleep under-drive
        MRUDS: u1 = 0,
        /// unused [12:12]
        _unused12: u1 = 0,
        /// ADCDC1 [13:13]
        /// ADCDC1
        ADCDC1: u1 = 0,
        /// VOS [14:15]
        /// Regulator voltage scaling output
        VOS: u2 = 3,
        /// ODEN [16:16]
        /// Over-drive enable
        ODEN: u1 = 0,
        /// ODSWEN [17:17]
        /// Over-drive switching
        ODSWEN: u1 = 0,
        /// UDEN [18:19]
        /// Under-drive enable in stop
        UDEN: u2 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// power control register
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CSR1
    const CSR1_val = packed struct {
        /// WUIF [0:0]
        /// Wakeup internal flag
        WUIF: u1 = 0,
        /// SBF [1:1]
        /// Standby flag
        SBF: u1 = 0,
        /// PVDO [2:2]
        /// PVD output
        PVDO: u1 = 0,
        /// BRR [3:3]
        /// Backup regulator ready
        BRR: u1 = 0,
        /// unused [4:8]
        _unused4: u4 = 0,
        _unused8: u1 = 0,
        /// BRE [9:9]
        /// Backup regulator enable
        BRE: u1 = 0,
        /// unused [10:13]
        _unused10: u4 = 0,
        /// VOSRDY [14:14]
        /// Regulator voltage scaling output
        VOSRDY: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// ODRDY [16:16]
        /// Over-drive mode ready
        ODRDY: u1 = 0,
        /// ODSWRDY [17:17]
        /// Over-drive mode switching
        ODSWRDY: u1 = 0,
        /// UDRDY [18:19]
        /// Under-drive ready flag
        UDRDY: u2 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// power control/status register
    pub const CSR1 = Register(CSR1_val).init(base_address + 0x4);

    /// CR2
    const CR2_val = packed struct {
        /// CWUPF1 [0:0]
        /// Clear Wakeup Pin flag for
        CWUPF1: u1 = 0,
        /// CWUPF2 [1:1]
        /// Clear Wakeup Pin flag for
        CWUPF2: u1 = 0,
        /// CWUPF3 [2:2]
        /// Clear Wakeup Pin flag for
        CWUPF3: u1 = 0,
        /// CWUPF4 [3:3]
        /// Clear Wakeup Pin flag for
        CWUPF4: u1 = 0,
        /// CWUPF5 [4:4]
        /// Clear Wakeup Pin flag for
        CWUPF5: u1 = 0,
        /// CWUPF6 [5:5]
        /// Clear Wakeup Pin flag for
        CWUPF6: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// WUPP1 [8:8]
        /// Wakeup pin polarity bit for
        WUPP1: u1 = 0,
        /// WUPP2 [9:9]
        /// Wakeup pin polarity bit for
        WUPP2: u1 = 0,
        /// WUPP3 [10:10]
        /// Wakeup pin polarity bit for
        WUPP3: u1 = 0,
        /// WUPP4 [11:11]
        /// Wakeup pin polarity bit for
        WUPP4: u1 = 0,
        /// WUPP5 [12:12]
        /// Wakeup pin polarity bit for
        WUPP5: u1 = 0,
        /// WUPP6 [13:13]
        /// Wakeup pin polarity bit for
        WUPP6: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// power control register
    pub const CR2 = Register(CR2_val).init(base_address + 0x8);

    /// CSR2
    const CSR2_val = packed struct {
        /// WUPF1 [0:0]
        /// Wakeup Pin flag for PA0
        WUPF1: u1 = 0,
        /// WUPF2 [1:1]
        /// Wakeup Pin flag for PA2
        WUPF2: u1 = 0,
        /// WUPF3 [2:2]
        /// Wakeup Pin flag for PC1
        WUPF3: u1 = 0,
        /// WUPF4 [3:3]
        /// Wakeup Pin flag for PC13
        WUPF4: u1 = 0,
        /// WUPF5 [4:4]
        /// Wakeup Pin flag for PI8
        WUPF5: u1 = 0,
        /// WUPF6 [5:5]
        /// Wakeup Pin flag for PI11
        WUPF6: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// EWUP1 [8:8]
        /// Enable Wakeup pin for PA0
        EWUP1: u1 = 0,
        /// EWUP2 [9:9]
        /// Enable Wakeup pin for PA2
        EWUP2: u1 = 0,
        /// EWUP3 [10:10]
        /// Enable Wakeup pin for PC1
        EWUP3: u1 = 0,
        /// EWUP4 [11:11]
        /// Enable Wakeup pin for PC13
        EWUP4: u1 = 0,
        /// EWUP5 [12:12]
        /// Enable Wakeup pin for PI8
        EWUP5: u1 = 0,
        /// EWUP6 [13:13]
        /// Enable Wakeup pin for PI11
        EWUP6: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// power control/status register
    pub const CSR2 = Register(CSR2_val).init(base_address + 0xc);
};

/// Independent watchdog
pub const IWDG = struct {
    const base_address = 0x40003000;
    /// KR
    const KR_val = packed struct {
        /// KEY [0:15]
        /// Key value (write only, read
        KEY: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Key register
    pub const KR = Register(KR_val).init(base_address + 0x0);

    /// PR
    const PR_val = packed struct {
        /// PR [0:2]
        /// Prescaler divider
        PR: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Prescaler register
    pub const PR = Register(PR_val).init(base_address + 0x4);

    /// RLR
    const RLR_val = packed struct {
        /// RL [0:11]
        /// Watchdog counter reload
        RL: u12 = 4095,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Reload register
    pub const RLR = Register(RLR_val).init(base_address + 0x8);

    /// SR
    const SR_val = packed struct {
        /// PVU [0:0]
        /// Watchdog prescaler value
        PVU: u1 = 0,
        /// RVU [1:1]
        /// Watchdog counter reload value
        RVU: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register
    pub const SR = Register(SR_val).init(base_address + 0xc);

    /// WINR
    const WINR_val = packed struct {
        /// WIN [0:11]
        /// Watchdog counter window
        WIN: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Window register
    pub const WINR = Register(WINR_val).init(base_address + 0x10);
};

/// Window watchdog
pub const WWDG = struct {
    const base_address = 0x40002c00;
    /// CR
    const CR_val = packed struct {
        /// T [0:6]
        /// 7-bit counter (MSB to LSB)
        T: u7 = 127,
        /// WDGA [7:7]
        /// Activation bit
        WDGA: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// CFR
    const CFR_val = packed struct {
        /// W [0:6]
        /// 7-bit window value
        W: u7 = 127,
        /// WDGTB0 [7:7]
        /// Timer base
        WDGTB0: u1 = 0,
        /// WDGTB1 [8:8]
        /// Timer base
        WDGTB1: u1 = 0,
        /// EWI [9:9]
        /// Early wakeup interrupt
        EWI: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Configuration register
    pub const CFR = Register(CFR_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// EWIF [0:0]
        /// Early wakeup interrupt
        EWIF: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Status register
    pub const SR = Register(SR_val).init(base_address + 0x8);
};

/// Advanced-timers
pub const TIM1 = struct {
    const base_address = 0x40010000;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// CCPC [0:0]
        /// Capture/compare preloaded
        CCPC: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CCUS [2:2]
        /// Capture/compare control update
        CCUS: u1 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// OIS1 [8:8]
        /// Output Idle state 1
        OIS1: u1 = 0,
        /// OIS1N [9:9]
        /// Output Idle state 1
        OIS1N: u1 = 0,
        /// OIS2 [10:10]
        /// Output Idle state 2
        OIS2: u1 = 0,
        /// OIS2N [11:11]
        /// Output Idle state 2
        OIS2N: u1 = 0,
        /// OIS3 [12:12]
        /// Output Idle state 3
        OIS3: u1 = 0,
        /// OIS3N [13:13]
        /// Output Idle state 3
        OIS3N: u1 = 0,
        /// OIS4 [14:14]
        /// Output Idle state 4
        OIS4: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// COMIE [5:5]
        /// COM interrupt enable
        COMIE: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// BIE [7:7]
        /// Break interrupt enable
        BIE: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// COMDE [13:13]
        /// COM DMA request enable
        COMDE: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// COMIF [5:5]
        /// COM interrupt flag
        COMIF: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// BIF [7:7]
        /// Break interrupt flag
        BIF: u1 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// COMG [5:5]
        /// Capture/Compare control update
        COMG: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// BG [7:7]
        /// Break generation
        BG: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// Output Compare 1 clear
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// Output Compare 2 fast
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// Output Compare 2 preload
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// Output Compare 2 mode
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// Output Compare 2 clear
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// Capture/Compare 3
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// Output compare 3 fast
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// Output compare 3 preload
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// Output compare 3 mode
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// Output compare 3 clear
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// Output compare 4 fast
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// Output compare 4 preload
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// Output compare 4 mode
        OC4M: u3 = 0,
        /// OC4CE [15:15]
        /// Output compare 4 clear
        OC4CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// CC1NE [2:2]
        /// Capture/Compare 1 complementary output
        CC1NE: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// CC2NE [6:6]
        /// Capture/Compare 2 complementary output
        CC2NE: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// CC3NE [10:10]
        /// Capture/Compare 3 complementary output
        CC3NE: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2 [0:15]
        /// Capture/Compare 2 value
        CCR2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3 [0:15]
        /// Capture/Compare value
        CCR3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4 [0:15]
        /// Capture/Compare value
        CCR4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);

    /// RCR
    const RCR_val = packed struct {
        /// REP [0:7]
        /// Repetition counter value
        REP: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// repetition counter register
    pub const RCR = Register(RCR_val).init(base_address + 0x30);

    /// BDTR
    const BDTR_val = packed struct {
        /// DTG [0:7]
        /// Dead-time generator setup
        DTG: u8 = 0,
        /// LOCK [8:9]
        /// Lock configuration
        LOCK: u2 = 0,
        /// OSSI [10:10]
        /// Off-state selection for Idle
        OSSI: u1 = 0,
        /// OSSR [11:11]
        /// Off-state selection for Run
        OSSR: u1 = 0,
        /// BKE [12:12]
        /// Break enable
        BKE: u1 = 0,
        /// BKP [13:13]
        /// Break polarity
        BKP: u1 = 0,
        /// AOE [14:14]
        /// Automatic output enable
        AOE: u1 = 0,
        /// MOE [15:15]
        /// Main output enable
        MOE: u1 = 0,
        /// BKF [16:19]
        /// Break filter
        BKF: u4 = 0,
        /// BK2F [20:23]
        /// Break 2 filter
        BK2F: u4 = 0,
        /// BK2E [24:24]
        /// Break 2 enable
        BK2E: u1 = 0,
        /// BK2P [25:25]
        /// Break 2 polarity
        BK2P: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// break and dead-time register
    pub const BDTR = Register(BDTR_val).init(base_address + 0x44);

    /// CCMR3_Output
    const CCMR3_Output_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// OC5FE [2:2]
        /// Output compare 5 fast
        OC5FE: u1 = 0,
        /// OC5PE [3:3]
        /// Output compare 5 preload
        OC5PE: u1 = 0,
        /// OC5M [4:6]
        /// Output compare 5 mode
        OC5M: u3 = 0,
        /// OC5CE [7:7]
        /// Output compare 5 clear
        OC5CE: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// OC6FE [10:10]
        /// Output compare 6 fast
        OC6FE: u1 = 0,
        /// OC6PE [11:11]
        /// Output compare 6 preload
        OC6PE: u1 = 0,
        /// OC6M [12:14]
        /// Output compare 6 mode
        OC6M: u3 = 0,
        /// OC6CE [15:15]
        /// Output compare 6 clear
        OC6CE: u1 = 0,
        /// OC5M3 [16:16]
        /// Output Compare 5 mode
        OC5M3: u1 = 0,
        /// unused [17:23]
        _unused17: u7 = 0,
        /// OC6M3 [24:24]
        /// Output Compare 6 mode
        OC6M3: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// capture/compare mode register 3 (output
    pub const CCMR3_Output = Register(CCMR3_Output_val).init(base_address + 0x54);

    /// CCR5
    const CCR5_val = packed struct {
        /// CCR5 [0:15]
        /// Capture/Compare 5 value
        CCR5: u16 = 0,
        /// unused [16:28]
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// GC5C1 [29:29]
        /// Group Channel 5 and Channel
        GC5C1: u1 = 0,
        /// GC5C2 [30:30]
        /// Group Channel 5 and Channel
        GC5C2: u1 = 0,
        /// GC5C3 [31:31]
        /// Group Channel 5 and Channel
        GC5C3: u1 = 0,
    };
    /// capture/compare register 5
    pub const CCR5 = Register(CCR5_val).init(base_address + 0x58);

    /// CRR6
    const CRR6_val = packed struct {
        /// CCR6 [0:15]
        /// Capture/Compare 6 value
        CCR6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 6
    pub const CRR6 = Register(CRR6_val).init(base_address + 0x5c);

    /// AF1
    const AF1_val = packed struct {
        /// BKINE [0:0]
        /// BRK BKIN input enable
        BKINE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// BKDFBKE [8:8]
        /// BRK DFSDM_BREAK[0] enable
        BKDFBKE: u1 = 0,
        /// BKINP [9:9]
        /// BRK BKIN input polarity
        BKINP: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// alternate function option register
    pub const AF1 = Register(AF1_val).init(base_address + 0x60);

    /// AF2
    const AF2_val = packed struct {
        /// BK2INE [0:0]
        /// BRK2 BKIN input enable
        BK2INE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// BK2DFBKE [8:8]
        /// BRK2 DFSDM_BREAK enable
        BK2DFBKE: u1 = 0,
        /// BK2INP [9:9]
        /// BRK2 BKIN2 input polarity
        BK2INP: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// alternate function option register
    pub const AF2 = Register(AF2_val).init(base_address + 0x64);
};

/// Advanced-timers
pub const TIM8 = struct {
    const base_address = 0x40010400;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// CCPC [0:0]
        /// Capture/compare preloaded
        CCPC: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// CCUS [2:2]
        /// Capture/compare control update
        CCUS: u1 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// OIS1 [8:8]
        /// Output Idle state 1
        OIS1: u1 = 0,
        /// OIS1N [9:9]
        /// Output Idle state 1
        OIS1N: u1 = 0,
        /// OIS2 [10:10]
        /// Output Idle state 2
        OIS2: u1 = 0,
        /// OIS2N [11:11]
        /// Output Idle state 2
        OIS2N: u1 = 0,
        /// OIS3 [12:12]
        /// Output Idle state 3
        OIS3: u1 = 0,
        /// OIS3N [13:13]
        /// Output Idle state 3
        OIS3N: u1 = 0,
        /// OIS4 [14:14]
        /// Output Idle state 4
        OIS4: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// COMIE [5:5]
        /// COM interrupt enable
        COMIE: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// BIE [7:7]
        /// Break interrupt enable
        BIE: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// COMDE [13:13]
        /// COM DMA request enable
        COMDE: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// COMIF [5:5]
        /// COM interrupt flag
        COMIF: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// BIF [7:7]
        /// Break interrupt flag
        BIF: u1 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// COMG [5:5]
        /// Capture/Compare control update
        COMG: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// BG [7:7]
        /// Break generation
        BG: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// Output Compare 1 clear
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// Output Compare 2 fast
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// Output Compare 2 preload
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// Output Compare 2 mode
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// Output Compare 2 clear
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// Capture/Compare 3
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// Output compare 3 fast
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// Output compare 3 preload
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// Output compare 3 mode
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// Output compare 3 clear
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// Output compare 4 fast
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// Output compare 4 preload
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// Output compare 4 mode
        OC4M: u3 = 0,
        /// OC4CE [15:15]
        /// Output compare 4 clear
        OC4CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// CC1NE [2:2]
        /// Capture/Compare 1 complementary output
        CC1NE: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// CC2NE [6:6]
        /// Capture/Compare 2 complementary output
        CC2NE: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// CC3NE [10:10]
        /// Capture/Compare 3 complementary output
        CC3NE: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2 [0:15]
        /// Capture/Compare 2 value
        CCR2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3 [0:15]
        /// Capture/Compare value
        CCR3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4 [0:15]
        /// Capture/Compare value
        CCR4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);

    /// RCR
    const RCR_val = packed struct {
        /// REP [0:7]
        /// Repetition counter value
        REP: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// repetition counter register
    pub const RCR = Register(RCR_val).init(base_address + 0x30);

    /// BDTR
    const BDTR_val = packed struct {
        /// DTG [0:7]
        /// Dead-time generator setup
        DTG: u8 = 0,
        /// LOCK [8:9]
        /// Lock configuration
        LOCK: u2 = 0,
        /// OSSI [10:10]
        /// Off-state selection for Idle
        OSSI: u1 = 0,
        /// OSSR [11:11]
        /// Off-state selection for Run
        OSSR: u1 = 0,
        /// BKE [12:12]
        /// Break enable
        BKE: u1 = 0,
        /// BKP [13:13]
        /// Break polarity
        BKP: u1 = 0,
        /// AOE [14:14]
        /// Automatic output enable
        AOE: u1 = 0,
        /// MOE [15:15]
        /// Main output enable
        MOE: u1 = 0,
        /// BKF [16:19]
        /// Break filter
        BKF: u4 = 0,
        /// BK2F [20:23]
        /// Break 2 filter
        BK2F: u4 = 0,
        /// BK2E [24:24]
        /// Break 2 enable
        BK2E: u1 = 0,
        /// BK2P [25:25]
        /// Break 2 polarity
        BK2P: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// break and dead-time register
    pub const BDTR = Register(BDTR_val).init(base_address + 0x44);

    /// CCMR3_Output
    const CCMR3_Output_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// OC5FE [2:2]
        /// Output compare 5 fast
        OC5FE: u1 = 0,
        /// OC5PE [3:3]
        /// Output compare 5 preload
        OC5PE: u1 = 0,
        /// OC5M [4:6]
        /// Output compare 5 mode
        OC5M: u3 = 0,
        /// OC5CE [7:7]
        /// Output compare 5 clear
        OC5CE: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// OC6FE [10:10]
        /// Output compare 6 fast
        OC6FE: u1 = 0,
        /// OC6PE [11:11]
        /// Output compare 6 preload
        OC6PE: u1 = 0,
        /// OC6M [12:14]
        /// Output compare 6 mode
        OC6M: u3 = 0,
        /// OC6CE [15:15]
        /// Output compare 6 clear
        OC6CE: u1 = 0,
        /// OC5M3 [16:16]
        /// Output Compare 5 mode
        OC5M3: u1 = 0,
        /// unused [17:23]
        _unused17: u7 = 0,
        /// OC6M3 [24:24]
        /// Output Compare 6 mode
        OC6M3: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// capture/compare mode register 3 (output
    pub const CCMR3_Output = Register(CCMR3_Output_val).init(base_address + 0x54);

    /// CCR5
    const CCR5_val = packed struct {
        /// CCR5 [0:15]
        /// Capture/Compare 5 value
        CCR5: u16 = 0,
        /// unused [16:28]
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// GC5C1 [29:29]
        /// Group Channel 5 and Channel
        GC5C1: u1 = 0,
        /// GC5C2 [30:30]
        /// Group Channel 5 and Channel
        GC5C2: u1 = 0,
        /// GC5C3 [31:31]
        /// Group Channel 5 and Channel
        GC5C3: u1 = 0,
    };
    /// capture/compare register 5
    pub const CCR5 = Register(CCR5_val).init(base_address + 0x58);

    /// CRR6
    const CRR6_val = packed struct {
        /// CCR6 [0:15]
        /// Capture/Compare 6 value
        CCR6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 6
    pub const CRR6 = Register(CRR6_val).init(base_address + 0x5c);

    /// AF1
    const AF1_val = packed struct {
        /// BKINE [0:0]
        /// BRK BKIN input enable
        BKINE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// BKDFBKE [8:8]
        /// BRK DFSDM_BREAK[0] enable
        BKDFBKE: u1 = 0,
        /// BKINP [9:9]
        /// BRK BKIN input polarity
        BKINP: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// alternate function option register
    pub const AF1 = Register(AF1_val).init(base_address + 0x60);

    /// AF2
    const AF2_val = packed struct {
        /// BK2INE [0:0]
        /// BRK2 BKIN input enable
        BK2INE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// BK2DFBKE [8:8]
        /// BRK2 DFSDM_BREAK enable
        BK2DFBKE: u1 = 0,
        /// BK2INP [9:9]
        /// BRK2 BKIN2 input polarity
        BK2INP: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// alternate function option register
    pub const AF2 = Register(AF2_val).init(base_address + 0x64);
};

/// General purpose timers
pub const TIM2 = struct {
    const base_address = 0x40000000;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// CC1S
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// OC1FE
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// OC1PE
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// OC1M
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// OC1CE
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// CC2S
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// OC2FE
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// OC2PE
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// OC2M
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// OC2CE
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// CC3S
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// OC3FE
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// OC3PE
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// OC3M
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// OC3CE
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// CC4S
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// OC4FE
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// OC4PE
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// OC4M
        OC4M: u3 = 0,
        /// O24CE [15:15]
        /// O24CE
        O24CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// CC4NP [15:15]
        /// Capture/Compare 4 output
        CC4NP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT_L [0:15]
        /// Low counter value
        CNT_L: u16 = 0,
        /// CNT_H [16:31]
        /// High counter value
        CNT_H: u16 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR_L [0:15]
        /// Low Auto-reload value
        ARR_L: u16 = 0,
        /// ARR_H [16:31]
        /// High Auto-reload value
        ARR_H: u16 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1_L [0:15]
        /// Low Capture/Compare 1
        CCR1_L: u16 = 0,
        /// CCR1_H [16:31]
        /// High Capture/Compare 1
        CCR1_H: u16 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2_L [0:15]
        /// Low Capture/Compare 2
        CCR2_L: u16 = 0,
        /// CCR2_H [16:31]
        /// High Capture/Compare 2
        CCR2_H: u16 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3_L [0:15]
        /// Low Capture/Compare value
        CCR3_L: u16 = 0,
        /// CCR3_H [16:31]
        /// High Capture/Compare value
        CCR3_H: u16 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4_L [0:15]
        /// Low Capture/Compare value
        CCR4_L: u16 = 0,
        /// CCR4_H [16:31]
        /// High Capture/Compare value
        CCR4_H: u16 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);

    /// OR1
    const OR1_val = packed struct {
        /// ITR1_RMP [0:0]
        /// Internal trigger 1 remap
        ITR1_RMP: u1 = 0,
        /// ETR1_RMP [1:1]
        /// External trigger remap
        ETR1_RMP: u1 = 0,
        /// TI4_RMP [2:3]
        /// Input Capture 4 remap
        TI4_RMP: u2 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TIM2 option register 1
    pub const OR1 = Register(OR1_val).init(base_address + 0x50);

    /// OR2
    const OR2_val = packed struct {
        /// unused [0:13]
        _unused0: u8 = 0,
        _unused8: u6 = 0,
        /// ETRSEL [14:16]
        /// ETR source selection
        ETRSEL: u3 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// TIM2 option register 2
    pub const OR2 = Register(OR2_val).init(base_address + 0x60);
};

/// General purpose timers
pub const TIM3 = struct {
    const base_address = 0x40000400;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// CC1S
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// OC1FE
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// OC1PE
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// OC1M
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// OC1CE
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// CC2S
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// OC2FE
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// OC2PE
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// OC2M
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// OC2CE
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// CC3S
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// OC3FE
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// OC3PE
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// OC3M
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// OC3CE
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// CC4S
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// OC4FE
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// OC4PE
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// OC4M
        OC4M: u3 = 0,
        /// O24CE [15:15]
        /// O24CE
        O24CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// CC4NP [15:15]
        /// Capture/Compare 4 output
        CC4NP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT_L [0:15]
        /// Low counter value
        CNT_L: u16 = 0,
        /// CNT_H [16:31]
        /// High counter value
        CNT_H: u16 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR_L [0:15]
        /// Low Auto-reload value
        ARR_L: u16 = 0,
        /// ARR_H [16:31]
        /// High Auto-reload value
        ARR_H: u16 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1_L [0:15]
        /// Low Capture/Compare 1
        CCR1_L: u16 = 0,
        /// CCR1_H [16:31]
        /// High Capture/Compare 1
        CCR1_H: u16 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2_L [0:15]
        /// Low Capture/Compare 2
        CCR2_L: u16 = 0,
        /// CCR2_H [16:31]
        /// High Capture/Compare 2
        CCR2_H: u16 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3_L [0:15]
        /// Low Capture/Compare value
        CCR3_L: u16 = 0,
        /// CCR3_H [16:31]
        /// High Capture/Compare value
        CCR3_H: u16 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4_L [0:15]
        /// Low Capture/Compare value
        CCR4_L: u16 = 0,
        /// CCR4_H [16:31]
        /// High Capture/Compare value
        CCR4_H: u16 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);

    /// OR1
    const OR1_val = packed struct {
        /// TI1_RMP [0:1]
        /// Input Capture 1 remap
        TI1_RMP: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// TIM3 option register 1
    pub const OR1 = Register(OR1_val).init(base_address + 0x50);

    /// OR2
    const OR2_val = packed struct {
        /// unused [0:13]
        _unused0: u8 = 0,
        _unused8: u6 = 0,
        /// ETRSEL [14:16]
        /// ETR source selection
        ETRSEL: u3 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// TIM3 option register 2
    pub const OR2 = Register(OR2_val).init(base_address + 0x60);
};

/// General purpose timers
pub const TIM4 = struct {
    const base_address = 0x40000800;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// CC1S
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// OC1FE
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// OC1PE
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// OC1M
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// OC1CE
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// CC2S
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// OC2FE
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// OC2PE
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// OC2M
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// OC2CE
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// CC3S
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// OC3FE
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// OC3PE
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// OC3M
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// OC3CE
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// CC4S
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// OC4FE
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// OC4PE
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// OC4M
        OC4M: u3 = 0,
        /// O24CE [15:15]
        /// O24CE
        O24CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// CC4NP [15:15]
        /// Capture/Compare 4 output
        CC4NP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT_L [0:15]
        /// Low counter value
        CNT_L: u16 = 0,
        /// CNT_H [16:31]
        /// High counter value
        CNT_H: u16 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR_L [0:15]
        /// Low Auto-reload value
        ARR_L: u16 = 0,
        /// ARR_H [16:31]
        /// High Auto-reload value
        ARR_H: u16 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1_L [0:15]
        /// Low Capture/Compare 1
        CCR1_L: u16 = 0,
        /// CCR1_H [16:31]
        /// High Capture/Compare 1
        CCR1_H: u16 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2_L [0:15]
        /// Low Capture/Compare 2
        CCR2_L: u16 = 0,
        /// CCR2_H [16:31]
        /// High Capture/Compare 2
        CCR2_H: u16 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3_L [0:15]
        /// Low Capture/Compare value
        CCR3_L: u16 = 0,
        /// CCR3_H [16:31]
        /// High Capture/Compare value
        CCR3_H: u16 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4_L [0:15]
        /// Low Capture/Compare value
        CCR4_L: u16 = 0,
        /// CCR4_H [16:31]
        /// High Capture/Compare value
        CCR4_H: u16 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);
};

/// General purpose timers
pub const TIM5 = struct {
    const base_address = 0x40000c00;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// DIR [4:4]
        /// Direction
        DIR: u1 = 0,
        /// CMS [5:6]
        /// Center-aligned mode
        CMS: u2 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// CCDS [3:3]
        /// Capture/compare DMA
        CCDS: u1 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// TI1S [7:7]
        /// TI1 selection
        TI1S: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// CC3IE [3:3]
        /// Capture/Compare 3 interrupt
        CC3IE: u1 = 0,
        /// CC4IE [4:4]
        /// Capture/Compare 4 interrupt
        CC4IE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// CC1DE [9:9]
        /// Capture/Compare 1 DMA request
        CC1DE: u1 = 0,
        /// CC2DE [10:10]
        /// Capture/Compare 2 DMA request
        CC2DE: u1 = 0,
        /// CC3DE [11:11]
        /// Capture/Compare 3 DMA request
        CC3DE: u1 = 0,
        /// CC4DE [12:12]
        /// Capture/Compare 4 DMA request
        CC4DE: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TDE [14:14]
        /// Trigger DMA request enable
        TDE: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// CC3IF [3:3]
        /// Capture/Compare 3 interrupt
        CC3IF: u1 = 0,
        /// CC4IF [4:4]
        /// Capture/Compare 4 interrupt
        CC4IF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// CC3OF [11:11]
        /// Capture/Compare 3 overcapture
        CC3OF: u1 = 0,
        /// CC4OF [12:12]
        /// Capture/Compare 4 overcapture
        CC4OF: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// CC3G [3:3]
        /// Capture/compare 3
        CC3G: u1 = 0,
        /// CC4G [4:4]
        /// Capture/compare 4
        CC4G: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// CC1S
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// OC1FE
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// OC1PE
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// OC1M
        OC1M: u3 = 0,
        /// OC1CE [7:7]
        /// OC1CE
        OC1CE: u1 = 0,
        /// CC2S [8:9]
        /// CC2S
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// OC2FE
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// OC2PE
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// OC2M
        OC2M: u3 = 0,
        /// OC2CE [15:15]
        /// OC2CE
        OC2CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:15]
        /// Input capture 2 filter
        IC2F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCMR2_Output
    const CCMR2_Output_val = packed struct {
        /// CC3S [0:1]
        /// CC3S
        CC3S: u2 = 0,
        /// OC3FE [2:2]
        /// OC3FE
        OC3FE: u1 = 0,
        /// OC3PE [3:3]
        /// OC3PE
        OC3PE: u1 = 0,
        /// OC3M [4:6]
        /// OC3M
        OC3M: u3 = 0,
        /// OC3CE [7:7]
        /// OC3CE
        OC3CE: u1 = 0,
        /// CC4S [8:9]
        /// CC4S
        CC4S: u2 = 0,
        /// OC4FE [10:10]
        /// OC4FE
        OC4FE: u1 = 0,
        /// OC4PE [11:11]
        /// OC4PE
        OC4PE: u1 = 0,
        /// OC4M [12:14]
        /// OC4M
        OC4M: u3 = 0,
        /// O24CE [15:15]
        /// O24CE
        O24CE: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (output
    pub const CCMR2_Output = Register(CCMR2_Output_val).init(base_address + 0x1c);

    /// CCMR2_Input
    const CCMR2_Input_val = packed struct {
        /// CC3S [0:1]
        /// Capture/compare 3
        CC3S: u2 = 0,
        /// IC3PSC [2:3]
        /// Input capture 3 prescaler
        IC3PSC: u2 = 0,
        /// IC3F [4:7]
        /// Input capture 3 filter
        IC3F: u4 = 0,
        /// CC4S [8:9]
        /// Capture/Compare 4
        CC4S: u2 = 0,
        /// IC4PSC [10:11]
        /// Input capture 4 prescaler
        IC4PSC: u2 = 0,
        /// IC4F [12:15]
        /// Input capture 4 filter
        IC4F: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 2 (input
    pub const CCMR2_Input = Register(CCMR2_Input_val).init(base_address + 0x1c);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// CC3E [8:8]
        /// Capture/Compare 3 output
        CC3E: u1 = 0,
        /// CC3P [9:9]
        /// Capture/Compare 3 output
        CC3P: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// CC3NP [11:11]
        /// Capture/Compare 3 output
        CC3NP: u1 = 0,
        /// CC4E [12:12]
        /// Capture/Compare 4 output
        CC4E: u1 = 0,
        /// CC4P [13:13]
        /// Capture/Compare 3 output
        CC4P: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// CC4NP [15:15]
        /// Capture/Compare 4 output
        CC4NP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT_L [0:15]
        /// Low counter value
        CNT_L: u16 = 0,
        /// CNT_H [16:31]
        /// High counter value
        CNT_H: u16 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR_L [0:15]
        /// Low Auto-reload value
        ARR_L: u16 = 0,
        /// ARR_H [16:31]
        /// High Auto-reload value
        ARR_H: u16 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1_L [0:15]
        /// Low Capture/Compare 1
        CCR1_L: u16 = 0,
        /// CCR1_H [16:31]
        /// High Capture/Compare 1
        CCR1_H: u16 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2_L [0:15]
        /// Low Capture/Compare 2
        CCR2_L: u16 = 0,
        /// CCR2_H [16:31]
        /// High Capture/Compare 2
        CCR2_H: u16 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);

    /// CCR3
    const CCR3_val = packed struct {
        /// CCR3_L [0:15]
        /// Low Capture/Compare value
        CCR3_L: u16 = 0,
        /// CCR3_H [16:31]
        /// High Capture/Compare value
        CCR3_H: u16 = 0,
    };
    /// capture/compare register 3
    pub const CCR3 = Register(CCR3_val).init(base_address + 0x3c);

    /// CCR4
    const CCR4_val = packed struct {
        /// CCR4_L [0:15]
        /// Low Capture/Compare value
        CCR4_L: u16 = 0,
        /// CCR4_H [16:31]
        /// High Capture/Compare value
        CCR4_H: u16 = 0,
    };
    /// capture/compare register 4
    pub const CCR4 = Register(CCR4_val).init(base_address + 0x40);

    /// DCR
    const DCR_val = packed struct {
        /// DBA [0:4]
        /// DMA base address
        DBA: u5 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// DBL [8:12]
        /// DMA burst length
        DBL: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA control register
    pub const DCR = Register(DCR_val).init(base_address + 0x48);

    /// DMAR
    const DMAR_val = packed struct {
        /// DMAB [0:15]
        /// DMA register for burst
        DMAB: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA address for full transfer
    pub const DMAR = Register(DMAR_val).init(base_address + 0x4c);
};

/// General purpose timers
pub const TIM9 = struct {
    const base_address = 0x40014000;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// Output Compare 2 fast
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// Output Compare 2 preload
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// Output Compare 2 mode
        OC2M: u3 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:6]
        /// Input capture 1 filter
        IC1F: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:14]
        /// Input capture 2 filter
        IC2F: u3 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2 [0:15]
        /// Capture/Compare 2 value
        CCR2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);
};

/// General purpose timers
pub const TIM12 = struct {
    const base_address = 0x40001800;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/Slave mode
        MSM: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// CC2IE [2:2]
        /// Capture/Compare 2 interrupt
        CC2IE: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TIE [6:6]
        /// Trigger interrupt enable
        TIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// CC2IF [2:2]
        /// Capture/Compare 2 interrupt
        CC2IF: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TIF [6:6]
        /// Trigger interrupt flag
        TIF: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// CC2OF [10:10]
        /// Capture/compare 2 overcapture
        CC2OF: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// CC2G [2:2]
        /// Capture/compare 2
        CC2G: u1 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// TG [6:6]
        /// Trigger generation
        TG: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// OC2FE [10:10]
        /// Output Compare 2 fast
        OC2FE: u1 = 0,
        /// OC2PE [11:11]
        /// Output Compare 2 preload
        OC2PE: u1 = 0,
        /// OC2M [12:14]
        /// Output Compare 2 mode
        OC2M: u3 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:6]
        /// Input capture 1 filter
        IC1F: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// CC2S [8:9]
        /// Capture/Compare 2
        CC2S: u2 = 0,
        /// IC2PCS [10:11]
        /// Input capture 2 prescaler
        IC2PCS: u2 = 0,
        /// IC2F [12:14]
        /// Input capture 2 filter
        IC2F: u3 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// CC2E [4:4]
        /// Capture/Compare 2 output
        CC2E: u1 = 0,
        /// CC2P [5:5]
        /// Capture/Compare 2 output
        CC2P: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// CC2NP [7:7]
        /// Capture/Compare 2 output
        CC2NP: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// CCR2
    const CCR2_val = packed struct {
        /// CCR2 [0:15]
        /// Capture/Compare 2 value
        CCR2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 2
    pub const CCR2 = Register(CCR2_val).init(base_address + 0x38);
};

/// General-purpose-timers
pub const TIM10 = struct {
    const base_address = 0x40014400;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// SMS3 [16:16]
        /// Slave mode selection
        SMS3: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// OR
    const OR_val = packed struct {
        /// TI1_RMP [0:1]
        /// TIM11 Input 1 remapping
        TI1_RMP: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// option register
    pub const OR = Register(OR_val).init(base_address + 0x50);
};

/// General-purpose-timers
pub const TIM11 = struct {
    const base_address = 0x40014800;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// SMS3 [16:16]
        /// Slave mode selection
        SMS3: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// OR
    const OR_val = packed struct {
        /// TI1_RMP [0:1]
        /// TIM11 Input 1 remapping
        TI1_RMP: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// option register
    pub const OR = Register(OR_val).init(base_address + 0x50);
};

/// General-purpose-timers
pub const TIM13 = struct {
    const base_address = 0x40001c00;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// SMS3 [16:16]
        /// Slave mode selection
        SMS3: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// OR
    const OR_val = packed struct {
        /// TI1_RMP [0:1]
        /// TIM11 Input 1 remapping
        TI1_RMP: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// option register
    pub const OR = Register(OR_val).init(base_address + 0x50);
};

/// General-purpose-timers
pub const TIM14 = struct {
    const base_address = 0x40002000;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// unused [3:6]
        _unused3: u4 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// CKD [8:9]
        /// Clock division
        CKD: u2 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// CC1IE [1:1]
        /// Capture/Compare 1 interrupt
        CC1IE: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// CC1IF [1:1]
        /// Capture/compare 1 interrupt
        CC1IF: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// CC1OF [9:9]
        /// Capture/Compare 1 overcapture
        CC1OF: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// CC1G [1:1]
        /// Capture/compare 1
        CC1G: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CCMR1_Output
    const CCMR1_Output_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// OC1FE [2:2]
        /// Output Compare 1 fast
        OC1FE: u1 = 0,
        /// OC1PE [3:3]
        /// Output Compare 1 preload
        OC1PE: u1 = 0,
        /// OC1M [4:6]
        /// Output Compare 1 mode
        OC1M: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (output
    pub const CCMR1_Output = Register(CCMR1_Output_val).init(base_address + 0x18);

    /// CCMR1_Input
    const CCMR1_Input_val = packed struct {
        /// CC1S [0:1]
        /// Capture/Compare 1
        CC1S: u2 = 0,
        /// ICPCS [2:3]
        /// Input capture 1 prescaler
        ICPCS: u2 = 0,
        /// IC1F [4:7]
        /// Input capture 1 filter
        IC1F: u4 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare mode register 1 (input
    pub const CCMR1_Input = Register(CCMR1_Input_val).init(base_address + 0x18);

    /// CCER
    const CCER_val = packed struct {
        /// CC1E [0:0]
        /// Capture/Compare 1 output
        CC1E: u1 = 0,
        /// CC1P [1:1]
        /// Capture/Compare 1 output
        CC1P: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CC1NP [3:3]
        /// Capture/Compare 1 output
        CC1NP: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare enable
    pub const CCER = Register(CCER_val).init(base_address + 0x20);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);

    /// CCR1
    const CCR1_val = packed struct {
        /// CCR1 [0:15]
        /// Capture/Compare 1 value
        CCR1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// capture/compare register 1
    pub const CCR1 = Register(CCR1_val).init(base_address + 0x34);

    /// SMCR
    const SMCR_val = packed struct {
        /// SMS [0:2]
        /// Slave mode selection
        SMS: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// TS [4:6]
        /// Trigger selection
        TS: u3 = 0,
        /// MSM [7:7]
        /// Master/slave mode
        MSM: u1 = 0,
        /// ETF [8:11]
        /// External trigger filter
        ETF: u4 = 0,
        /// ETPS [12:13]
        /// External trigger prescaler
        ETPS: u2 = 0,
        /// ECE [14:14]
        /// External clock enable
        ECE: u1 = 0,
        /// ETP [15:15]
        /// External trigger polarity
        ETP: u1 = 0,
        /// SMS3 [16:16]
        /// Slave mode selection
        SMS3: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// slave mode control register
    pub const SMCR = Register(SMCR_val).init(base_address + 0x8);

    /// OR
    const OR_val = packed struct {
        /// TI1_RMP [0:1]
        /// TIM11 Input 1 remapping
        TI1_RMP: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// option register
    pub const OR = Register(OR_val).init(base_address + 0x50);
};

/// Basic timers
pub const TIM6 = struct {
    const base_address = 0x40001000;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// Low counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Low Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);
};

/// Basic timers
pub const TIM7 = struct {
    const base_address = 0x40001400;
    /// CR1
    const CR1_val = packed struct {
        /// CEN [0:0]
        /// Counter enable
        CEN: u1 = 0,
        /// UDIS [1:1]
        /// Update disable
        UDIS: u1 = 0,
        /// URS [2:2]
        /// Update request source
        URS: u1 = 0,
        /// OPM [3:3]
        /// One-pulse mode
        OPM: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ARPE [7:7]
        /// Auto-reload preload enable
        ARPE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// MMS [4:6]
        /// Master mode selection
        MMS: u3 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// DIER
    const DIER_val = packed struct {
        /// UIE [0:0]
        /// Update interrupt enable
        UIE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// UDE [8:8]
        /// Update DMA request enable
        UDE: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DMA/Interrupt enable register
    pub const DIER = Register(DIER_val).init(base_address + 0xc);

    /// SR
    const SR_val = packed struct {
        /// UIF [0:0]
        /// Update interrupt flag
        UIF: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x10);

    /// EGR
    const EGR_val = packed struct {
        /// UG [0:0]
        /// Update generation
        UG: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// event generation register
    pub const EGR = Register(EGR_val).init(base_address + 0x14);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// Low counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// counter
    pub const CNT = Register(CNT_val).init(base_address + 0x24);

    /// PSC
    const PSC_val = packed struct {
        /// PSC [0:15]
        /// Prescaler value
        PSC: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler
    pub const PSC = Register(PSC_val).init(base_address + 0x28);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Low Auto-reload value
        ARR: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// auto-reload register
    pub const ARR = Register(ARR_val).init(base_address + 0x2c);
};

/// Ethernet: media access control
pub const Ethernet_MAC = struct {
    const base_address = 0x40028000;
    /// MACCR
    const MACCR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// RE [2:2]
        /// RE
        RE: u1 = 0,
        /// TE [3:3]
        /// TE
        TE: u1 = 0,
        /// DC [4:4]
        /// DC
        DC: u1 = 0,
        /// BL [5:6]
        /// BL
        BL: u2 = 0,
        /// APCS [7:7]
        /// APCS
        APCS: u1 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// RD [9:9]
        /// RD
        RD: u1 = 0,
        /// IPCO [10:10]
        /// IPCO
        IPCO: u1 = 0,
        /// DM [11:11]
        /// DM
        DM: u1 = 0,
        /// LM [12:12]
        /// LM
        LM: u1 = 0,
        /// ROD [13:13]
        /// ROD
        ROD: u1 = 0,
        /// FES [14:14]
        /// FES
        FES: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 1,
        /// CSD [16:16]
        /// CSD
        CSD: u1 = 0,
        /// IFG [17:19]
        /// IFG
        IFG: u3 = 0,
        /// unused [20:21]
        _unused20: u2 = 0,
        /// JD [22:22]
        /// JD
        JD: u1 = 0,
        /// WD [23:23]
        /// WD
        WD: u1 = 0,
        /// unused [24:24]
        _unused24: u1 = 0,
        /// CSTF [25:25]
        /// CSTF
        CSTF: u1 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Ethernet MAC configuration
    pub const MACCR = Register(MACCR_val).init(base_address + 0x0);

    /// MACFFR
    const MACFFR_val = packed struct {
        /// PM [0:0]
        /// PM
        PM: u1 = 0,
        /// HU [1:1]
        /// HU
        HU: u1 = 0,
        /// HM [2:2]
        /// HM
        HM: u1 = 0,
        /// DAIF [3:3]
        /// DAIF
        DAIF: u1 = 0,
        /// RAM [4:4]
        /// RAM
        RAM: u1 = 0,
        /// BFD [5:5]
        /// BFD
        BFD: u1 = 0,
        /// PCF [6:6]
        /// PCF
        PCF: u1 = 0,
        /// SAIF [7:7]
        /// SAIF
        SAIF: u1 = 0,
        /// SAF [8:8]
        /// SAF
        SAF: u1 = 0,
        /// HPF [9:9]
        /// HPF
        HPF: u1 = 0,
        /// unused [10:30]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// RA [31:31]
        /// RA
        RA: u1 = 0,
    };
    /// Ethernet MAC frame filter
    pub const MACFFR = Register(MACFFR_val).init(base_address + 0x4);

    /// MACHTHR
    const MACHTHR_val = packed struct {
        /// HTH [0:31]
        /// HTH
        HTH: u32 = 0,
    };
    /// Ethernet MAC hash table high
    pub const MACHTHR = Register(MACHTHR_val).init(base_address + 0x8);

    /// MACHTLR
    const MACHTLR_val = packed struct {
        /// HTL [0:31]
        /// HTL
        HTL: u32 = 0,
    };
    /// Ethernet MAC hash table low
    pub const MACHTLR = Register(MACHTLR_val).init(base_address + 0xc);

    /// MACMIIAR
    const MACMIIAR_val = packed struct {
        /// MB [0:0]
        /// MB
        MB: u1 = 0,
        /// MW [1:1]
        /// MW
        MW: u1 = 0,
        /// CR [2:4]
        /// CR
        CR: u3 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// MR [6:10]
        /// MR
        MR: u5 = 0,
        /// PA [11:15]
        /// PA
        PA: u5 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC MII address
    pub const MACMIIAR = Register(MACMIIAR_val).init(base_address + 0x10);

    /// MACMIIDR
    const MACMIIDR_val = packed struct {
        /// TD [0:15]
        /// TD
        TD: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC MII data register
    pub const MACMIIDR = Register(MACMIIDR_val).init(base_address + 0x14);

    /// MACFCR
    const MACFCR_val = packed struct {
        /// FCB [0:0]
        /// FCB
        FCB: u1 = 0,
        /// TFCE [1:1]
        /// TFCE
        TFCE: u1 = 0,
        /// RFCE [2:2]
        /// RFCE
        RFCE: u1 = 0,
        /// UPFD [3:3]
        /// UPFD
        UPFD: u1 = 0,
        /// PLT [4:5]
        /// PLT
        PLT: u2 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// ZQPD [7:7]
        /// ZQPD
        ZQPD: u1 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// PT [16:31]
        /// PT
        PT: u16 = 0,
    };
    /// Ethernet MAC flow control
    pub const MACFCR = Register(MACFCR_val).init(base_address + 0x18);

    /// MACVLANTR
    const MACVLANTR_val = packed struct {
        /// VLANTI [0:15]
        /// VLANTI
        VLANTI: u16 = 0,
        /// VLANTC [16:16]
        /// VLANTC
        VLANTC: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC VLAN tag register
    pub const MACVLANTR = Register(MACVLANTR_val).init(base_address + 0x1c);

    /// MACPMTCSR
    const MACPMTCSR_val = packed struct {
        /// PD [0:0]
        /// PD
        PD: u1 = 0,
        /// MPE [1:1]
        /// MPE
        MPE: u1 = 0,
        /// WFE [2:2]
        /// WFE
        WFE: u1 = 0,
        /// unused [3:4]
        _unused3: u2 = 0,
        /// MPR [5:5]
        /// MPR
        MPR: u1 = 0,
        /// WFR [6:6]
        /// WFR
        WFR: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// GU [9:9]
        /// GU
        GU: u1 = 0,
        /// unused [10:30]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// WFFRPR [31:31]
        /// WFFRPR
        WFFRPR: u1 = 0,
    };
    /// Ethernet MAC PMT control and status
    pub const MACPMTCSR = Register(MACPMTCSR_val).init(base_address + 0x2c);

    /// MACDBGR
    const MACDBGR_val = packed struct {
        /// CR [0:0]
        /// CR
        CR: u1 = 0,
        /// CSR [1:1]
        /// CSR
        CSR: u1 = 0,
        /// ROR [2:2]
        /// ROR
        ROR: u1 = 0,
        /// MCF [3:3]
        /// MCF
        MCF: u1 = 0,
        /// MCP [4:4]
        /// MCP
        MCP: u1 = 0,
        /// MCFHP [5:5]
        /// MCFHP
        MCFHP: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC debug register
    pub const MACDBGR = Register(MACDBGR_val).init(base_address + 0x34);

    /// MACSR
    const MACSR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// PMTS [3:3]
        /// PMTS
        PMTS: u1 = 0,
        /// MMCS [4:4]
        /// MMCS
        MMCS: u1 = 0,
        /// MMCRS [5:5]
        /// MMCRS
        MMCRS: u1 = 0,
        /// MMCTS [6:6]
        /// MMCTS
        MMCTS: u1 = 0,
        /// unused [7:8]
        _unused7: u1 = 0,
        _unused8: u1 = 0,
        /// TSTS [9:9]
        /// TSTS
        TSTS: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC interrupt status
    pub const MACSR = Register(MACSR_val).init(base_address + 0x38);

    /// MACIMR
    const MACIMR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// PMTIM [3:3]
        /// PMTIM
        PMTIM: u1 = 0,
        /// unused [4:8]
        _unused4: u4 = 0,
        _unused8: u1 = 0,
        /// TSTIM [9:9]
        /// TSTIM
        TSTIM: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MAC interrupt mask
    pub const MACIMR = Register(MACIMR_val).init(base_address + 0x3c);

    /// MACA0HR
    const MACA0HR_val = packed struct {
        /// MACA0H [0:15]
        /// MAC address0 high
        MACA0H: u16 = 65535,
        /// unused [16:30]
        _unused16: u8 = 16,
        _unused24: u7 = 0,
        /// MO [31:31]
        /// Always 1
        MO: u1 = 0,
    };
    /// Ethernet MAC address 0 high
    pub const MACA0HR = Register(MACA0HR_val).init(base_address + 0x40);

    /// MACA0LR
    const MACA0LR_val = packed struct {
        /// MACA0L [0:31]
        /// 0
        MACA0L: u32 = 4294967295,
    };
    /// Ethernet MAC address 0 low
    pub const MACA0LR = Register(MACA0LR_val).init(base_address + 0x44);

    /// MACA1HR
    const MACA1HR_val = packed struct {
        /// MACA1H [0:15]
        /// MACA1H
        MACA1H: u16 = 65535,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// MBC [24:29]
        /// MBC
        MBC: u6 = 0,
        /// SA [30:30]
        /// SA
        SA: u1 = 0,
        /// AE [31:31]
        /// AE
        AE: u1 = 0,
    };
    /// Ethernet MAC address 1 high
    pub const MACA1HR = Register(MACA1HR_val).init(base_address + 0x48);

    /// MACA1LR
    const MACA1LR_val = packed struct {
        /// MACA1LR [0:31]
        /// MACA1LR
        MACA1LR: u32 = 4294967295,
    };
    /// Ethernet MAC address1 low
    pub const MACA1LR = Register(MACA1LR_val).init(base_address + 0x4c);

    /// MACA2HR
    const MACA2HR_val = packed struct {
        /// MAC2AH [0:15]
        /// MAC2AH
        MAC2AH: u16 = 65535,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// MBC [24:29]
        /// MBC
        MBC: u6 = 0,
        /// SA [30:30]
        /// SA
        SA: u1 = 0,
        /// AE [31:31]
        /// AE
        AE: u1 = 0,
    };
    /// Ethernet MAC address 2 high
    pub const MACA2HR = Register(MACA2HR_val).init(base_address + 0x50);

    /// MACA2LR
    const MACA2LR_val = packed struct {
        /// MACA2L [0:30]
        /// MACA2L
        MACA2L: u31 = 2147483647,
        /// unused [31:31]
        _unused31: u1 = 1,
    };
    /// Ethernet MAC address 2 low
    pub const MACA2LR = Register(MACA2LR_val).init(base_address + 0x54);

    /// MACA3HR
    const MACA3HR_val = packed struct {
        /// MACA3H [0:15]
        /// MACA3H
        MACA3H: u16 = 65535,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// MBC [24:29]
        /// MBC
        MBC: u6 = 0,
        /// SA [30:30]
        /// SA
        SA: u1 = 0,
        /// AE [31:31]
        /// AE
        AE: u1 = 0,
    };
    /// Ethernet MAC address 3 high
    pub const MACA3HR = Register(MACA3HR_val).init(base_address + 0x58);

    /// MACA3LR
    const MACA3LR_val = packed struct {
        /// MBCA3L [0:31]
        /// MBCA3L
        MBCA3L: u32 = 4294967295,
    };
    /// Ethernet MAC address 3 low
    pub const MACA3LR = Register(MACA3LR_val).init(base_address + 0x5c);

    /// MACRWUFFER
    const MACRWUFFER_val = packed struct {
        /// unused [0:31]
        _unused0: u8 = 255,
        _unused8: u8 = 255,
        _unused16: u8 = 255,
        _unused24: u8 = 255,
    };
    /// Ethernet MAC remote wakeup frame filter
    pub const MACRWUFFER = Register(MACRWUFFER_val).init(base_address + 0x60);
};

/// Cryptographic processor
pub const CRC = struct {
    const base_address = 0x40023000;
    /// DR
    const DR_val = packed struct {
        /// DR [0:31]
        /// Data Register
        DR: u32 = 4294967295,
    };
    /// Data register
    pub const DR = Register(DR_val).init(base_address + 0x0);

    /// IDR
    const IDR_val = packed struct {
        /// IDR [0:7]
        /// Independent Data register
        IDR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Independent Data register
    pub const IDR = Register(IDR_val).init(base_address + 0x4);

    /// CR
    const CR_val = packed struct {
        /// CR [0:0]
        /// Control regidter
        CR: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control register
    pub const CR = Register(CR_val).init(base_address + 0x8);

    /// INIT
    const INIT_val = packed struct {
        /// CRC_INIT [0:31]
        /// Programmable initial CRC
        CRC_INIT: u32 = 0,
    };
    /// Initial CRC value
    pub const INIT = Register(INIT_val).init(base_address + 0x10);

    /// POL
    const POL_val = packed struct {
        /// POL [0:31]
        /// Programmable polynomial
        POL: u32 = 0,
    };
    /// CRC polynomial
    pub const POL = Register(POL_val).init(base_address + 0x14);
};

/// Controller area network
pub const CAN1 = struct {
    const base_address = 0x40006400;
    /// MCR
    const MCR_val = packed struct {
        /// INRQ [0:0]
        /// INRQ
        INRQ: u1 = 0,
        /// SLEEP [1:1]
        /// SLEEP
        SLEEP: u1 = 1,
        /// TXFP [2:2]
        /// TXFP
        TXFP: u1 = 0,
        /// RFLM [3:3]
        /// RFLM
        RFLM: u1 = 0,
        /// NART [4:4]
        /// NART
        NART: u1 = 0,
        /// AWUM [5:5]
        /// AWUM
        AWUM: u1 = 0,
        /// ABOM [6:6]
        /// ABOM
        ABOM: u1 = 0,
        /// TTCM [7:7]
        /// TTCM
        TTCM: u1 = 0,
        /// unused [8:14]
        _unused8: u7 = 0,
        /// RESET [15:15]
        /// RESET
        RESET: u1 = 0,
        /// DBF [16:16]
        /// DBF
        DBF: u1 = 1,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// master control register
    pub const MCR = Register(MCR_val).init(base_address + 0x0);

    /// MSR
    const MSR_val = packed struct {
        /// INAK [0:0]
        /// INAK
        INAK: u1 = 0,
        /// SLAK [1:1]
        /// SLAK
        SLAK: u1 = 1,
        /// ERRI [2:2]
        /// ERRI
        ERRI: u1 = 0,
        /// WKUI [3:3]
        /// WKUI
        WKUI: u1 = 0,
        /// SLAKI [4:4]
        /// SLAKI
        SLAKI: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// TXM [8:8]
        /// TXM
        TXM: u1 = 0,
        /// RXM [9:9]
        /// RXM
        RXM: u1 = 0,
        /// SAMP [10:10]
        /// SAMP
        SAMP: u1 = 1,
        /// RX [11:11]
        /// RX
        RX: u1 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// master status register
    pub const MSR = Register(MSR_val).init(base_address + 0x4);

    /// TSR
    const TSR_val = packed struct {
        /// RQCP0 [0:0]
        /// RQCP0
        RQCP0: u1 = 0,
        /// TXOK0 [1:1]
        /// TXOK0
        TXOK0: u1 = 0,
        /// ALST0 [2:2]
        /// ALST0
        ALST0: u1 = 0,
        /// TERR0 [3:3]
        /// TERR0
        TERR0: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ABRQ0 [7:7]
        /// ABRQ0
        ABRQ0: u1 = 0,
        /// RQCP1 [8:8]
        /// RQCP1
        RQCP1: u1 = 0,
        /// TXOK1 [9:9]
        /// TXOK1
        TXOK1: u1 = 0,
        /// ALST1 [10:10]
        /// ALST1
        ALST1: u1 = 0,
        /// TERR1 [11:11]
        /// TERR1
        TERR1: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ABRQ1 [15:15]
        /// ABRQ1
        ABRQ1: u1 = 0,
        /// RQCP2 [16:16]
        /// RQCP2
        RQCP2: u1 = 0,
        /// TXOK2 [17:17]
        /// TXOK2
        TXOK2: u1 = 0,
        /// ALST2 [18:18]
        /// ALST2
        ALST2: u1 = 0,
        /// TERR2 [19:19]
        /// TERR2
        TERR2: u1 = 0,
        /// unused [20:22]
        _unused20: u3 = 0,
        /// ABRQ2 [23:23]
        /// ABRQ2
        ABRQ2: u1 = 0,
        /// CODE [24:25]
        /// CODE
        CODE: u2 = 0,
        /// TME0 [26:26]
        /// Lowest priority flag for mailbox
        TME0: u1 = 1,
        /// TME1 [27:27]
        /// Lowest priority flag for mailbox
        TME1: u1 = 1,
        /// TME2 [28:28]
        /// Lowest priority flag for mailbox
        TME2: u1 = 1,
        /// LOW0 [29:29]
        /// Lowest priority flag for mailbox
        LOW0: u1 = 0,
        /// LOW1 [30:30]
        /// Lowest priority flag for mailbox
        LOW1: u1 = 0,
        /// LOW2 [31:31]
        /// Lowest priority flag for mailbox
        LOW2: u1 = 0,
    };
    /// transmit status register
    pub const TSR = Register(TSR_val).init(base_address + 0x8);

    /// RF0R
    const RF0R_val = packed struct {
        /// FMP0 [0:1]
        /// FMP0
        FMP0: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL0 [3:3]
        /// FULL0
        FULL0: u1 = 0,
        /// FOVR0 [4:4]
        /// FOVR0
        FOVR0: u1 = 0,
        /// RFOM0 [5:5]
        /// RFOM0
        RFOM0: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 0 register
    pub const RF0R = Register(RF0R_val).init(base_address + 0xc);

    /// RF1R
    const RF1R_val = packed struct {
        /// FMP1 [0:1]
        /// FMP1
        FMP1: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL1 [3:3]
        /// FULL1
        FULL1: u1 = 0,
        /// FOVR1 [4:4]
        /// FOVR1
        FOVR1: u1 = 0,
        /// RFOM1 [5:5]
        /// RFOM1
        RFOM1: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 1 register
    pub const RF1R = Register(RF1R_val).init(base_address + 0x10);

    /// IER
    const IER_val = packed struct {
        /// TMEIE [0:0]
        /// TMEIE
        TMEIE: u1 = 0,
        /// FMPIE0 [1:1]
        /// FMPIE0
        FMPIE0: u1 = 0,
        /// FFIE0 [2:2]
        /// FFIE0
        FFIE0: u1 = 0,
        /// FOVIE0 [3:3]
        /// FOVIE0
        FOVIE0: u1 = 0,
        /// FMPIE1 [4:4]
        /// FMPIE1
        FMPIE1: u1 = 0,
        /// FFIE1 [5:5]
        /// FFIE1
        FFIE1: u1 = 0,
        /// FOVIE1 [6:6]
        /// FOVIE1
        FOVIE1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EWGIE [8:8]
        /// EWGIE
        EWGIE: u1 = 0,
        /// EPVIE [9:9]
        /// EPVIE
        EPVIE: u1 = 0,
        /// BOFIE [10:10]
        /// BOFIE
        BOFIE: u1 = 0,
        /// LECIE [11:11]
        /// LECIE
        LECIE: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ERRIE [15:15]
        /// ERRIE
        ERRIE: u1 = 0,
        /// WKUIE [16:16]
        /// WKUIE
        WKUIE: u1 = 0,
        /// SLKIE [17:17]
        /// SLKIE
        SLKIE: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IER = Register(IER_val).init(base_address + 0x14);

    /// ESR
    const ESR_val = packed struct {
        /// EWGF [0:0]
        /// EWGF
        EWGF: u1 = 0,
        /// EPVF [1:1]
        /// EPVF
        EPVF: u1 = 0,
        /// BOFF [2:2]
        /// BOFF
        BOFF: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// LEC [4:6]
        /// LEC
        LEC: u3 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// TEC [16:23]
        /// TEC
        TEC: u8 = 0,
        /// REC [24:31]
        /// REC
        REC: u8 = 0,
    };
    /// interrupt enable register
    pub const ESR = Register(ESR_val).init(base_address + 0x18);

    /// BTR
    const BTR_val = packed struct {
        /// BRP [0:9]
        /// BRP
        BRP: u10 = 0,
        /// unused [10:15]
        _unused10: u6 = 0,
        /// TS1 [16:19]
        /// TS1
        TS1: u4 = 0,
        /// TS2 [20:22]
        /// TS2
        TS2: u3 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// SJW [24:25]
        /// SJW
        SJW: u2 = 0,
        /// unused [26:29]
        _unused26: u4 = 0,
        /// LBKM [30:30]
        /// LBKM
        LBKM: u1 = 0,
        /// SILM [31:31]
        /// SILM
        SILM: u1 = 0,
    };
    /// bit timing register
    pub const BTR = Register(BTR_val).init(base_address + 0x1c);

    /// TI0R
    const TI0R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// TX mailbox identifier register
    pub const TI0R = Register(TI0R_val).init(base_address + 0x180);

    /// TDT0R
    const TDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT0R = Register(TDT0R_val).init(base_address + 0x184);

    /// TDL0R
    const TDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL0R = Register(TDL0R_val).init(base_address + 0x188);

    /// TDH0R
    const TDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH0R = Register(TDH0R_val).init(base_address + 0x18c);

    /// TI1R
    const TI1R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI1R = Register(TI1R_val).init(base_address + 0x190);

    /// TDT1R
    const TDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT1R = Register(TDT1R_val).init(base_address + 0x194);

    /// TDL1R
    const TDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL1R = Register(TDL1R_val).init(base_address + 0x198);

    /// TDH1R
    const TDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH1R = Register(TDH1R_val).init(base_address + 0x19c);

    /// TI2R
    const TI2R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI2R = Register(TI2R_val).init(base_address + 0x1a0);

    /// TDT2R
    const TDT2R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT2R = Register(TDT2R_val).init(base_address + 0x1a4);

    /// TDL2R
    const TDL2R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL2R = Register(TDL2R_val).init(base_address + 0x1a8);

    /// TDH2R
    const TDH2R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH2R = Register(TDH2R_val).init(base_address + 0x1ac);

    /// RI0R
    const RI0R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// receive FIFO mailbox identifier
    pub const RI0R = Register(RI0R_val).init(base_address + 0x1b0);

    /// RDT0R
    const RDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT0R = Register(RDT0R_val).init(base_address + 0x1b4);

    /// RDL0R
    const RDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL0R = Register(RDL0R_val).init(base_address + 0x1b8);

    /// RDH0R
    const RDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// receive FIFO mailbox data high
    pub const RDH0R = Register(RDH0R_val).init(base_address + 0x1bc);

    /// RI1R
    const RI1R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox data high register
    pub const RI1R = Register(RI1R_val).init(base_address + 0x1c0);

    /// RDT1R
    const RDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT1R = Register(RDT1R_val).init(base_address + 0x1c4);

    /// RDL1R
    const RDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL1R = Register(RDL1R_val).init(base_address + 0x1c8);

    /// RDH1R
    const RDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const RDH1R = Register(RDH1R_val).init(base_address + 0x1cc);

    /// FMR
    const FMR_val = packed struct {
        /// FINIT [0:0]
        /// FINIT
        FINIT: u1 = 1,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// CAN2SB [8:13]
        /// CAN2SB
        CAN2SB: u6 = 14,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 28,
        _unused24: u8 = 42,
    };
    /// filter master register
    pub const FMR = Register(FMR_val).init(base_address + 0x200);

    /// FM1R
    const FM1R_val = packed struct {
        /// FBM0 [0:0]
        /// Filter mode
        FBM0: u1 = 0,
        /// FBM1 [1:1]
        /// Filter mode
        FBM1: u1 = 0,
        /// FBM2 [2:2]
        /// Filter mode
        FBM2: u1 = 0,
        /// FBM3 [3:3]
        /// Filter mode
        FBM3: u1 = 0,
        /// FBM4 [4:4]
        /// Filter mode
        FBM4: u1 = 0,
        /// FBM5 [5:5]
        /// Filter mode
        FBM5: u1 = 0,
        /// FBM6 [6:6]
        /// Filter mode
        FBM6: u1 = 0,
        /// FBM7 [7:7]
        /// Filter mode
        FBM7: u1 = 0,
        /// FBM8 [8:8]
        /// Filter mode
        FBM8: u1 = 0,
        /// FBM9 [9:9]
        /// Filter mode
        FBM9: u1 = 0,
        /// FBM10 [10:10]
        /// Filter mode
        FBM10: u1 = 0,
        /// FBM11 [11:11]
        /// Filter mode
        FBM11: u1 = 0,
        /// FBM12 [12:12]
        /// Filter mode
        FBM12: u1 = 0,
        /// FBM13 [13:13]
        /// Filter mode
        FBM13: u1 = 0,
        /// FBM14 [14:14]
        /// Filter mode
        FBM14: u1 = 0,
        /// FBM15 [15:15]
        /// Filter mode
        FBM15: u1 = 0,
        /// FBM16 [16:16]
        /// Filter mode
        FBM16: u1 = 0,
        /// FBM17 [17:17]
        /// Filter mode
        FBM17: u1 = 0,
        /// FBM18 [18:18]
        /// Filter mode
        FBM18: u1 = 0,
        /// FBM19 [19:19]
        /// Filter mode
        FBM19: u1 = 0,
        /// FBM20 [20:20]
        /// Filter mode
        FBM20: u1 = 0,
        /// FBM21 [21:21]
        /// Filter mode
        FBM21: u1 = 0,
        /// FBM22 [22:22]
        /// Filter mode
        FBM22: u1 = 0,
        /// FBM23 [23:23]
        /// Filter mode
        FBM23: u1 = 0,
        /// FBM24 [24:24]
        /// Filter mode
        FBM24: u1 = 0,
        /// FBM25 [25:25]
        /// Filter mode
        FBM25: u1 = 0,
        /// FBM26 [26:26]
        /// Filter mode
        FBM26: u1 = 0,
        /// FBM27 [27:27]
        /// Filter mode
        FBM27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter mode register
    pub const FM1R = Register(FM1R_val).init(base_address + 0x204);

    /// FS1R
    const FS1R_val = packed struct {
        /// FSC0 [0:0]
        /// Filter scale configuration
        FSC0: u1 = 0,
        /// FSC1 [1:1]
        /// Filter scale configuration
        FSC1: u1 = 0,
        /// FSC2 [2:2]
        /// Filter scale configuration
        FSC2: u1 = 0,
        /// FSC3 [3:3]
        /// Filter scale configuration
        FSC3: u1 = 0,
        /// FSC4 [4:4]
        /// Filter scale configuration
        FSC4: u1 = 0,
        /// FSC5 [5:5]
        /// Filter scale configuration
        FSC5: u1 = 0,
        /// FSC6 [6:6]
        /// Filter scale configuration
        FSC6: u1 = 0,
        /// FSC7 [7:7]
        /// Filter scale configuration
        FSC7: u1 = 0,
        /// FSC8 [8:8]
        /// Filter scale configuration
        FSC8: u1 = 0,
        /// FSC9 [9:9]
        /// Filter scale configuration
        FSC9: u1 = 0,
        /// FSC10 [10:10]
        /// Filter scale configuration
        FSC10: u1 = 0,
        /// FSC11 [11:11]
        /// Filter scale configuration
        FSC11: u1 = 0,
        /// FSC12 [12:12]
        /// Filter scale configuration
        FSC12: u1 = 0,
        /// FSC13 [13:13]
        /// Filter scale configuration
        FSC13: u1 = 0,
        /// FSC14 [14:14]
        /// Filter scale configuration
        FSC14: u1 = 0,
        /// FSC15 [15:15]
        /// Filter scale configuration
        FSC15: u1 = 0,
        /// FSC16 [16:16]
        /// Filter scale configuration
        FSC16: u1 = 0,
        /// FSC17 [17:17]
        /// Filter scale configuration
        FSC17: u1 = 0,
        /// FSC18 [18:18]
        /// Filter scale configuration
        FSC18: u1 = 0,
        /// FSC19 [19:19]
        /// Filter scale configuration
        FSC19: u1 = 0,
        /// FSC20 [20:20]
        /// Filter scale configuration
        FSC20: u1 = 0,
        /// FSC21 [21:21]
        /// Filter scale configuration
        FSC21: u1 = 0,
        /// FSC22 [22:22]
        /// Filter scale configuration
        FSC22: u1 = 0,
        /// FSC23 [23:23]
        /// Filter scale configuration
        FSC23: u1 = 0,
        /// FSC24 [24:24]
        /// Filter scale configuration
        FSC24: u1 = 0,
        /// FSC25 [25:25]
        /// Filter scale configuration
        FSC25: u1 = 0,
        /// FSC26 [26:26]
        /// Filter scale configuration
        FSC26: u1 = 0,
        /// FSC27 [27:27]
        /// Filter scale configuration
        FSC27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter scale register
    pub const FS1R = Register(FS1R_val).init(base_address + 0x20c);

    /// FFA1R
    const FFA1R_val = packed struct {
        /// FFA0 [0:0]
        /// Filter FIFO assignment for filter
        FFA0: u1 = 0,
        /// FFA1 [1:1]
        /// Filter FIFO assignment for filter
        FFA1: u1 = 0,
        /// FFA2 [2:2]
        /// Filter FIFO assignment for filter
        FFA2: u1 = 0,
        /// FFA3 [3:3]
        /// Filter FIFO assignment for filter
        FFA3: u1 = 0,
        /// FFA4 [4:4]
        /// Filter FIFO assignment for filter
        FFA4: u1 = 0,
        /// FFA5 [5:5]
        /// Filter FIFO assignment for filter
        FFA5: u1 = 0,
        /// FFA6 [6:6]
        /// Filter FIFO assignment for filter
        FFA6: u1 = 0,
        /// FFA7 [7:7]
        /// Filter FIFO assignment for filter
        FFA7: u1 = 0,
        /// FFA8 [8:8]
        /// Filter FIFO assignment for filter
        FFA8: u1 = 0,
        /// FFA9 [9:9]
        /// Filter FIFO assignment for filter
        FFA9: u1 = 0,
        /// FFA10 [10:10]
        /// Filter FIFO assignment for filter
        FFA10: u1 = 0,
        /// FFA11 [11:11]
        /// Filter FIFO assignment for filter
        FFA11: u1 = 0,
        /// FFA12 [12:12]
        /// Filter FIFO assignment for filter
        FFA12: u1 = 0,
        /// FFA13 [13:13]
        /// Filter FIFO assignment for filter
        FFA13: u1 = 0,
        /// FFA14 [14:14]
        /// Filter FIFO assignment for filter
        FFA14: u1 = 0,
        /// FFA15 [15:15]
        /// Filter FIFO assignment for filter
        FFA15: u1 = 0,
        /// FFA16 [16:16]
        /// Filter FIFO assignment for filter
        FFA16: u1 = 0,
        /// FFA17 [17:17]
        /// Filter FIFO assignment for filter
        FFA17: u1 = 0,
        /// FFA18 [18:18]
        /// Filter FIFO assignment for filter
        FFA18: u1 = 0,
        /// FFA19 [19:19]
        /// Filter FIFO assignment for filter
        FFA19: u1 = 0,
        /// FFA20 [20:20]
        /// Filter FIFO assignment for filter
        FFA20: u1 = 0,
        /// FFA21 [21:21]
        /// Filter FIFO assignment for filter
        FFA21: u1 = 0,
        /// FFA22 [22:22]
        /// Filter FIFO assignment for filter
        FFA22: u1 = 0,
        /// FFA23 [23:23]
        /// Filter FIFO assignment for filter
        FFA23: u1 = 0,
        /// FFA24 [24:24]
        /// Filter FIFO assignment for filter
        FFA24: u1 = 0,
        /// FFA25 [25:25]
        /// Filter FIFO assignment for filter
        FFA25: u1 = 0,
        /// FFA26 [26:26]
        /// Filter FIFO assignment for filter
        FFA26: u1 = 0,
        /// FFA27 [27:27]
        /// Filter FIFO assignment for filter
        FFA27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter FIFO assignment
    pub const FFA1R = Register(FFA1R_val).init(base_address + 0x214);

    /// FA1R
    const FA1R_val = packed struct {
        /// FACT0 [0:0]
        /// Filter active
        FACT0: u1 = 0,
        /// FACT1 [1:1]
        /// Filter active
        FACT1: u1 = 0,
        /// FACT2 [2:2]
        /// Filter active
        FACT2: u1 = 0,
        /// FACT3 [3:3]
        /// Filter active
        FACT3: u1 = 0,
        /// FACT4 [4:4]
        /// Filter active
        FACT4: u1 = 0,
        /// FACT5 [5:5]
        /// Filter active
        FACT5: u1 = 0,
        /// FACT6 [6:6]
        /// Filter active
        FACT6: u1 = 0,
        /// FACT7 [7:7]
        /// Filter active
        FACT7: u1 = 0,
        /// FACT8 [8:8]
        /// Filter active
        FACT8: u1 = 0,
        /// FACT9 [9:9]
        /// Filter active
        FACT9: u1 = 0,
        /// FACT10 [10:10]
        /// Filter active
        FACT10: u1 = 0,
        /// FACT11 [11:11]
        /// Filter active
        FACT11: u1 = 0,
        /// FACT12 [12:12]
        /// Filter active
        FACT12: u1 = 0,
        /// FACT13 [13:13]
        /// Filter active
        FACT13: u1 = 0,
        /// FACT14 [14:14]
        /// Filter active
        FACT14: u1 = 0,
        /// FACT15 [15:15]
        /// Filter active
        FACT15: u1 = 0,
        /// FACT16 [16:16]
        /// Filter active
        FACT16: u1 = 0,
        /// FACT17 [17:17]
        /// Filter active
        FACT17: u1 = 0,
        /// FACT18 [18:18]
        /// Filter active
        FACT18: u1 = 0,
        /// FACT19 [19:19]
        /// Filter active
        FACT19: u1 = 0,
        /// FACT20 [20:20]
        /// Filter active
        FACT20: u1 = 0,
        /// FACT21 [21:21]
        /// Filter active
        FACT21: u1 = 0,
        /// FACT22 [22:22]
        /// Filter active
        FACT22: u1 = 0,
        /// FACT23 [23:23]
        /// Filter active
        FACT23: u1 = 0,
        /// FACT24 [24:24]
        /// Filter active
        FACT24: u1 = 0,
        /// FACT25 [25:25]
        /// Filter active
        FACT25: u1 = 0,
        /// FACT26 [26:26]
        /// Filter active
        FACT26: u1 = 0,
        /// FACT27 [27:27]
        /// Filter active
        FACT27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter activation register
    pub const FA1R = Register(FA1R_val).init(base_address + 0x21c);

    /// F0R1
    const F0R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 1
    pub const F0R1 = Register(F0R1_val).init(base_address + 0x240);

    /// F0R2
    const F0R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 2
    pub const F0R2 = Register(F0R2_val).init(base_address + 0x244);

    /// F1R1
    const F1R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 1
    pub const F1R1 = Register(F1R1_val).init(base_address + 0x248);

    /// F1R2
    const F1R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 2
    pub const F1R2 = Register(F1R2_val).init(base_address + 0x24c);

    /// F2R1
    const F2R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 1
    pub const F2R1 = Register(F2R1_val).init(base_address + 0x250);

    /// F2R2
    const F2R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 2
    pub const F2R2 = Register(F2R2_val).init(base_address + 0x254);

    /// F3R1
    const F3R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 1
    pub const F3R1 = Register(F3R1_val).init(base_address + 0x258);

    /// F3R2
    const F3R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 2
    pub const F3R2 = Register(F3R2_val).init(base_address + 0x25c);

    /// F4R1
    const F4R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F4R1 = Register(F4R1_val).init(base_address + 0x260);

    /// F4R2
    const F4R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 2
    pub const F4R2 = Register(F4R2_val).init(base_address + 0x264);

    /// F5R1
    const F5R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 1
    pub const F5R1 = Register(F5R1_val).init(base_address + 0x268);

    /// F5R2
    const F5R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 2
    pub const F5R2 = Register(F5R2_val).init(base_address + 0x26c);

    /// F6R1
    const F6R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 1
    pub const F6R1 = Register(F6R1_val).init(base_address + 0x270);

    /// F6R2
    const F6R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 2
    pub const F6R2 = Register(F6R2_val).init(base_address + 0x274);

    /// F7R1
    const F7R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 1
    pub const F7R1 = Register(F7R1_val).init(base_address + 0x278);

    /// F7R2
    const F7R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 2
    pub const F7R2 = Register(F7R2_val).init(base_address + 0x27c);

    /// F8R1
    const F8R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 1
    pub const F8R1 = Register(F8R1_val).init(base_address + 0x280);

    /// F8R2
    const F8R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 2
    pub const F8R2 = Register(F8R2_val).init(base_address + 0x284);

    /// F9R1
    const F9R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 1
    pub const F9R1 = Register(F9R1_val).init(base_address + 0x288);

    /// F9R2
    const F9R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 2
    pub const F9R2 = Register(F9R2_val).init(base_address + 0x28c);

    /// F10R1
    const F10R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 1
    pub const F10R1 = Register(F10R1_val).init(base_address + 0x290);

    /// F10R2
    const F10R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 2
    pub const F10R2 = Register(F10R2_val).init(base_address + 0x294);

    /// F11R1
    const F11R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 1
    pub const F11R1 = Register(F11R1_val).init(base_address + 0x298);

    /// F11R2
    const F11R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 2
    pub const F11R2 = Register(F11R2_val).init(base_address + 0x29c);

    /// F12R1
    const F12R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F12R1 = Register(F12R1_val).init(base_address + 0x2a0);

    /// F12R2
    const F12R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 12 register 2
    pub const F12R2 = Register(F12R2_val).init(base_address + 0x2a4);

    /// F13R1
    const F13R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 1
    pub const F13R1 = Register(F13R1_val).init(base_address + 0x2a8);

    /// F13R2
    const F13R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 2
    pub const F13R2 = Register(F13R2_val).init(base_address + 0x2ac);

    /// F14R1
    const F14R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 1
    pub const F14R1 = Register(F14R1_val).init(base_address + 0x2b0);

    /// F14R2
    const F14R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 2
    pub const F14R2 = Register(F14R2_val).init(base_address + 0x2b4);

    /// F15R1
    const F15R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 1
    pub const F15R1 = Register(F15R1_val).init(base_address + 0x2b8);

    /// F15R2
    const F15R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 2
    pub const F15R2 = Register(F15R2_val).init(base_address + 0x2bc);

    /// F16R1
    const F16R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 1
    pub const F16R1 = Register(F16R1_val).init(base_address + 0x2c0);

    /// F16R2
    const F16R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 2
    pub const F16R2 = Register(F16R2_val).init(base_address + 0x2c4);

    /// F17R1
    const F17R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 1
    pub const F17R1 = Register(F17R1_val).init(base_address + 0x2c8);

    /// F17R2
    const F17R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 2
    pub const F17R2 = Register(F17R2_val).init(base_address + 0x2cc);

    /// F18R1
    const F18R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 1
    pub const F18R1 = Register(F18R1_val).init(base_address + 0x2d0);

    /// F18R2
    const F18R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 2
    pub const F18R2 = Register(F18R2_val).init(base_address + 0x2d4);

    /// F19R1
    const F19R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 1
    pub const F19R1 = Register(F19R1_val).init(base_address + 0x2d8);

    /// F19R2
    const F19R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 2
    pub const F19R2 = Register(F19R2_val).init(base_address + 0x2dc);

    /// F20R1
    const F20R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 1
    pub const F20R1 = Register(F20R1_val).init(base_address + 0x2e0);

    /// F20R2
    const F20R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 2
    pub const F20R2 = Register(F20R2_val).init(base_address + 0x2e4);

    /// F21R1
    const F21R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 1
    pub const F21R1 = Register(F21R1_val).init(base_address + 0x2e8);

    /// F21R2
    const F21R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 2
    pub const F21R2 = Register(F21R2_val).init(base_address + 0x2ec);

    /// F22R1
    const F22R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 1
    pub const F22R1 = Register(F22R1_val).init(base_address + 0x2f0);

    /// F22R2
    const F22R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 2
    pub const F22R2 = Register(F22R2_val).init(base_address + 0x2f4);

    /// F23R1
    const F23R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 1
    pub const F23R1 = Register(F23R1_val).init(base_address + 0x2f8);

    /// F23R2
    const F23R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 2
    pub const F23R2 = Register(F23R2_val).init(base_address + 0x2fc);

    /// F24R1
    const F24R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 1
    pub const F24R1 = Register(F24R1_val).init(base_address + 0x300);

    /// F24R2
    const F24R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 2
    pub const F24R2 = Register(F24R2_val).init(base_address + 0x304);

    /// F25R1
    const F25R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 1
    pub const F25R1 = Register(F25R1_val).init(base_address + 0x308);

    /// F25R2
    const F25R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 2
    pub const F25R2 = Register(F25R2_val).init(base_address + 0x30c);

    /// F26R1
    const F26R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 1
    pub const F26R1 = Register(F26R1_val).init(base_address + 0x310);

    /// F26R2
    const F26R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 2
    pub const F26R2 = Register(F26R2_val).init(base_address + 0x314);

    /// F27R1
    const F27R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 1
    pub const F27R1 = Register(F27R1_val).init(base_address + 0x318);

    /// F27R2
    const F27R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 2
    pub const F27R2 = Register(F27R2_val).init(base_address + 0x31c);
};

/// Controller area network
pub const CAN2 = struct {
    const base_address = 0x40006800;
    /// MCR
    const MCR_val = packed struct {
        /// INRQ [0:0]
        /// INRQ
        INRQ: u1 = 0,
        /// SLEEP [1:1]
        /// SLEEP
        SLEEP: u1 = 1,
        /// TXFP [2:2]
        /// TXFP
        TXFP: u1 = 0,
        /// RFLM [3:3]
        /// RFLM
        RFLM: u1 = 0,
        /// NART [4:4]
        /// NART
        NART: u1 = 0,
        /// AWUM [5:5]
        /// AWUM
        AWUM: u1 = 0,
        /// ABOM [6:6]
        /// ABOM
        ABOM: u1 = 0,
        /// TTCM [7:7]
        /// TTCM
        TTCM: u1 = 0,
        /// unused [8:14]
        _unused8: u7 = 0,
        /// RESET [15:15]
        /// RESET
        RESET: u1 = 0,
        /// DBF [16:16]
        /// DBF
        DBF: u1 = 1,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// master control register
    pub const MCR = Register(MCR_val).init(base_address + 0x0);

    /// MSR
    const MSR_val = packed struct {
        /// INAK [0:0]
        /// INAK
        INAK: u1 = 0,
        /// SLAK [1:1]
        /// SLAK
        SLAK: u1 = 1,
        /// ERRI [2:2]
        /// ERRI
        ERRI: u1 = 0,
        /// WKUI [3:3]
        /// WKUI
        WKUI: u1 = 0,
        /// SLAKI [4:4]
        /// SLAKI
        SLAKI: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// TXM [8:8]
        /// TXM
        TXM: u1 = 0,
        /// RXM [9:9]
        /// RXM
        RXM: u1 = 0,
        /// SAMP [10:10]
        /// SAMP
        SAMP: u1 = 1,
        /// RX [11:11]
        /// RX
        RX: u1 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// master status register
    pub const MSR = Register(MSR_val).init(base_address + 0x4);

    /// TSR
    const TSR_val = packed struct {
        /// RQCP0 [0:0]
        /// RQCP0
        RQCP0: u1 = 0,
        /// TXOK0 [1:1]
        /// TXOK0
        TXOK0: u1 = 0,
        /// ALST0 [2:2]
        /// ALST0
        ALST0: u1 = 0,
        /// TERR0 [3:3]
        /// TERR0
        TERR0: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ABRQ0 [7:7]
        /// ABRQ0
        ABRQ0: u1 = 0,
        /// RQCP1 [8:8]
        /// RQCP1
        RQCP1: u1 = 0,
        /// TXOK1 [9:9]
        /// TXOK1
        TXOK1: u1 = 0,
        /// ALST1 [10:10]
        /// ALST1
        ALST1: u1 = 0,
        /// TERR1 [11:11]
        /// TERR1
        TERR1: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ABRQ1 [15:15]
        /// ABRQ1
        ABRQ1: u1 = 0,
        /// RQCP2 [16:16]
        /// RQCP2
        RQCP2: u1 = 0,
        /// TXOK2 [17:17]
        /// TXOK2
        TXOK2: u1 = 0,
        /// ALST2 [18:18]
        /// ALST2
        ALST2: u1 = 0,
        /// TERR2 [19:19]
        /// TERR2
        TERR2: u1 = 0,
        /// unused [20:22]
        _unused20: u3 = 0,
        /// ABRQ2 [23:23]
        /// ABRQ2
        ABRQ2: u1 = 0,
        /// CODE [24:25]
        /// CODE
        CODE: u2 = 0,
        /// TME0 [26:26]
        /// Lowest priority flag for mailbox
        TME0: u1 = 1,
        /// TME1 [27:27]
        /// Lowest priority flag for mailbox
        TME1: u1 = 1,
        /// TME2 [28:28]
        /// Lowest priority flag for mailbox
        TME2: u1 = 1,
        /// LOW0 [29:29]
        /// Lowest priority flag for mailbox
        LOW0: u1 = 0,
        /// LOW1 [30:30]
        /// Lowest priority flag for mailbox
        LOW1: u1 = 0,
        /// LOW2 [31:31]
        /// Lowest priority flag for mailbox
        LOW2: u1 = 0,
    };
    /// transmit status register
    pub const TSR = Register(TSR_val).init(base_address + 0x8);

    /// RF0R
    const RF0R_val = packed struct {
        /// FMP0 [0:1]
        /// FMP0
        FMP0: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL0 [3:3]
        /// FULL0
        FULL0: u1 = 0,
        /// FOVR0 [4:4]
        /// FOVR0
        FOVR0: u1 = 0,
        /// RFOM0 [5:5]
        /// RFOM0
        RFOM0: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 0 register
    pub const RF0R = Register(RF0R_val).init(base_address + 0xc);

    /// RF1R
    const RF1R_val = packed struct {
        /// FMP1 [0:1]
        /// FMP1
        FMP1: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL1 [3:3]
        /// FULL1
        FULL1: u1 = 0,
        /// FOVR1 [4:4]
        /// FOVR1
        FOVR1: u1 = 0,
        /// RFOM1 [5:5]
        /// RFOM1
        RFOM1: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 1 register
    pub const RF1R = Register(RF1R_val).init(base_address + 0x10);

    /// IER
    const IER_val = packed struct {
        /// TMEIE [0:0]
        /// TMEIE
        TMEIE: u1 = 0,
        /// FMPIE0 [1:1]
        /// FMPIE0
        FMPIE0: u1 = 0,
        /// FFIE0 [2:2]
        /// FFIE0
        FFIE0: u1 = 0,
        /// FOVIE0 [3:3]
        /// FOVIE0
        FOVIE0: u1 = 0,
        /// FMPIE1 [4:4]
        /// FMPIE1
        FMPIE1: u1 = 0,
        /// FFIE1 [5:5]
        /// FFIE1
        FFIE1: u1 = 0,
        /// FOVIE1 [6:6]
        /// FOVIE1
        FOVIE1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EWGIE [8:8]
        /// EWGIE
        EWGIE: u1 = 0,
        /// EPVIE [9:9]
        /// EPVIE
        EPVIE: u1 = 0,
        /// BOFIE [10:10]
        /// BOFIE
        BOFIE: u1 = 0,
        /// LECIE [11:11]
        /// LECIE
        LECIE: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ERRIE [15:15]
        /// ERRIE
        ERRIE: u1 = 0,
        /// WKUIE [16:16]
        /// WKUIE
        WKUIE: u1 = 0,
        /// SLKIE [17:17]
        /// SLKIE
        SLKIE: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IER = Register(IER_val).init(base_address + 0x14);

    /// ESR
    const ESR_val = packed struct {
        /// EWGF [0:0]
        /// EWGF
        EWGF: u1 = 0,
        /// EPVF [1:1]
        /// EPVF
        EPVF: u1 = 0,
        /// BOFF [2:2]
        /// BOFF
        BOFF: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// LEC [4:6]
        /// LEC
        LEC: u3 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// TEC [16:23]
        /// TEC
        TEC: u8 = 0,
        /// REC [24:31]
        /// REC
        REC: u8 = 0,
    };
    /// interrupt enable register
    pub const ESR = Register(ESR_val).init(base_address + 0x18);

    /// BTR
    const BTR_val = packed struct {
        /// BRP [0:9]
        /// BRP
        BRP: u10 = 0,
        /// unused [10:15]
        _unused10: u6 = 0,
        /// TS1 [16:19]
        /// TS1
        TS1: u4 = 0,
        /// TS2 [20:22]
        /// TS2
        TS2: u3 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// SJW [24:25]
        /// SJW
        SJW: u2 = 0,
        /// unused [26:29]
        _unused26: u4 = 0,
        /// LBKM [30:30]
        /// LBKM
        LBKM: u1 = 0,
        /// SILM [31:31]
        /// SILM
        SILM: u1 = 0,
    };
    /// bit timing register
    pub const BTR = Register(BTR_val).init(base_address + 0x1c);

    /// TI0R
    const TI0R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// TX mailbox identifier register
    pub const TI0R = Register(TI0R_val).init(base_address + 0x180);

    /// TDT0R
    const TDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT0R = Register(TDT0R_val).init(base_address + 0x184);

    /// TDL0R
    const TDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL0R = Register(TDL0R_val).init(base_address + 0x188);

    /// TDH0R
    const TDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH0R = Register(TDH0R_val).init(base_address + 0x18c);

    /// TI1R
    const TI1R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI1R = Register(TI1R_val).init(base_address + 0x190);

    /// TDT1R
    const TDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT1R = Register(TDT1R_val).init(base_address + 0x194);

    /// TDL1R
    const TDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL1R = Register(TDL1R_val).init(base_address + 0x198);

    /// TDH1R
    const TDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH1R = Register(TDH1R_val).init(base_address + 0x19c);

    /// TI2R
    const TI2R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI2R = Register(TI2R_val).init(base_address + 0x1a0);

    /// TDT2R
    const TDT2R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT2R = Register(TDT2R_val).init(base_address + 0x1a4);

    /// TDL2R
    const TDL2R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL2R = Register(TDL2R_val).init(base_address + 0x1a8);

    /// TDH2R
    const TDH2R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH2R = Register(TDH2R_val).init(base_address + 0x1ac);

    /// RI0R
    const RI0R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// receive FIFO mailbox identifier
    pub const RI0R = Register(RI0R_val).init(base_address + 0x1b0);

    /// RDT0R
    const RDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT0R = Register(RDT0R_val).init(base_address + 0x1b4);

    /// RDL0R
    const RDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL0R = Register(RDL0R_val).init(base_address + 0x1b8);

    /// RDH0R
    const RDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// receive FIFO mailbox data high
    pub const RDH0R = Register(RDH0R_val).init(base_address + 0x1bc);

    /// RI1R
    const RI1R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox data high register
    pub const RI1R = Register(RI1R_val).init(base_address + 0x1c0);

    /// RDT1R
    const RDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT1R = Register(RDT1R_val).init(base_address + 0x1c4);

    /// RDL1R
    const RDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL1R = Register(RDL1R_val).init(base_address + 0x1c8);

    /// RDH1R
    const RDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const RDH1R = Register(RDH1R_val).init(base_address + 0x1cc);

    /// FMR
    const FMR_val = packed struct {
        /// FINIT [0:0]
        /// FINIT
        FINIT: u1 = 1,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// CAN2SB [8:13]
        /// CAN2SB
        CAN2SB: u6 = 14,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 28,
        _unused24: u8 = 42,
    };
    /// filter master register
    pub const FMR = Register(FMR_val).init(base_address + 0x200);

    /// FM1R
    const FM1R_val = packed struct {
        /// FBM0 [0:0]
        /// Filter mode
        FBM0: u1 = 0,
        /// FBM1 [1:1]
        /// Filter mode
        FBM1: u1 = 0,
        /// FBM2 [2:2]
        /// Filter mode
        FBM2: u1 = 0,
        /// FBM3 [3:3]
        /// Filter mode
        FBM3: u1 = 0,
        /// FBM4 [4:4]
        /// Filter mode
        FBM4: u1 = 0,
        /// FBM5 [5:5]
        /// Filter mode
        FBM5: u1 = 0,
        /// FBM6 [6:6]
        /// Filter mode
        FBM6: u1 = 0,
        /// FBM7 [7:7]
        /// Filter mode
        FBM7: u1 = 0,
        /// FBM8 [8:8]
        /// Filter mode
        FBM8: u1 = 0,
        /// FBM9 [9:9]
        /// Filter mode
        FBM9: u1 = 0,
        /// FBM10 [10:10]
        /// Filter mode
        FBM10: u1 = 0,
        /// FBM11 [11:11]
        /// Filter mode
        FBM11: u1 = 0,
        /// FBM12 [12:12]
        /// Filter mode
        FBM12: u1 = 0,
        /// FBM13 [13:13]
        /// Filter mode
        FBM13: u1 = 0,
        /// FBM14 [14:14]
        /// Filter mode
        FBM14: u1 = 0,
        /// FBM15 [15:15]
        /// Filter mode
        FBM15: u1 = 0,
        /// FBM16 [16:16]
        /// Filter mode
        FBM16: u1 = 0,
        /// FBM17 [17:17]
        /// Filter mode
        FBM17: u1 = 0,
        /// FBM18 [18:18]
        /// Filter mode
        FBM18: u1 = 0,
        /// FBM19 [19:19]
        /// Filter mode
        FBM19: u1 = 0,
        /// FBM20 [20:20]
        /// Filter mode
        FBM20: u1 = 0,
        /// FBM21 [21:21]
        /// Filter mode
        FBM21: u1 = 0,
        /// FBM22 [22:22]
        /// Filter mode
        FBM22: u1 = 0,
        /// FBM23 [23:23]
        /// Filter mode
        FBM23: u1 = 0,
        /// FBM24 [24:24]
        /// Filter mode
        FBM24: u1 = 0,
        /// FBM25 [25:25]
        /// Filter mode
        FBM25: u1 = 0,
        /// FBM26 [26:26]
        /// Filter mode
        FBM26: u1 = 0,
        /// FBM27 [27:27]
        /// Filter mode
        FBM27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter mode register
    pub const FM1R = Register(FM1R_val).init(base_address + 0x204);

    /// FS1R
    const FS1R_val = packed struct {
        /// FSC0 [0:0]
        /// Filter scale configuration
        FSC0: u1 = 0,
        /// FSC1 [1:1]
        /// Filter scale configuration
        FSC1: u1 = 0,
        /// FSC2 [2:2]
        /// Filter scale configuration
        FSC2: u1 = 0,
        /// FSC3 [3:3]
        /// Filter scale configuration
        FSC3: u1 = 0,
        /// FSC4 [4:4]
        /// Filter scale configuration
        FSC4: u1 = 0,
        /// FSC5 [5:5]
        /// Filter scale configuration
        FSC5: u1 = 0,
        /// FSC6 [6:6]
        /// Filter scale configuration
        FSC6: u1 = 0,
        /// FSC7 [7:7]
        /// Filter scale configuration
        FSC7: u1 = 0,
        /// FSC8 [8:8]
        /// Filter scale configuration
        FSC8: u1 = 0,
        /// FSC9 [9:9]
        /// Filter scale configuration
        FSC9: u1 = 0,
        /// FSC10 [10:10]
        /// Filter scale configuration
        FSC10: u1 = 0,
        /// FSC11 [11:11]
        /// Filter scale configuration
        FSC11: u1 = 0,
        /// FSC12 [12:12]
        /// Filter scale configuration
        FSC12: u1 = 0,
        /// FSC13 [13:13]
        /// Filter scale configuration
        FSC13: u1 = 0,
        /// FSC14 [14:14]
        /// Filter scale configuration
        FSC14: u1 = 0,
        /// FSC15 [15:15]
        /// Filter scale configuration
        FSC15: u1 = 0,
        /// FSC16 [16:16]
        /// Filter scale configuration
        FSC16: u1 = 0,
        /// FSC17 [17:17]
        /// Filter scale configuration
        FSC17: u1 = 0,
        /// FSC18 [18:18]
        /// Filter scale configuration
        FSC18: u1 = 0,
        /// FSC19 [19:19]
        /// Filter scale configuration
        FSC19: u1 = 0,
        /// FSC20 [20:20]
        /// Filter scale configuration
        FSC20: u1 = 0,
        /// FSC21 [21:21]
        /// Filter scale configuration
        FSC21: u1 = 0,
        /// FSC22 [22:22]
        /// Filter scale configuration
        FSC22: u1 = 0,
        /// FSC23 [23:23]
        /// Filter scale configuration
        FSC23: u1 = 0,
        /// FSC24 [24:24]
        /// Filter scale configuration
        FSC24: u1 = 0,
        /// FSC25 [25:25]
        /// Filter scale configuration
        FSC25: u1 = 0,
        /// FSC26 [26:26]
        /// Filter scale configuration
        FSC26: u1 = 0,
        /// FSC27 [27:27]
        /// Filter scale configuration
        FSC27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter scale register
    pub const FS1R = Register(FS1R_val).init(base_address + 0x20c);

    /// FFA1R
    const FFA1R_val = packed struct {
        /// FFA0 [0:0]
        /// Filter FIFO assignment for filter
        FFA0: u1 = 0,
        /// FFA1 [1:1]
        /// Filter FIFO assignment for filter
        FFA1: u1 = 0,
        /// FFA2 [2:2]
        /// Filter FIFO assignment for filter
        FFA2: u1 = 0,
        /// FFA3 [3:3]
        /// Filter FIFO assignment for filter
        FFA3: u1 = 0,
        /// FFA4 [4:4]
        /// Filter FIFO assignment for filter
        FFA4: u1 = 0,
        /// FFA5 [5:5]
        /// Filter FIFO assignment for filter
        FFA5: u1 = 0,
        /// FFA6 [6:6]
        /// Filter FIFO assignment for filter
        FFA6: u1 = 0,
        /// FFA7 [7:7]
        /// Filter FIFO assignment for filter
        FFA7: u1 = 0,
        /// FFA8 [8:8]
        /// Filter FIFO assignment for filter
        FFA8: u1 = 0,
        /// FFA9 [9:9]
        /// Filter FIFO assignment for filter
        FFA9: u1 = 0,
        /// FFA10 [10:10]
        /// Filter FIFO assignment for filter
        FFA10: u1 = 0,
        /// FFA11 [11:11]
        /// Filter FIFO assignment for filter
        FFA11: u1 = 0,
        /// FFA12 [12:12]
        /// Filter FIFO assignment for filter
        FFA12: u1 = 0,
        /// FFA13 [13:13]
        /// Filter FIFO assignment for filter
        FFA13: u1 = 0,
        /// FFA14 [14:14]
        /// Filter FIFO assignment for filter
        FFA14: u1 = 0,
        /// FFA15 [15:15]
        /// Filter FIFO assignment for filter
        FFA15: u1 = 0,
        /// FFA16 [16:16]
        /// Filter FIFO assignment for filter
        FFA16: u1 = 0,
        /// FFA17 [17:17]
        /// Filter FIFO assignment for filter
        FFA17: u1 = 0,
        /// FFA18 [18:18]
        /// Filter FIFO assignment for filter
        FFA18: u1 = 0,
        /// FFA19 [19:19]
        /// Filter FIFO assignment for filter
        FFA19: u1 = 0,
        /// FFA20 [20:20]
        /// Filter FIFO assignment for filter
        FFA20: u1 = 0,
        /// FFA21 [21:21]
        /// Filter FIFO assignment for filter
        FFA21: u1 = 0,
        /// FFA22 [22:22]
        /// Filter FIFO assignment for filter
        FFA22: u1 = 0,
        /// FFA23 [23:23]
        /// Filter FIFO assignment for filter
        FFA23: u1 = 0,
        /// FFA24 [24:24]
        /// Filter FIFO assignment for filter
        FFA24: u1 = 0,
        /// FFA25 [25:25]
        /// Filter FIFO assignment for filter
        FFA25: u1 = 0,
        /// FFA26 [26:26]
        /// Filter FIFO assignment for filter
        FFA26: u1 = 0,
        /// FFA27 [27:27]
        /// Filter FIFO assignment for filter
        FFA27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter FIFO assignment
    pub const FFA1R = Register(FFA1R_val).init(base_address + 0x214);

    /// FA1R
    const FA1R_val = packed struct {
        /// FACT0 [0:0]
        /// Filter active
        FACT0: u1 = 0,
        /// FACT1 [1:1]
        /// Filter active
        FACT1: u1 = 0,
        /// FACT2 [2:2]
        /// Filter active
        FACT2: u1 = 0,
        /// FACT3 [3:3]
        /// Filter active
        FACT3: u1 = 0,
        /// FACT4 [4:4]
        /// Filter active
        FACT4: u1 = 0,
        /// FACT5 [5:5]
        /// Filter active
        FACT5: u1 = 0,
        /// FACT6 [6:6]
        /// Filter active
        FACT6: u1 = 0,
        /// FACT7 [7:7]
        /// Filter active
        FACT7: u1 = 0,
        /// FACT8 [8:8]
        /// Filter active
        FACT8: u1 = 0,
        /// FACT9 [9:9]
        /// Filter active
        FACT9: u1 = 0,
        /// FACT10 [10:10]
        /// Filter active
        FACT10: u1 = 0,
        /// FACT11 [11:11]
        /// Filter active
        FACT11: u1 = 0,
        /// FACT12 [12:12]
        /// Filter active
        FACT12: u1 = 0,
        /// FACT13 [13:13]
        /// Filter active
        FACT13: u1 = 0,
        /// FACT14 [14:14]
        /// Filter active
        FACT14: u1 = 0,
        /// FACT15 [15:15]
        /// Filter active
        FACT15: u1 = 0,
        /// FACT16 [16:16]
        /// Filter active
        FACT16: u1 = 0,
        /// FACT17 [17:17]
        /// Filter active
        FACT17: u1 = 0,
        /// FACT18 [18:18]
        /// Filter active
        FACT18: u1 = 0,
        /// FACT19 [19:19]
        /// Filter active
        FACT19: u1 = 0,
        /// FACT20 [20:20]
        /// Filter active
        FACT20: u1 = 0,
        /// FACT21 [21:21]
        /// Filter active
        FACT21: u1 = 0,
        /// FACT22 [22:22]
        /// Filter active
        FACT22: u1 = 0,
        /// FACT23 [23:23]
        /// Filter active
        FACT23: u1 = 0,
        /// FACT24 [24:24]
        /// Filter active
        FACT24: u1 = 0,
        /// FACT25 [25:25]
        /// Filter active
        FACT25: u1 = 0,
        /// FACT26 [26:26]
        /// Filter active
        FACT26: u1 = 0,
        /// FACT27 [27:27]
        /// Filter active
        FACT27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter activation register
    pub const FA1R = Register(FA1R_val).init(base_address + 0x21c);

    /// F0R1
    const F0R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 1
    pub const F0R1 = Register(F0R1_val).init(base_address + 0x240);

    /// F0R2
    const F0R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 2
    pub const F0R2 = Register(F0R2_val).init(base_address + 0x244);

    /// F1R1
    const F1R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 1
    pub const F1R1 = Register(F1R1_val).init(base_address + 0x248);

    /// F1R2
    const F1R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 2
    pub const F1R2 = Register(F1R2_val).init(base_address + 0x24c);

    /// F2R1
    const F2R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 1
    pub const F2R1 = Register(F2R1_val).init(base_address + 0x250);

    /// F2R2
    const F2R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 2
    pub const F2R2 = Register(F2R2_val).init(base_address + 0x254);

    /// F3R1
    const F3R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 1
    pub const F3R1 = Register(F3R1_val).init(base_address + 0x258);

    /// F3R2
    const F3R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 2
    pub const F3R2 = Register(F3R2_val).init(base_address + 0x25c);

    /// F4R1
    const F4R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F4R1 = Register(F4R1_val).init(base_address + 0x260);

    /// F4R2
    const F4R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 2
    pub const F4R2 = Register(F4R2_val).init(base_address + 0x264);

    /// F5R1
    const F5R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 1
    pub const F5R1 = Register(F5R1_val).init(base_address + 0x268);

    /// F5R2
    const F5R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 2
    pub const F5R2 = Register(F5R2_val).init(base_address + 0x26c);

    /// F6R1
    const F6R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 1
    pub const F6R1 = Register(F6R1_val).init(base_address + 0x270);

    /// F6R2
    const F6R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 2
    pub const F6R2 = Register(F6R2_val).init(base_address + 0x274);

    /// F7R1
    const F7R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 1
    pub const F7R1 = Register(F7R1_val).init(base_address + 0x278);

    /// F7R2
    const F7R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 2
    pub const F7R2 = Register(F7R2_val).init(base_address + 0x27c);

    /// F8R1
    const F8R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 1
    pub const F8R1 = Register(F8R1_val).init(base_address + 0x280);

    /// F8R2
    const F8R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 2
    pub const F8R2 = Register(F8R2_val).init(base_address + 0x284);

    /// F9R1
    const F9R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 1
    pub const F9R1 = Register(F9R1_val).init(base_address + 0x288);

    /// F9R2
    const F9R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 2
    pub const F9R2 = Register(F9R2_val).init(base_address + 0x28c);

    /// F10R1
    const F10R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 1
    pub const F10R1 = Register(F10R1_val).init(base_address + 0x290);

    /// F10R2
    const F10R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 2
    pub const F10R2 = Register(F10R2_val).init(base_address + 0x294);

    /// F11R1
    const F11R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 1
    pub const F11R1 = Register(F11R1_val).init(base_address + 0x298);

    /// F11R2
    const F11R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 2
    pub const F11R2 = Register(F11R2_val).init(base_address + 0x29c);

    /// F12R1
    const F12R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F12R1 = Register(F12R1_val).init(base_address + 0x2a0);

    /// F12R2
    const F12R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 12 register 2
    pub const F12R2 = Register(F12R2_val).init(base_address + 0x2a4);

    /// F13R1
    const F13R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 1
    pub const F13R1 = Register(F13R1_val).init(base_address + 0x2a8);

    /// F13R2
    const F13R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 2
    pub const F13R2 = Register(F13R2_val).init(base_address + 0x2ac);

    /// F14R1
    const F14R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 1
    pub const F14R1 = Register(F14R1_val).init(base_address + 0x2b0);

    /// F14R2
    const F14R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 2
    pub const F14R2 = Register(F14R2_val).init(base_address + 0x2b4);

    /// F15R1
    const F15R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 1
    pub const F15R1 = Register(F15R1_val).init(base_address + 0x2b8);

    /// F15R2
    const F15R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 2
    pub const F15R2 = Register(F15R2_val).init(base_address + 0x2bc);

    /// F16R1
    const F16R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 1
    pub const F16R1 = Register(F16R1_val).init(base_address + 0x2c0);

    /// F16R2
    const F16R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 2
    pub const F16R2 = Register(F16R2_val).init(base_address + 0x2c4);

    /// F17R1
    const F17R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 1
    pub const F17R1 = Register(F17R1_val).init(base_address + 0x2c8);

    /// F17R2
    const F17R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 2
    pub const F17R2 = Register(F17R2_val).init(base_address + 0x2cc);

    /// F18R1
    const F18R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 1
    pub const F18R1 = Register(F18R1_val).init(base_address + 0x2d0);

    /// F18R2
    const F18R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 2
    pub const F18R2 = Register(F18R2_val).init(base_address + 0x2d4);

    /// F19R1
    const F19R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 1
    pub const F19R1 = Register(F19R1_val).init(base_address + 0x2d8);

    /// F19R2
    const F19R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 2
    pub const F19R2 = Register(F19R2_val).init(base_address + 0x2dc);

    /// F20R1
    const F20R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 1
    pub const F20R1 = Register(F20R1_val).init(base_address + 0x2e0);

    /// F20R2
    const F20R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 2
    pub const F20R2 = Register(F20R2_val).init(base_address + 0x2e4);

    /// F21R1
    const F21R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 1
    pub const F21R1 = Register(F21R1_val).init(base_address + 0x2e8);

    /// F21R2
    const F21R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 2
    pub const F21R2 = Register(F21R2_val).init(base_address + 0x2ec);

    /// F22R1
    const F22R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 1
    pub const F22R1 = Register(F22R1_val).init(base_address + 0x2f0);

    /// F22R2
    const F22R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 2
    pub const F22R2 = Register(F22R2_val).init(base_address + 0x2f4);

    /// F23R1
    const F23R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 1
    pub const F23R1 = Register(F23R1_val).init(base_address + 0x2f8);

    /// F23R2
    const F23R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 2
    pub const F23R2 = Register(F23R2_val).init(base_address + 0x2fc);

    /// F24R1
    const F24R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 1
    pub const F24R1 = Register(F24R1_val).init(base_address + 0x300);

    /// F24R2
    const F24R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 2
    pub const F24R2 = Register(F24R2_val).init(base_address + 0x304);

    /// F25R1
    const F25R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 1
    pub const F25R1 = Register(F25R1_val).init(base_address + 0x308);

    /// F25R2
    const F25R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 2
    pub const F25R2 = Register(F25R2_val).init(base_address + 0x30c);

    /// F26R1
    const F26R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 1
    pub const F26R1 = Register(F26R1_val).init(base_address + 0x310);

    /// F26R2
    const F26R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 2
    pub const F26R2 = Register(F26R2_val).init(base_address + 0x314);

    /// F27R1
    const F27R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 1
    pub const F27R1 = Register(F27R1_val).init(base_address + 0x318);

    /// F27R2
    const F27R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 2
    pub const F27R2 = Register(F27R2_val).init(base_address + 0x31c);
};

/// Controller area network
pub const CAN3 = struct {
    const base_address = 0x40003400;
    /// MCR
    const MCR_val = packed struct {
        /// INRQ [0:0]
        /// INRQ
        INRQ: u1 = 0,
        /// SLEEP [1:1]
        /// SLEEP
        SLEEP: u1 = 1,
        /// TXFP [2:2]
        /// TXFP
        TXFP: u1 = 0,
        /// RFLM [3:3]
        /// RFLM
        RFLM: u1 = 0,
        /// NART [4:4]
        /// NART
        NART: u1 = 0,
        /// AWUM [5:5]
        /// AWUM
        AWUM: u1 = 0,
        /// ABOM [6:6]
        /// ABOM
        ABOM: u1 = 0,
        /// TTCM [7:7]
        /// TTCM
        TTCM: u1 = 0,
        /// unused [8:14]
        _unused8: u7 = 0,
        /// RESET [15:15]
        /// RESET
        RESET: u1 = 0,
        /// DBF [16:16]
        /// DBF
        DBF: u1 = 1,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// master control register
    pub const MCR = Register(MCR_val).init(base_address + 0x0);

    /// MSR
    const MSR_val = packed struct {
        /// INAK [0:0]
        /// INAK
        INAK: u1 = 0,
        /// SLAK [1:1]
        /// SLAK
        SLAK: u1 = 1,
        /// ERRI [2:2]
        /// ERRI
        ERRI: u1 = 0,
        /// WKUI [3:3]
        /// WKUI
        WKUI: u1 = 0,
        /// SLAKI [4:4]
        /// SLAKI
        SLAKI: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// TXM [8:8]
        /// TXM
        TXM: u1 = 0,
        /// RXM [9:9]
        /// RXM
        RXM: u1 = 0,
        /// SAMP [10:10]
        /// SAMP
        SAMP: u1 = 1,
        /// RX [11:11]
        /// RX
        RX: u1 = 1,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// master status register
    pub const MSR = Register(MSR_val).init(base_address + 0x4);

    /// TSR
    const TSR_val = packed struct {
        /// RQCP0 [0:0]
        /// RQCP0
        RQCP0: u1 = 0,
        /// TXOK0 [1:1]
        /// TXOK0
        TXOK0: u1 = 0,
        /// ALST0 [2:2]
        /// ALST0
        ALST0: u1 = 0,
        /// TERR0 [3:3]
        /// TERR0
        TERR0: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// ABRQ0 [7:7]
        /// ABRQ0
        ABRQ0: u1 = 0,
        /// RQCP1 [8:8]
        /// RQCP1
        RQCP1: u1 = 0,
        /// TXOK1 [9:9]
        /// TXOK1
        TXOK1: u1 = 0,
        /// ALST1 [10:10]
        /// ALST1
        ALST1: u1 = 0,
        /// TERR1 [11:11]
        /// TERR1
        TERR1: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ABRQ1 [15:15]
        /// ABRQ1
        ABRQ1: u1 = 0,
        /// RQCP2 [16:16]
        /// RQCP2
        RQCP2: u1 = 0,
        /// TXOK2 [17:17]
        /// TXOK2
        TXOK2: u1 = 0,
        /// ALST2 [18:18]
        /// ALST2
        ALST2: u1 = 0,
        /// TERR2 [19:19]
        /// TERR2
        TERR2: u1 = 0,
        /// unused [20:22]
        _unused20: u3 = 0,
        /// ABRQ2 [23:23]
        /// ABRQ2
        ABRQ2: u1 = 0,
        /// CODE [24:25]
        /// CODE
        CODE: u2 = 0,
        /// TME0 [26:26]
        /// Lowest priority flag for mailbox
        TME0: u1 = 1,
        /// TME1 [27:27]
        /// Lowest priority flag for mailbox
        TME1: u1 = 1,
        /// TME2 [28:28]
        /// Lowest priority flag for mailbox
        TME2: u1 = 1,
        /// LOW0 [29:29]
        /// Lowest priority flag for mailbox
        LOW0: u1 = 0,
        /// LOW1 [30:30]
        /// Lowest priority flag for mailbox
        LOW1: u1 = 0,
        /// LOW2 [31:31]
        /// Lowest priority flag for mailbox
        LOW2: u1 = 0,
    };
    /// transmit status register
    pub const TSR = Register(TSR_val).init(base_address + 0x8);

    /// RF0R
    const RF0R_val = packed struct {
        /// FMP0 [0:1]
        /// FMP0
        FMP0: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL0 [3:3]
        /// FULL0
        FULL0: u1 = 0,
        /// FOVR0 [4:4]
        /// FOVR0
        FOVR0: u1 = 0,
        /// RFOM0 [5:5]
        /// RFOM0
        RFOM0: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 0 register
    pub const RF0R = Register(RF0R_val).init(base_address + 0xc);

    /// RF1R
    const RF1R_val = packed struct {
        /// FMP1 [0:1]
        /// FMP1
        FMP1: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// FULL1 [3:3]
        /// FULL1
        FULL1: u1 = 0,
        /// FOVR1 [4:4]
        /// FOVR1
        FOVR1: u1 = 0,
        /// RFOM1 [5:5]
        /// RFOM1
        RFOM1: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// receive FIFO 1 register
    pub const RF1R = Register(RF1R_val).init(base_address + 0x10);

    /// IER
    const IER_val = packed struct {
        /// TMEIE [0:0]
        /// TMEIE
        TMEIE: u1 = 0,
        /// FMPIE0 [1:1]
        /// FMPIE0
        FMPIE0: u1 = 0,
        /// FFIE0 [2:2]
        /// FFIE0
        FFIE0: u1 = 0,
        /// FOVIE0 [3:3]
        /// FOVIE0
        FOVIE0: u1 = 0,
        /// FMPIE1 [4:4]
        /// FMPIE1
        FMPIE1: u1 = 0,
        /// FFIE1 [5:5]
        /// FFIE1
        FFIE1: u1 = 0,
        /// FOVIE1 [6:6]
        /// FOVIE1
        FOVIE1: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EWGIE [8:8]
        /// EWGIE
        EWGIE: u1 = 0,
        /// EPVIE [9:9]
        /// EPVIE
        EPVIE: u1 = 0,
        /// BOFIE [10:10]
        /// BOFIE
        BOFIE: u1 = 0,
        /// LECIE [11:11]
        /// LECIE
        LECIE: u1 = 0,
        /// unused [12:14]
        _unused12: u3 = 0,
        /// ERRIE [15:15]
        /// ERRIE
        ERRIE: u1 = 0,
        /// WKUIE [16:16]
        /// WKUIE
        WKUIE: u1 = 0,
        /// SLKIE [17:17]
        /// SLKIE
        SLKIE: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IER = Register(IER_val).init(base_address + 0x14);

    /// ESR
    const ESR_val = packed struct {
        /// EWGF [0:0]
        /// EWGF
        EWGF: u1 = 0,
        /// EPVF [1:1]
        /// EPVF
        EPVF: u1 = 0,
        /// BOFF [2:2]
        /// BOFF
        BOFF: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// LEC [4:6]
        /// LEC
        LEC: u3 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// TEC [16:23]
        /// TEC
        TEC: u8 = 0,
        /// REC [24:31]
        /// REC
        REC: u8 = 0,
    };
    /// interrupt enable register
    pub const ESR = Register(ESR_val).init(base_address + 0x18);

    /// BTR
    const BTR_val = packed struct {
        /// BRP [0:9]
        /// BRP
        BRP: u10 = 0,
        /// unused [10:15]
        _unused10: u6 = 0,
        /// TS1 [16:19]
        /// TS1
        TS1: u4 = 0,
        /// TS2 [20:22]
        /// TS2
        TS2: u3 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// SJW [24:25]
        /// SJW
        SJW: u2 = 0,
        /// unused [26:29]
        _unused26: u4 = 0,
        /// LBKM [30:30]
        /// LBKM
        LBKM: u1 = 0,
        /// SILM [31:31]
        /// SILM
        SILM: u1 = 0,
    };
    /// bit timing register
    pub const BTR = Register(BTR_val).init(base_address + 0x1c);

    /// TI0R
    const TI0R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// TX mailbox identifier register
    pub const TI0R = Register(TI0R_val).init(base_address + 0x180);

    /// TDT0R
    const TDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT0R = Register(TDT0R_val).init(base_address + 0x184);

    /// TDL0R
    const TDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL0R = Register(TDL0R_val).init(base_address + 0x188);

    /// TDH0R
    const TDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH0R = Register(TDH0R_val).init(base_address + 0x18c);

    /// TI1R
    const TI1R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI1R = Register(TI1R_val).init(base_address + 0x190);

    /// TDT1R
    const TDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT1R = Register(TDT1R_val).init(base_address + 0x194);

    /// TDL1R
    const TDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL1R = Register(TDL1R_val).init(base_address + 0x198);

    /// TDH1R
    const TDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH1R = Register(TDH1R_val).init(base_address + 0x19c);

    /// TI2R
    const TI2R_val = packed struct {
        /// TXRQ [0:0]
        /// TXRQ
        TXRQ: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox identifier register
    pub const TI2R = Register(TI2R_val).init(base_address + 0x1a0);

    /// TDT2R
    const TDT2R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// TGT [8:8]
        /// TGT
        TGT: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data length control and time stamp
    pub const TDT2R = Register(TDT2R_val).init(base_address + 0x1a4);

    /// TDL2R
    const TDL2R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data low register
    pub const TDL2R = Register(TDL2R_val).init(base_address + 0x1a8);

    /// TDH2R
    const TDH2R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const TDH2R = Register(TDH2R_val).init(base_address + 0x1ac);

    /// RI0R
    const RI0R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// receive FIFO mailbox identifier
    pub const RI0R = Register(RI0R_val).init(base_address + 0x1b0);

    /// RDT0R
    const RDT0R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT0R = Register(RDT0R_val).init(base_address + 0x1b4);

    /// RDL0R
    const RDL0R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL0R = Register(RDL0R_val).init(base_address + 0x1b8);

    /// RDH0R
    const RDH0R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// receive FIFO mailbox data high
    pub const RDH0R = Register(RDH0R_val).init(base_address + 0x1bc);

    /// RI1R
    const RI1R_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// RTR [1:1]
        /// RTR
        RTR: u1 = 0,
        /// IDE [2:2]
        /// IDE
        IDE: u1 = 0,
        /// EXID [3:20]
        /// EXID
        EXID: u18 = 0,
        /// STID [21:31]
        /// STID
        STID: u11 = 0,
    };
    /// mailbox data high register
    pub const RI1R = Register(RI1R_val).init(base_address + 0x1c0);

    /// RDT1R
    const RDT1R_val = packed struct {
        /// DLC [0:3]
        /// DLC
        DLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// FMI [8:15]
        /// FMI
        FMI: u8 = 0,
        /// TIME [16:31]
        /// TIME
        TIME: u16 = 0,
    };
    /// mailbox data high register
    pub const RDT1R = Register(RDT1R_val).init(base_address + 0x1c4);

    /// RDL1R
    const RDL1R_val = packed struct {
        /// DATA0 [0:7]
        /// DATA0
        DATA0: u8 = 0,
        /// DATA1 [8:15]
        /// DATA1
        DATA1: u8 = 0,
        /// DATA2 [16:23]
        /// DATA2
        DATA2: u8 = 0,
        /// DATA3 [24:31]
        /// DATA3
        DATA3: u8 = 0,
    };
    /// mailbox data high register
    pub const RDL1R = Register(RDL1R_val).init(base_address + 0x1c8);

    /// RDH1R
    const RDH1R_val = packed struct {
        /// DATA4 [0:7]
        /// DATA4
        DATA4: u8 = 0,
        /// DATA5 [8:15]
        /// DATA5
        DATA5: u8 = 0,
        /// DATA6 [16:23]
        /// DATA6
        DATA6: u8 = 0,
        /// DATA7 [24:31]
        /// DATA7
        DATA7: u8 = 0,
    };
    /// mailbox data high register
    pub const RDH1R = Register(RDH1R_val).init(base_address + 0x1cc);

    /// FMR
    const FMR_val = packed struct {
        /// FINIT [0:0]
        /// FINIT
        FINIT: u1 = 1,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// CAN2SB [8:13]
        /// CAN2SB
        CAN2SB: u6 = 14,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 28,
        _unused24: u8 = 42,
    };
    /// filter master register
    pub const FMR = Register(FMR_val).init(base_address + 0x200);

    /// FM1R
    const FM1R_val = packed struct {
        /// FBM0 [0:0]
        /// Filter mode
        FBM0: u1 = 0,
        /// FBM1 [1:1]
        /// Filter mode
        FBM1: u1 = 0,
        /// FBM2 [2:2]
        /// Filter mode
        FBM2: u1 = 0,
        /// FBM3 [3:3]
        /// Filter mode
        FBM3: u1 = 0,
        /// FBM4 [4:4]
        /// Filter mode
        FBM4: u1 = 0,
        /// FBM5 [5:5]
        /// Filter mode
        FBM5: u1 = 0,
        /// FBM6 [6:6]
        /// Filter mode
        FBM6: u1 = 0,
        /// FBM7 [7:7]
        /// Filter mode
        FBM7: u1 = 0,
        /// FBM8 [8:8]
        /// Filter mode
        FBM8: u1 = 0,
        /// FBM9 [9:9]
        /// Filter mode
        FBM9: u1 = 0,
        /// FBM10 [10:10]
        /// Filter mode
        FBM10: u1 = 0,
        /// FBM11 [11:11]
        /// Filter mode
        FBM11: u1 = 0,
        /// FBM12 [12:12]
        /// Filter mode
        FBM12: u1 = 0,
        /// FBM13 [13:13]
        /// Filter mode
        FBM13: u1 = 0,
        /// FBM14 [14:14]
        /// Filter mode
        FBM14: u1 = 0,
        /// FBM15 [15:15]
        /// Filter mode
        FBM15: u1 = 0,
        /// FBM16 [16:16]
        /// Filter mode
        FBM16: u1 = 0,
        /// FBM17 [17:17]
        /// Filter mode
        FBM17: u1 = 0,
        /// FBM18 [18:18]
        /// Filter mode
        FBM18: u1 = 0,
        /// FBM19 [19:19]
        /// Filter mode
        FBM19: u1 = 0,
        /// FBM20 [20:20]
        /// Filter mode
        FBM20: u1 = 0,
        /// FBM21 [21:21]
        /// Filter mode
        FBM21: u1 = 0,
        /// FBM22 [22:22]
        /// Filter mode
        FBM22: u1 = 0,
        /// FBM23 [23:23]
        /// Filter mode
        FBM23: u1 = 0,
        /// FBM24 [24:24]
        /// Filter mode
        FBM24: u1 = 0,
        /// FBM25 [25:25]
        /// Filter mode
        FBM25: u1 = 0,
        /// FBM26 [26:26]
        /// Filter mode
        FBM26: u1 = 0,
        /// FBM27 [27:27]
        /// Filter mode
        FBM27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter mode register
    pub const FM1R = Register(FM1R_val).init(base_address + 0x204);

    /// FS1R
    const FS1R_val = packed struct {
        /// FSC0 [0:0]
        /// Filter scale configuration
        FSC0: u1 = 0,
        /// FSC1 [1:1]
        /// Filter scale configuration
        FSC1: u1 = 0,
        /// FSC2 [2:2]
        /// Filter scale configuration
        FSC2: u1 = 0,
        /// FSC3 [3:3]
        /// Filter scale configuration
        FSC3: u1 = 0,
        /// FSC4 [4:4]
        /// Filter scale configuration
        FSC4: u1 = 0,
        /// FSC5 [5:5]
        /// Filter scale configuration
        FSC5: u1 = 0,
        /// FSC6 [6:6]
        /// Filter scale configuration
        FSC6: u1 = 0,
        /// FSC7 [7:7]
        /// Filter scale configuration
        FSC7: u1 = 0,
        /// FSC8 [8:8]
        /// Filter scale configuration
        FSC8: u1 = 0,
        /// FSC9 [9:9]
        /// Filter scale configuration
        FSC9: u1 = 0,
        /// FSC10 [10:10]
        /// Filter scale configuration
        FSC10: u1 = 0,
        /// FSC11 [11:11]
        /// Filter scale configuration
        FSC11: u1 = 0,
        /// FSC12 [12:12]
        /// Filter scale configuration
        FSC12: u1 = 0,
        /// FSC13 [13:13]
        /// Filter scale configuration
        FSC13: u1 = 0,
        /// FSC14 [14:14]
        /// Filter scale configuration
        FSC14: u1 = 0,
        /// FSC15 [15:15]
        /// Filter scale configuration
        FSC15: u1 = 0,
        /// FSC16 [16:16]
        /// Filter scale configuration
        FSC16: u1 = 0,
        /// FSC17 [17:17]
        /// Filter scale configuration
        FSC17: u1 = 0,
        /// FSC18 [18:18]
        /// Filter scale configuration
        FSC18: u1 = 0,
        /// FSC19 [19:19]
        /// Filter scale configuration
        FSC19: u1 = 0,
        /// FSC20 [20:20]
        /// Filter scale configuration
        FSC20: u1 = 0,
        /// FSC21 [21:21]
        /// Filter scale configuration
        FSC21: u1 = 0,
        /// FSC22 [22:22]
        /// Filter scale configuration
        FSC22: u1 = 0,
        /// FSC23 [23:23]
        /// Filter scale configuration
        FSC23: u1 = 0,
        /// FSC24 [24:24]
        /// Filter scale configuration
        FSC24: u1 = 0,
        /// FSC25 [25:25]
        /// Filter scale configuration
        FSC25: u1 = 0,
        /// FSC26 [26:26]
        /// Filter scale configuration
        FSC26: u1 = 0,
        /// FSC27 [27:27]
        /// Filter scale configuration
        FSC27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter scale register
    pub const FS1R = Register(FS1R_val).init(base_address + 0x20c);

    /// FFA1R
    const FFA1R_val = packed struct {
        /// FFA0 [0:0]
        /// Filter FIFO assignment for filter
        FFA0: u1 = 0,
        /// FFA1 [1:1]
        /// Filter FIFO assignment for filter
        FFA1: u1 = 0,
        /// FFA2 [2:2]
        /// Filter FIFO assignment for filter
        FFA2: u1 = 0,
        /// FFA3 [3:3]
        /// Filter FIFO assignment for filter
        FFA3: u1 = 0,
        /// FFA4 [4:4]
        /// Filter FIFO assignment for filter
        FFA4: u1 = 0,
        /// FFA5 [5:5]
        /// Filter FIFO assignment for filter
        FFA5: u1 = 0,
        /// FFA6 [6:6]
        /// Filter FIFO assignment for filter
        FFA6: u1 = 0,
        /// FFA7 [7:7]
        /// Filter FIFO assignment for filter
        FFA7: u1 = 0,
        /// FFA8 [8:8]
        /// Filter FIFO assignment for filter
        FFA8: u1 = 0,
        /// FFA9 [9:9]
        /// Filter FIFO assignment for filter
        FFA9: u1 = 0,
        /// FFA10 [10:10]
        /// Filter FIFO assignment for filter
        FFA10: u1 = 0,
        /// FFA11 [11:11]
        /// Filter FIFO assignment for filter
        FFA11: u1 = 0,
        /// FFA12 [12:12]
        /// Filter FIFO assignment for filter
        FFA12: u1 = 0,
        /// FFA13 [13:13]
        /// Filter FIFO assignment for filter
        FFA13: u1 = 0,
        /// FFA14 [14:14]
        /// Filter FIFO assignment for filter
        FFA14: u1 = 0,
        /// FFA15 [15:15]
        /// Filter FIFO assignment for filter
        FFA15: u1 = 0,
        /// FFA16 [16:16]
        /// Filter FIFO assignment for filter
        FFA16: u1 = 0,
        /// FFA17 [17:17]
        /// Filter FIFO assignment for filter
        FFA17: u1 = 0,
        /// FFA18 [18:18]
        /// Filter FIFO assignment for filter
        FFA18: u1 = 0,
        /// FFA19 [19:19]
        /// Filter FIFO assignment for filter
        FFA19: u1 = 0,
        /// FFA20 [20:20]
        /// Filter FIFO assignment for filter
        FFA20: u1 = 0,
        /// FFA21 [21:21]
        /// Filter FIFO assignment for filter
        FFA21: u1 = 0,
        /// FFA22 [22:22]
        /// Filter FIFO assignment for filter
        FFA22: u1 = 0,
        /// FFA23 [23:23]
        /// Filter FIFO assignment for filter
        FFA23: u1 = 0,
        /// FFA24 [24:24]
        /// Filter FIFO assignment for filter
        FFA24: u1 = 0,
        /// FFA25 [25:25]
        /// Filter FIFO assignment for filter
        FFA25: u1 = 0,
        /// FFA26 [26:26]
        /// Filter FIFO assignment for filter
        FFA26: u1 = 0,
        /// FFA27 [27:27]
        /// Filter FIFO assignment for filter
        FFA27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter FIFO assignment
    pub const FFA1R = Register(FFA1R_val).init(base_address + 0x214);

    /// FA1R
    const FA1R_val = packed struct {
        /// FACT0 [0:0]
        /// Filter active
        FACT0: u1 = 0,
        /// FACT1 [1:1]
        /// Filter active
        FACT1: u1 = 0,
        /// FACT2 [2:2]
        /// Filter active
        FACT2: u1 = 0,
        /// FACT3 [3:3]
        /// Filter active
        FACT3: u1 = 0,
        /// FACT4 [4:4]
        /// Filter active
        FACT4: u1 = 0,
        /// FACT5 [5:5]
        /// Filter active
        FACT5: u1 = 0,
        /// FACT6 [6:6]
        /// Filter active
        FACT6: u1 = 0,
        /// FACT7 [7:7]
        /// Filter active
        FACT7: u1 = 0,
        /// FACT8 [8:8]
        /// Filter active
        FACT8: u1 = 0,
        /// FACT9 [9:9]
        /// Filter active
        FACT9: u1 = 0,
        /// FACT10 [10:10]
        /// Filter active
        FACT10: u1 = 0,
        /// FACT11 [11:11]
        /// Filter active
        FACT11: u1 = 0,
        /// FACT12 [12:12]
        /// Filter active
        FACT12: u1 = 0,
        /// FACT13 [13:13]
        /// Filter active
        FACT13: u1 = 0,
        /// FACT14 [14:14]
        /// Filter active
        FACT14: u1 = 0,
        /// FACT15 [15:15]
        /// Filter active
        FACT15: u1 = 0,
        /// FACT16 [16:16]
        /// Filter active
        FACT16: u1 = 0,
        /// FACT17 [17:17]
        /// Filter active
        FACT17: u1 = 0,
        /// FACT18 [18:18]
        /// Filter active
        FACT18: u1 = 0,
        /// FACT19 [19:19]
        /// Filter active
        FACT19: u1 = 0,
        /// FACT20 [20:20]
        /// Filter active
        FACT20: u1 = 0,
        /// FACT21 [21:21]
        /// Filter active
        FACT21: u1 = 0,
        /// FACT22 [22:22]
        /// Filter active
        FACT22: u1 = 0,
        /// FACT23 [23:23]
        /// Filter active
        FACT23: u1 = 0,
        /// FACT24 [24:24]
        /// Filter active
        FACT24: u1 = 0,
        /// FACT25 [25:25]
        /// Filter active
        FACT25: u1 = 0,
        /// FACT26 [26:26]
        /// Filter active
        FACT26: u1 = 0,
        /// FACT27 [27:27]
        /// Filter active
        FACT27: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// filter activation register
    pub const FA1R = Register(FA1R_val).init(base_address + 0x21c);

    /// F0R1
    const F0R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 1
    pub const F0R1 = Register(F0R1_val).init(base_address + 0x240);

    /// F0R2
    const F0R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 0 register 2
    pub const F0R2 = Register(F0R2_val).init(base_address + 0x244);

    /// F1R1
    const F1R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 1
    pub const F1R1 = Register(F1R1_val).init(base_address + 0x248);

    /// F1R2
    const F1R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 1 register 2
    pub const F1R2 = Register(F1R2_val).init(base_address + 0x24c);

    /// F2R1
    const F2R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 1
    pub const F2R1 = Register(F2R1_val).init(base_address + 0x250);

    /// F2R2
    const F2R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 2 register 2
    pub const F2R2 = Register(F2R2_val).init(base_address + 0x254);

    /// F3R1
    const F3R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 1
    pub const F3R1 = Register(F3R1_val).init(base_address + 0x258);

    /// F3R2
    const F3R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 3 register 2
    pub const F3R2 = Register(F3R2_val).init(base_address + 0x25c);

    /// F4R1
    const F4R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F4R1 = Register(F4R1_val).init(base_address + 0x260);

    /// F4R2
    const F4R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 2
    pub const F4R2 = Register(F4R2_val).init(base_address + 0x264);

    /// F5R1
    const F5R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 1
    pub const F5R1 = Register(F5R1_val).init(base_address + 0x268);

    /// F5R2
    const F5R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 5 register 2
    pub const F5R2 = Register(F5R2_val).init(base_address + 0x26c);

    /// F6R1
    const F6R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 1
    pub const F6R1 = Register(F6R1_val).init(base_address + 0x270);

    /// F6R2
    const F6R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 6 register 2
    pub const F6R2 = Register(F6R2_val).init(base_address + 0x274);

    /// F7R1
    const F7R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 1
    pub const F7R1 = Register(F7R1_val).init(base_address + 0x278);

    /// F7R2
    const F7R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 7 register 2
    pub const F7R2 = Register(F7R2_val).init(base_address + 0x27c);

    /// F8R1
    const F8R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 1
    pub const F8R1 = Register(F8R1_val).init(base_address + 0x280);

    /// F8R2
    const F8R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 8 register 2
    pub const F8R2 = Register(F8R2_val).init(base_address + 0x284);

    /// F9R1
    const F9R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 1
    pub const F9R1 = Register(F9R1_val).init(base_address + 0x288);

    /// F9R2
    const F9R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 9 register 2
    pub const F9R2 = Register(F9R2_val).init(base_address + 0x28c);

    /// F10R1
    const F10R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 1
    pub const F10R1 = Register(F10R1_val).init(base_address + 0x290);

    /// F10R2
    const F10R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 10 register 2
    pub const F10R2 = Register(F10R2_val).init(base_address + 0x294);

    /// F11R1
    const F11R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 1
    pub const F11R1 = Register(F11R1_val).init(base_address + 0x298);

    /// F11R2
    const F11R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 11 register 2
    pub const F11R2 = Register(F11R2_val).init(base_address + 0x29c);

    /// F12R1
    const F12R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 4 register 1
    pub const F12R1 = Register(F12R1_val).init(base_address + 0x2a0);

    /// F12R2
    const F12R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 12 register 2
    pub const F12R2 = Register(F12R2_val).init(base_address + 0x2a4);

    /// F13R1
    const F13R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 1
    pub const F13R1 = Register(F13R1_val).init(base_address + 0x2a8);

    /// F13R2
    const F13R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 13 register 2
    pub const F13R2 = Register(F13R2_val).init(base_address + 0x2ac);

    /// F14R1
    const F14R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 1
    pub const F14R1 = Register(F14R1_val).init(base_address + 0x2b0);

    /// F14R2
    const F14R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 14 register 2
    pub const F14R2 = Register(F14R2_val).init(base_address + 0x2b4);

    /// F15R1
    const F15R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 1
    pub const F15R1 = Register(F15R1_val).init(base_address + 0x2b8);

    /// F15R2
    const F15R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 15 register 2
    pub const F15R2 = Register(F15R2_val).init(base_address + 0x2bc);

    /// F16R1
    const F16R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 1
    pub const F16R1 = Register(F16R1_val).init(base_address + 0x2c0);

    /// F16R2
    const F16R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 16 register 2
    pub const F16R2 = Register(F16R2_val).init(base_address + 0x2c4);

    /// F17R1
    const F17R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 1
    pub const F17R1 = Register(F17R1_val).init(base_address + 0x2c8);

    /// F17R2
    const F17R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 17 register 2
    pub const F17R2 = Register(F17R2_val).init(base_address + 0x2cc);

    /// F18R1
    const F18R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 1
    pub const F18R1 = Register(F18R1_val).init(base_address + 0x2d0);

    /// F18R2
    const F18R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 18 register 2
    pub const F18R2 = Register(F18R2_val).init(base_address + 0x2d4);

    /// F19R1
    const F19R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 1
    pub const F19R1 = Register(F19R1_val).init(base_address + 0x2d8);

    /// F19R2
    const F19R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 19 register 2
    pub const F19R2 = Register(F19R2_val).init(base_address + 0x2dc);

    /// F20R1
    const F20R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 1
    pub const F20R1 = Register(F20R1_val).init(base_address + 0x2e0);

    /// F20R2
    const F20R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 20 register 2
    pub const F20R2 = Register(F20R2_val).init(base_address + 0x2e4);

    /// F21R1
    const F21R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 1
    pub const F21R1 = Register(F21R1_val).init(base_address + 0x2e8);

    /// F21R2
    const F21R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 21 register 2
    pub const F21R2 = Register(F21R2_val).init(base_address + 0x2ec);

    /// F22R1
    const F22R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 1
    pub const F22R1 = Register(F22R1_val).init(base_address + 0x2f0);

    /// F22R2
    const F22R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 22 register 2
    pub const F22R2 = Register(F22R2_val).init(base_address + 0x2f4);

    /// F23R1
    const F23R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 1
    pub const F23R1 = Register(F23R1_val).init(base_address + 0x2f8);

    /// F23R2
    const F23R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 23 register 2
    pub const F23R2 = Register(F23R2_val).init(base_address + 0x2fc);

    /// F24R1
    const F24R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 1
    pub const F24R1 = Register(F24R1_val).init(base_address + 0x300);

    /// F24R2
    const F24R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 24 register 2
    pub const F24R2 = Register(F24R2_val).init(base_address + 0x304);

    /// F25R1
    const F25R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 1
    pub const F25R1 = Register(F25R1_val).init(base_address + 0x308);

    /// F25R2
    const F25R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 25 register 2
    pub const F25R2 = Register(F25R2_val).init(base_address + 0x30c);

    /// F26R1
    const F26R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 1
    pub const F26R1 = Register(F26R1_val).init(base_address + 0x310);

    /// F26R2
    const F26R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 26 register 2
    pub const F26R2 = Register(F26R2_val).init(base_address + 0x314);

    /// F27R1
    const F27R1_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 1
    pub const F27R1 = Register(F27R1_val).init(base_address + 0x318);

    /// F27R2
    const F27R2_val = packed struct {
        /// FB0 [0:0]
        /// Filter bits
        FB0: u1 = 0,
        /// FB1 [1:1]
        /// Filter bits
        FB1: u1 = 0,
        /// FB2 [2:2]
        /// Filter bits
        FB2: u1 = 0,
        /// FB3 [3:3]
        /// Filter bits
        FB3: u1 = 0,
        /// FB4 [4:4]
        /// Filter bits
        FB4: u1 = 0,
        /// FB5 [5:5]
        /// Filter bits
        FB5: u1 = 0,
        /// FB6 [6:6]
        /// Filter bits
        FB6: u1 = 0,
        /// FB7 [7:7]
        /// Filter bits
        FB7: u1 = 0,
        /// FB8 [8:8]
        /// Filter bits
        FB8: u1 = 0,
        /// FB9 [9:9]
        /// Filter bits
        FB9: u1 = 0,
        /// FB10 [10:10]
        /// Filter bits
        FB10: u1 = 0,
        /// FB11 [11:11]
        /// Filter bits
        FB11: u1 = 0,
        /// FB12 [12:12]
        /// Filter bits
        FB12: u1 = 0,
        /// FB13 [13:13]
        /// Filter bits
        FB13: u1 = 0,
        /// FB14 [14:14]
        /// Filter bits
        FB14: u1 = 0,
        /// FB15 [15:15]
        /// Filter bits
        FB15: u1 = 0,
        /// FB16 [16:16]
        /// Filter bits
        FB16: u1 = 0,
        /// FB17 [17:17]
        /// Filter bits
        FB17: u1 = 0,
        /// FB18 [18:18]
        /// Filter bits
        FB18: u1 = 0,
        /// FB19 [19:19]
        /// Filter bits
        FB19: u1 = 0,
        /// FB20 [20:20]
        /// Filter bits
        FB20: u1 = 0,
        /// FB21 [21:21]
        /// Filter bits
        FB21: u1 = 0,
        /// FB22 [22:22]
        /// Filter bits
        FB22: u1 = 0,
        /// FB23 [23:23]
        /// Filter bits
        FB23: u1 = 0,
        /// FB24 [24:24]
        /// Filter bits
        FB24: u1 = 0,
        /// FB25 [25:25]
        /// Filter bits
        FB25: u1 = 0,
        /// FB26 [26:26]
        /// Filter bits
        FB26: u1 = 0,
        /// FB27 [27:27]
        /// Filter bits
        FB27: u1 = 0,
        /// FB28 [28:28]
        /// Filter bits
        FB28: u1 = 0,
        /// FB29 [29:29]
        /// Filter bits
        FB29: u1 = 0,
        /// FB30 [30:30]
        /// Filter bits
        FB30: u1 = 0,
        /// FB31 [31:31]
        /// Filter bits
        FB31: u1 = 0,
    };
    /// Filter bank 27 register 2
    pub const F27R2 = Register(F27R2_val).init(base_address + 0x31c);
};

/// FLASH
pub const Flash = struct {
    const base_address = 0x40023c00;
    /// ACR
    const ACR_val = packed struct {
        /// LATENCY [0:3]
        /// Latency
        LATENCY: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// PRFTEN [8:8]
        /// Prefetch enable
        PRFTEN: u1 = 0,
        /// ARTEN [9:9]
        /// ART Accelerator Enable
        ARTEN: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// ARTRST [11:11]
        /// ART Accelerator reset
        ARTRST: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Flash access control register
    pub const ACR = Register(ACR_val).init(base_address + 0x0);

    /// KEYR
    const KEYR_val = packed struct {
        /// KEY [0:31]
        /// FPEC key
        KEY: u32 = 0,
    };
    /// Flash key register
    pub const KEYR = Register(KEYR_val).init(base_address + 0x4);

    /// OPTKEYR
    const OPTKEYR_val = packed struct {
        /// OPTKEY [0:31]
        /// Option byte key
        OPTKEY: u32 = 0,
    };
    /// Flash option key register
    pub const OPTKEYR = Register(OPTKEYR_val).init(base_address + 0x8);

    /// SR
    const SR_val = packed struct {
        /// EOP [0:0]
        /// End of operation
        EOP: u1 = 0,
        /// OPERR [1:1]
        /// Operation error
        OPERR: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// WRPERR [4:4]
        /// Write protection error
        WRPERR: u1 = 0,
        /// PGAERR [5:5]
        /// Programming alignment
        PGAERR: u1 = 0,
        /// PGPERR [6:6]
        /// Programming parallelism
        PGPERR: u1 = 0,
        /// PGSERR [7:7]
        /// Programming sequence error
        PGSERR: u1 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// BSY [16:16]
        /// Busy
        BSY: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Status register
    pub const SR = Register(SR_val).init(base_address + 0xc);

    /// CR
    const CR_val = packed struct {
        /// PG [0:0]
        /// Programming
        PG: u1 = 0,
        /// SER [1:1]
        /// Sector Erase
        SER: u1 = 0,
        /// MER [2:2]
        /// Mass Erase of sectors 0 to
        MER: u1 = 0,
        /// SNB [3:7]
        /// Sector number
        SNB: u5 = 0,
        /// PSIZE [8:9]
        /// Program size
        PSIZE: u2 = 0,
        /// unused [10:14]
        _unused10: u5 = 0,
        /// MER1 [15:15]
        /// Mass Erase of sectors 12 to
        MER1: u1 = 0,
        /// STRT [16:16]
        /// Start
        STRT: u1 = 0,
        /// unused [17:23]
        _unused17: u7 = 0,
        /// EOPIE [24:24]
        /// End of operation interrupt
        EOPIE: u1 = 0,
        /// ERRIE [25:25]
        /// Error interrupt enable
        ERRIE: u1 = 0,
        /// unused [26:30]
        _unused26: u5 = 0,
        /// LOCK [31:31]
        /// Lock
        LOCK: u1 = 1,
    };
    /// Control register
    pub const CR = Register(CR_val).init(base_address + 0x10);

    /// OPTCR
    const OPTCR_val = packed struct {
        /// OPTLOCK [0:0]
        /// Option lock
        OPTLOCK: u1 = 1,
        /// OPTSTRT [1:1]
        /// Option start
        OPTSTRT: u1 = 0,
        /// BOR_LEV [2:3]
        /// BOR reset Level
        BOR_LEV: u2 = 3,
        /// WWDG_SW [4:4]
        /// User option bytes
        WWDG_SW: u1 = 0,
        /// IWDG_SW [5:5]
        /// User option bytes
        IWDG_SW: u1 = 1,
        /// nRST_STOP [6:6]
        /// User option bytes
        nRST_STOP: u1 = 1,
        /// nRST_STDBY [7:7]
        /// User option bytes
        nRST_STDBY: u1 = 1,
        /// RDP [8:15]
        /// Read protect
        RDP: u8 = 170,
        /// nWRP [16:27]
        /// Not write protect
        nWRP: u12 = 4095,
        /// nDBOOT [28:28]
        /// Dual Boot mode (valid only when
        nDBOOT: u1 = 0,
        /// nDBANK [29:29]
        /// Not dual bank mode
        nDBANK: u1 = 0,
        /// IWDG_STDBY [30:30]
        /// Independent watchdog counter freeze in
        IWDG_STDBY: u1 = 0,
        /// IWDG_STOP [31:31]
        /// Independent watchdog counter freeze in
        IWDG_STOP: u1 = 0,
    };
    /// Flash option control register
    pub const OPTCR = Register(OPTCR_val).init(base_address + 0x14);

    /// OPTCR1
    const OPTCR1_val = packed struct {
        /// BOOT_ADD0 [0:15]
        /// Boot base address when Boot pin
        BOOT_ADD0: u16 = 0,
        /// BOOT_ADD1 [16:31]
        /// Boot base address when Boot pin
        BOOT_ADD1: u16 = 4095,
    };
    /// Flash option control register
    pub const OPTCR1 = Register(OPTCR1_val).init(base_address + 0x18);
};

/// External interrupt/event
pub const EXTI = struct {
    const base_address = 0x40013c00;
    /// IMR
    const IMR_val = packed struct {
        /// MR0 [0:0]
        /// Interrupt Mask on line 0
        MR0: u1 = 0,
        /// MR1 [1:1]
        /// Interrupt Mask on line 1
        MR1: u1 = 0,
        /// MR2 [2:2]
        /// Interrupt Mask on line 2
        MR2: u1 = 0,
        /// MR3 [3:3]
        /// Interrupt Mask on line 3
        MR3: u1 = 0,
        /// MR4 [4:4]
        /// Interrupt Mask on line 4
        MR4: u1 = 0,
        /// MR5 [5:5]
        /// Interrupt Mask on line 5
        MR5: u1 = 0,
        /// MR6 [6:6]
        /// Interrupt Mask on line 6
        MR6: u1 = 0,
        /// MR7 [7:7]
        /// Interrupt Mask on line 7
        MR7: u1 = 0,
        /// MR8 [8:8]
        /// Interrupt Mask on line 8
        MR8: u1 = 0,
        /// MR9 [9:9]
        /// Interrupt Mask on line 9
        MR9: u1 = 0,
        /// MR10 [10:10]
        /// Interrupt Mask on line 10
        MR10: u1 = 0,
        /// MR11 [11:11]
        /// Interrupt Mask on line 11
        MR11: u1 = 0,
        /// MR12 [12:12]
        /// Interrupt Mask on line 12
        MR12: u1 = 0,
        /// MR13 [13:13]
        /// Interrupt Mask on line 13
        MR13: u1 = 0,
        /// MR14 [14:14]
        /// Interrupt Mask on line 14
        MR14: u1 = 0,
        /// MR15 [15:15]
        /// Interrupt Mask on line 15
        MR15: u1 = 0,
        /// MR16 [16:16]
        /// Interrupt Mask on line 16
        MR16: u1 = 0,
        /// MR17 [17:17]
        /// Interrupt Mask on line 17
        MR17: u1 = 0,
        /// MR18 [18:18]
        /// Interrupt Mask on line 18
        MR18: u1 = 0,
        /// MR19 [19:19]
        /// Interrupt Mask on line 19
        MR19: u1 = 0,
        /// MR20 [20:20]
        /// Interrupt Mask on line 20
        MR20: u1 = 0,
        /// MR21 [21:21]
        /// Interrupt Mask on line 21
        MR21: u1 = 0,
        /// MR22 [22:22]
        /// Interrupt Mask on line 22
        MR22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt mask register
    pub const IMR = Register(IMR_val).init(base_address + 0x0);

    /// EMR
    const EMR_val = packed struct {
        /// MR0 [0:0]
        /// Event Mask on line 0
        MR0: u1 = 0,
        /// MR1 [1:1]
        /// Event Mask on line 1
        MR1: u1 = 0,
        /// MR2 [2:2]
        /// Event Mask on line 2
        MR2: u1 = 0,
        /// MR3 [3:3]
        /// Event Mask on line 3
        MR3: u1 = 0,
        /// MR4 [4:4]
        /// Event Mask on line 4
        MR4: u1 = 0,
        /// MR5 [5:5]
        /// Event Mask on line 5
        MR5: u1 = 0,
        /// MR6 [6:6]
        /// Event Mask on line 6
        MR6: u1 = 0,
        /// MR7 [7:7]
        /// Event Mask on line 7
        MR7: u1 = 0,
        /// MR8 [8:8]
        /// Event Mask on line 8
        MR8: u1 = 0,
        /// MR9 [9:9]
        /// Event Mask on line 9
        MR9: u1 = 0,
        /// MR10 [10:10]
        /// Event Mask on line 10
        MR10: u1 = 0,
        /// MR11 [11:11]
        /// Event Mask on line 11
        MR11: u1 = 0,
        /// MR12 [12:12]
        /// Event Mask on line 12
        MR12: u1 = 0,
        /// MR13 [13:13]
        /// Event Mask on line 13
        MR13: u1 = 0,
        /// MR14 [14:14]
        /// Event Mask on line 14
        MR14: u1 = 0,
        /// MR15 [15:15]
        /// Event Mask on line 15
        MR15: u1 = 0,
        /// MR16 [16:16]
        /// Event Mask on line 16
        MR16: u1 = 0,
        /// MR17 [17:17]
        /// Event Mask on line 17
        MR17: u1 = 0,
        /// MR18 [18:18]
        /// Event Mask on line 18
        MR18: u1 = 0,
        /// MR19 [19:19]
        /// Event Mask on line 19
        MR19: u1 = 0,
        /// MR20 [20:20]
        /// Event Mask on line 20
        MR20: u1 = 0,
        /// MR21 [21:21]
        /// Event Mask on line 21
        MR21: u1 = 0,
        /// MR22 [22:22]
        /// Event Mask on line 22
        MR22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Event mask register (EXTI_EMR)
    pub const EMR = Register(EMR_val).init(base_address + 0x4);

    /// RTSR
    const RTSR_val = packed struct {
        /// TR0 [0:0]
        /// Rising trigger event configuration of
        TR0: u1 = 0,
        /// TR1 [1:1]
        /// Rising trigger event configuration of
        TR1: u1 = 0,
        /// TR2 [2:2]
        /// Rising trigger event configuration of
        TR2: u1 = 0,
        /// TR3 [3:3]
        /// Rising trigger event configuration of
        TR3: u1 = 0,
        /// TR4 [4:4]
        /// Rising trigger event configuration of
        TR4: u1 = 0,
        /// TR5 [5:5]
        /// Rising trigger event configuration of
        TR5: u1 = 0,
        /// TR6 [6:6]
        /// Rising trigger event configuration of
        TR6: u1 = 0,
        /// TR7 [7:7]
        /// Rising trigger event configuration of
        TR7: u1 = 0,
        /// TR8 [8:8]
        /// Rising trigger event configuration of
        TR8: u1 = 0,
        /// TR9 [9:9]
        /// Rising trigger event configuration of
        TR9: u1 = 0,
        /// TR10 [10:10]
        /// Rising trigger event configuration of
        TR10: u1 = 0,
        /// TR11 [11:11]
        /// Rising trigger event configuration of
        TR11: u1 = 0,
        /// TR12 [12:12]
        /// Rising trigger event configuration of
        TR12: u1 = 0,
        /// TR13 [13:13]
        /// Rising trigger event configuration of
        TR13: u1 = 0,
        /// TR14 [14:14]
        /// Rising trigger event configuration of
        TR14: u1 = 0,
        /// TR15 [15:15]
        /// Rising trigger event configuration of
        TR15: u1 = 0,
        /// TR16 [16:16]
        /// Rising trigger event configuration of
        TR16: u1 = 0,
        /// TR17 [17:17]
        /// Rising trigger event configuration of
        TR17: u1 = 0,
        /// TR18 [18:18]
        /// Rising trigger event configuration of
        TR18: u1 = 0,
        /// TR19 [19:19]
        /// Rising trigger event configuration of
        TR19: u1 = 0,
        /// TR20 [20:20]
        /// Rising trigger event configuration of
        TR20: u1 = 0,
        /// TR21 [21:21]
        /// Rising trigger event configuration of
        TR21: u1 = 0,
        /// TR22 [22:22]
        /// Rising trigger event configuration of
        TR22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Rising Trigger selection register
    pub const RTSR = Register(RTSR_val).init(base_address + 0x8);

    /// FTSR
    const FTSR_val = packed struct {
        /// TR0 [0:0]
        /// Falling trigger event configuration of
        TR0: u1 = 0,
        /// TR1 [1:1]
        /// Falling trigger event configuration of
        TR1: u1 = 0,
        /// TR2 [2:2]
        /// Falling trigger event configuration of
        TR2: u1 = 0,
        /// TR3 [3:3]
        /// Falling trigger event configuration of
        TR3: u1 = 0,
        /// TR4 [4:4]
        /// Falling trigger event configuration of
        TR4: u1 = 0,
        /// TR5 [5:5]
        /// Falling trigger event configuration of
        TR5: u1 = 0,
        /// TR6 [6:6]
        /// Falling trigger event configuration of
        TR6: u1 = 0,
        /// TR7 [7:7]
        /// Falling trigger event configuration of
        TR7: u1 = 0,
        /// TR8 [8:8]
        /// Falling trigger event configuration of
        TR8: u1 = 0,
        /// TR9 [9:9]
        /// Falling trigger event configuration of
        TR9: u1 = 0,
        /// TR10 [10:10]
        /// Falling trigger event configuration of
        TR10: u1 = 0,
        /// TR11 [11:11]
        /// Falling trigger event configuration of
        TR11: u1 = 0,
        /// TR12 [12:12]
        /// Falling trigger event configuration of
        TR12: u1 = 0,
        /// TR13 [13:13]
        /// Falling trigger event configuration of
        TR13: u1 = 0,
        /// TR14 [14:14]
        /// Falling trigger event configuration of
        TR14: u1 = 0,
        /// TR15 [15:15]
        /// Falling trigger event configuration of
        TR15: u1 = 0,
        /// TR16 [16:16]
        /// Falling trigger event configuration of
        TR16: u1 = 0,
        /// TR17 [17:17]
        /// Falling trigger event configuration of
        TR17: u1 = 0,
        /// TR18 [18:18]
        /// Falling trigger event configuration of
        TR18: u1 = 0,
        /// TR19 [19:19]
        /// Falling trigger event configuration of
        TR19: u1 = 0,
        /// TR20 [20:20]
        /// Falling trigger event configuration of
        TR20: u1 = 0,
        /// TR21 [21:21]
        /// Falling trigger event configuration of
        TR21: u1 = 0,
        /// TR22 [22:22]
        /// Falling trigger event configuration of
        TR22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Falling Trigger selection register
    pub const FTSR = Register(FTSR_val).init(base_address + 0xc);

    /// SWIER
    const SWIER_val = packed struct {
        /// SWIER0 [0:0]
        /// Software Interrupt on line
        SWIER0: u1 = 0,
        /// SWIER1 [1:1]
        /// Software Interrupt on line
        SWIER1: u1 = 0,
        /// SWIER2 [2:2]
        /// Software Interrupt on line
        SWIER2: u1 = 0,
        /// SWIER3 [3:3]
        /// Software Interrupt on line
        SWIER3: u1 = 0,
        /// SWIER4 [4:4]
        /// Software Interrupt on line
        SWIER4: u1 = 0,
        /// SWIER5 [5:5]
        /// Software Interrupt on line
        SWIER5: u1 = 0,
        /// SWIER6 [6:6]
        /// Software Interrupt on line
        SWIER6: u1 = 0,
        /// SWIER7 [7:7]
        /// Software Interrupt on line
        SWIER7: u1 = 0,
        /// SWIER8 [8:8]
        /// Software Interrupt on line
        SWIER8: u1 = 0,
        /// SWIER9 [9:9]
        /// Software Interrupt on line
        SWIER9: u1 = 0,
        /// SWIER10 [10:10]
        /// Software Interrupt on line
        SWIER10: u1 = 0,
        /// SWIER11 [11:11]
        /// Software Interrupt on line
        SWIER11: u1 = 0,
        /// SWIER12 [12:12]
        /// Software Interrupt on line
        SWIER12: u1 = 0,
        /// SWIER13 [13:13]
        /// Software Interrupt on line
        SWIER13: u1 = 0,
        /// SWIER14 [14:14]
        /// Software Interrupt on line
        SWIER14: u1 = 0,
        /// SWIER15 [15:15]
        /// Software Interrupt on line
        SWIER15: u1 = 0,
        /// SWIER16 [16:16]
        /// Software Interrupt on line
        SWIER16: u1 = 0,
        /// SWIER17 [17:17]
        /// Software Interrupt on line
        SWIER17: u1 = 0,
        /// SWIER18 [18:18]
        /// Software Interrupt on line
        SWIER18: u1 = 0,
        /// SWIER19 [19:19]
        /// Software Interrupt on line
        SWIER19: u1 = 0,
        /// SWIER20 [20:20]
        /// Software Interrupt on line
        SWIER20: u1 = 0,
        /// SWIER21 [21:21]
        /// Software Interrupt on line
        SWIER21: u1 = 0,
        /// SWIER22 [22:22]
        /// Software Interrupt on line
        SWIER22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Software interrupt event register
    pub const SWIER = Register(SWIER_val).init(base_address + 0x10);

    /// PR
    const PR_val = packed struct {
        /// PR0 [0:0]
        /// Pending bit 0
        PR0: u1 = 0,
        /// PR1 [1:1]
        /// Pending bit 1
        PR1: u1 = 0,
        /// PR2 [2:2]
        /// Pending bit 2
        PR2: u1 = 0,
        /// PR3 [3:3]
        /// Pending bit 3
        PR3: u1 = 0,
        /// PR4 [4:4]
        /// Pending bit 4
        PR4: u1 = 0,
        /// PR5 [5:5]
        /// Pending bit 5
        PR5: u1 = 0,
        /// PR6 [6:6]
        /// Pending bit 6
        PR6: u1 = 0,
        /// PR7 [7:7]
        /// Pending bit 7
        PR7: u1 = 0,
        /// PR8 [8:8]
        /// Pending bit 8
        PR8: u1 = 0,
        /// PR9 [9:9]
        /// Pending bit 9
        PR9: u1 = 0,
        /// PR10 [10:10]
        /// Pending bit 10
        PR10: u1 = 0,
        /// PR11 [11:11]
        /// Pending bit 11
        PR11: u1 = 0,
        /// PR12 [12:12]
        /// Pending bit 12
        PR12: u1 = 0,
        /// PR13 [13:13]
        /// Pending bit 13
        PR13: u1 = 0,
        /// PR14 [14:14]
        /// Pending bit 14
        PR14: u1 = 0,
        /// PR15 [15:15]
        /// Pending bit 15
        PR15: u1 = 0,
        /// PR16 [16:16]
        /// Pending bit 16
        PR16: u1 = 0,
        /// PR17 [17:17]
        /// Pending bit 17
        PR17: u1 = 0,
        /// PR18 [18:18]
        /// Pending bit 18
        PR18: u1 = 0,
        /// PR19 [19:19]
        /// Pending bit 19
        PR19: u1 = 0,
        /// PR20 [20:20]
        /// Pending bit 20
        PR20: u1 = 0,
        /// PR21 [21:21]
        /// Pending bit 21
        PR21: u1 = 0,
        /// PR22 [22:22]
        /// Pending bit 22
        PR22: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Pending register (EXTI_PR)
    pub const PR = Register(PR_val).init(base_address + 0x14);
};

/// LCD-TFT Controller
pub const LTCD = struct {
    const base_address = 0x40016800;
    /// SSCR
    const SSCR_val = packed struct {
        /// VSH [0:10]
        /// Vertical Synchronization Height (in
        VSH: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// HSW [16:25]
        /// Horizontal Synchronization Width (in
        HSW: u10 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Synchronization Size Configuration
    pub const SSCR = Register(SSCR_val).init(base_address + 0x8);

    /// BPCR
    const BPCR_val = packed struct {
        /// AVBP [0:10]
        /// Accumulated Vertical back porch (in
        AVBP: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// AHBP [16:25]
        /// Accumulated Horizontal back porch (in
        AHBP: u10 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Back Porch Configuration
    pub const BPCR = Register(BPCR_val).init(base_address + 0xc);

    /// AWCR
    const AWCR_val = packed struct {
        /// AAH [0:10]
        /// Accumulated Active Height (in units of
        AAH: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// AAV [16:25]
        /// AAV
        AAV: u10 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Active Width Configuration
    pub const AWCR = Register(AWCR_val).init(base_address + 0x10);

    /// TWCR
    const TWCR_val = packed struct {
        /// TOTALH [0:10]
        /// Total Height (in units of horizontal
        TOTALH: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// TOTALW [16:25]
        /// Total Width (in units of pixel clock
        TOTALW: u10 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// Total Width Configuration
    pub const TWCR = Register(TWCR_val).init(base_address + 0x14);

    /// GCR
    const GCR_val = packed struct {
        /// LTDCEN [0:0]
        /// LCD-TFT controller enable
        LTDCEN: u1 = 0,
        /// unused [1:3]
        _unused1: u3 = 0,
        /// DBW [4:6]
        /// Dither Blue Width
        DBW: u3 = 2,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// DGW [8:10]
        /// Dither Green Width
        DGW: u3 = 2,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// DRW [12:14]
        /// Dither Red Width
        DRW: u3 = 2,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// DEN [16:16]
        /// Dither Enable
        DEN: u1 = 0,
        /// unused [17:27]
        _unused17: u7 = 0,
        _unused24: u4 = 0,
        /// PCPOL [28:28]
        /// Pixel Clock Polarity
        PCPOL: u1 = 0,
        /// DEPOL [29:29]
        /// Data Enable Polarity
        DEPOL: u1 = 0,
        /// VSPOL [30:30]
        /// Vertical Synchronization
        VSPOL: u1 = 0,
        /// HSPOL [31:31]
        /// Horizontal Synchronization
        HSPOL: u1 = 0,
    };
    /// Global Control Register
    pub const GCR = Register(GCR_val).init(base_address + 0x18);

    /// SRCR
    const SRCR_val = packed struct {
        /// IMR [0:0]
        /// Immediate Reload
        IMR: u1 = 0,
        /// VBR [1:1]
        /// Vertical Blanking Reload
        VBR: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Shadow Reload Configuration
    pub const SRCR = Register(SRCR_val).init(base_address + 0x24);

    /// BCCR
    const BCCR_val = packed struct {
        /// BC [0:23]
        /// Background Color Red value
        BC: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Background Color Configuration
    pub const BCCR = Register(BCCR_val).init(base_address + 0x2c);

    /// IER
    const IER_val = packed struct {
        /// LIE [0:0]
        /// Line Interrupt Enable
        LIE: u1 = 0,
        /// FUIE [1:1]
        /// FIFO Underrun Interrupt
        FUIE: u1 = 0,
        /// TERRIE [2:2]
        /// Transfer Error Interrupt
        TERRIE: u1 = 0,
        /// RRIE [3:3]
        /// Register Reload interrupt
        RRIE: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable Register
    pub const IER = Register(IER_val).init(base_address + 0x34);

    /// ISR
    const ISR_val = packed struct {
        /// LIF [0:0]
        /// Line Interrupt flag
        LIF: u1 = 0,
        /// FUIF [1:1]
        /// FIFO Underrun Interrupt
        FUIF: u1 = 0,
        /// TERRIF [2:2]
        /// Transfer Error interrupt
        TERRIF: u1 = 0,
        /// RRIF [3:3]
        /// Register Reload Interrupt
        RRIF: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status Register
    pub const ISR = Register(ISR_val).init(base_address + 0x38);

    /// ICR
    const ICR_val = packed struct {
        /// CLIF [0:0]
        /// Clears the Line Interrupt
        CLIF: u1 = 0,
        /// CFUIF [1:1]
        /// Clears the FIFO Underrun Interrupt
        CFUIF: u1 = 0,
        /// CTERRIF [2:2]
        /// Clears the Transfer Error Interrupt
        CTERRIF: u1 = 0,
        /// CRRIF [3:3]
        /// Clears Register Reload Interrupt
        CRRIF: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Clear Register
    pub const ICR = Register(ICR_val).init(base_address + 0x3c);

    /// LIPCR
    const LIPCR_val = packed struct {
        /// LIPOS [0:10]
        /// Line Interrupt Position
        LIPOS: u11 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Line Interrupt Position Configuration
    pub const LIPCR = Register(LIPCR_val).init(base_address + 0x40);

    /// CPSR
    const CPSR_val = packed struct {
        /// CYPOS [0:15]
        /// Current Y Position
        CYPOS: u16 = 0,
        /// CXPOS [16:31]
        /// Current X Position
        CXPOS: u16 = 0,
    };
    /// Current Position Status
    pub const CPSR = Register(CPSR_val).init(base_address + 0x44);

    /// CDSR
    const CDSR_val = packed struct {
        /// VDES [0:0]
        /// Vertical Data Enable display
        VDES: u1 = 1,
        /// HDES [1:1]
        /// Horizontal Data Enable display
        HDES: u1 = 1,
        /// VSYNCS [2:2]
        /// Vertical Synchronization display
        VSYNCS: u1 = 1,
        /// HSYNCS [3:3]
        /// Horizontal Synchronization display
        HSYNCS: u1 = 1,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Current Display Status
    pub const CDSR = Register(CDSR_val).init(base_address + 0x48);

    /// L1CR
    const L1CR_val = packed struct {
        /// LEN [0:0]
        /// Layer Enable
        LEN: u1 = 0,
        /// COLKEN [1:1]
        /// Color Keying Enable
        COLKEN: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// CLUTEN [4:4]
        /// Color Look-Up Table Enable
        CLUTEN: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Control Register
    pub const L1CR = Register(L1CR_val).init(base_address + 0x84);

    /// L1WHPCR
    const L1WHPCR_val = packed struct {
        /// WHSTPOS [0:11]
        /// Window Horizontal Start
        WHSTPOS: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// WHSPPOS [16:27]
        /// Window Horizontal Stop
        WHSPPOS: u12 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Layerx Window Horizontal Position
    pub const L1WHPCR = Register(L1WHPCR_val).init(base_address + 0x88);

    /// L1WVPCR
    const L1WVPCR_val = packed struct {
        /// WVSTPOS [0:10]
        /// Window Vertical Start
        WVSTPOS: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// WVSPPOS [16:26]
        /// Window Vertical Stop
        WVSPPOS: u11 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Layerx Window Vertical Position
    pub const L1WVPCR = Register(L1WVPCR_val).init(base_address + 0x8c);

    /// L1CKCR
    const L1CKCR_val = packed struct {
        /// CKBLUE [0:7]
        /// Color Key Blue value
        CKBLUE: u8 = 0,
        /// CKGREEN [8:15]
        /// Color Key Green value
        CKGREEN: u8 = 0,
        /// CKRED [16:23]
        /// Color Key Red value
        CKRED: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Layerx Color Keying Configuration
    pub const L1CKCR = Register(L1CKCR_val).init(base_address + 0x90);

    /// L1PFCR
    const L1PFCR_val = packed struct {
        /// PF [0:2]
        /// Pixel Format
        PF: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Pixel Format Configuration
    pub const L1PFCR = Register(L1PFCR_val).init(base_address + 0x94);

    /// L1CACR
    const L1CACR_val = packed struct {
        /// CONSTA [0:7]
        /// Constant Alpha
        CONSTA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Constant Alpha Configuration
    pub const L1CACR = Register(L1CACR_val).init(base_address + 0x98);

    /// L1DCCR
    const L1DCCR_val = packed struct {
        /// DCBLUE [0:7]
        /// Default Color Blue
        DCBLUE: u8 = 0,
        /// DCGREEN [8:15]
        /// Default Color Green
        DCGREEN: u8 = 0,
        /// DCRED [16:23]
        /// Default Color Red
        DCRED: u8 = 0,
        /// DCALPHA [24:31]
        /// Default Color Alpha
        DCALPHA: u8 = 0,
    };
    /// Layerx Default Color Configuration
    pub const L1DCCR = Register(L1DCCR_val).init(base_address + 0x9c);

    /// L1BFCR
    const L1BFCR_val = packed struct {
        /// BF2 [0:2]
        /// Blending Factor 2
        BF2: u3 = 7,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// BF1 [8:10]
        /// Blending Factor 1
        BF1: u3 = 6,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Blending Factors Configuration
    pub const L1BFCR = Register(L1BFCR_val).init(base_address + 0xa0);

    /// L1CFBAR
    const L1CFBAR_val = packed struct {
        /// CFBADD [0:31]
        /// Color Frame Buffer Start
        CFBADD: u32 = 0,
    };
    /// Layerx Color Frame Buffer Address
    pub const L1CFBAR = Register(L1CFBAR_val).init(base_address + 0xac);

    /// L1CFBLR
    const L1CFBLR_val = packed struct {
        /// CFBLL [0:12]
        /// Color Frame Buffer Line
        CFBLL: u13 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CFBP [16:28]
        /// Color Frame Buffer Pitch in
        CFBP: u13 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Layerx Color Frame Buffer Length
    pub const L1CFBLR = Register(L1CFBLR_val).init(base_address + 0xb0);

    /// L1CFBLNR
    const L1CFBLNR_val = packed struct {
        /// CFBLNBR [0:10]
        /// Frame Buffer Line Number
        CFBLNBR: u11 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx ColorFrame Buffer Line Number
    pub const L1CFBLNR = Register(L1CFBLNR_val).init(base_address + 0xb4);

    /// L1CLUTWR
    const L1CLUTWR_val = packed struct {
        /// BLUE [0:7]
        /// Blue value
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// Green value
        GREEN: u8 = 0,
        /// RED [16:23]
        /// Red value
        RED: u8 = 0,
        /// CLUTADD [24:31]
        /// CLUT Address
        CLUTADD: u8 = 0,
    };
    /// Layerx CLUT Write Register
    pub const L1CLUTWR = Register(L1CLUTWR_val).init(base_address + 0xc4);

    /// L2CR
    const L2CR_val = packed struct {
        /// LEN [0:0]
        /// Layer Enable
        LEN: u1 = 0,
        /// COLKEN [1:1]
        /// Color Keying Enable
        COLKEN: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// CLUTEN [4:4]
        /// Color Look-Up Table Enable
        CLUTEN: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Control Register
    pub const L2CR = Register(L2CR_val).init(base_address + 0x104);

    /// L2WHPCR
    const L2WHPCR_val = packed struct {
        /// WHSTPOS [0:11]
        /// Window Horizontal Start
        WHSTPOS: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// WHSPPOS [16:27]
        /// Window Horizontal Stop
        WHSPPOS: u12 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// Layerx Window Horizontal Position
    pub const L2WHPCR = Register(L2WHPCR_val).init(base_address + 0x108);

    /// L2WVPCR
    const L2WVPCR_val = packed struct {
        /// WVSTPOS [0:10]
        /// Window Vertical Start
        WVSTPOS: u11 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// WVSPPOS [16:26]
        /// Window Vertical Stop
        WVSPPOS: u11 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Layerx Window Vertical Position
    pub const L2WVPCR = Register(L2WVPCR_val).init(base_address + 0x10c);

    /// L2CKCR
    const L2CKCR_val = packed struct {
        /// CKBLUE [0:7]
        /// Color Key Blue value
        CKBLUE: u8 = 0,
        /// CKGREEN [8:14]
        /// Color Key Green value
        CKGREEN: u7 = 0,
        /// CKRED [15:23]
        /// Color Key Red value
        CKRED: u9 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Layerx Color Keying Configuration
    pub const L2CKCR = Register(L2CKCR_val).init(base_address + 0x110);

    /// L2PFCR
    const L2PFCR_val = packed struct {
        /// PF [0:2]
        /// Pixel Format
        PF: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Pixel Format Configuration
    pub const L2PFCR = Register(L2PFCR_val).init(base_address + 0x114);

    /// L2CACR
    const L2CACR_val = packed struct {
        /// CONSTA [0:7]
        /// Constant Alpha
        CONSTA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Constant Alpha Configuration
    pub const L2CACR = Register(L2CACR_val).init(base_address + 0x118);

    /// L2DCCR
    const L2DCCR_val = packed struct {
        /// DCBLUE [0:7]
        /// Default Color Blue
        DCBLUE: u8 = 0,
        /// DCGREEN [8:15]
        /// Default Color Green
        DCGREEN: u8 = 0,
        /// DCRED [16:23]
        /// Default Color Red
        DCRED: u8 = 0,
        /// DCALPHA [24:31]
        /// Default Color Alpha
        DCALPHA: u8 = 0,
    };
    /// Layerx Default Color Configuration
    pub const L2DCCR = Register(L2DCCR_val).init(base_address + 0x11c);

    /// L2BFCR
    const L2BFCR_val = packed struct {
        /// BF2 [0:2]
        /// Blending Factor 2
        BF2: u3 = 7,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// BF1 [8:10]
        /// Blending Factor 1
        BF1: u3 = 6,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx Blending Factors Configuration
    pub const L2BFCR = Register(L2BFCR_val).init(base_address + 0x120);

    /// L2CFBAR
    const L2CFBAR_val = packed struct {
        /// CFBADD [0:31]
        /// Color Frame Buffer Start
        CFBADD: u32 = 0,
    };
    /// Layerx Color Frame Buffer Address
    pub const L2CFBAR = Register(L2CFBAR_val).init(base_address + 0x12c);

    /// L2CFBLR
    const L2CFBLR_val = packed struct {
        /// CFBLL [0:12]
        /// Color Frame Buffer Line
        CFBLL: u13 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CFBP [16:28]
        /// Color Frame Buffer Pitch in
        CFBP: u13 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Layerx Color Frame Buffer Length
    pub const L2CFBLR = Register(L2CFBLR_val).init(base_address + 0x130);

    /// L2CFBLNR
    const L2CFBLNR_val = packed struct {
        /// CFBLNBR [0:10]
        /// Frame Buffer Line Number
        CFBLNBR: u11 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Layerx ColorFrame Buffer Line Number
    pub const L2CFBLNR = Register(L2CFBLNR_val).init(base_address + 0x134);

    /// L2CLUTWR
    const L2CLUTWR_val = packed struct {
        /// BLUE [0:7]
        /// Blue value
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// Green value
        GREEN: u8 = 0,
        /// RED [16:23]
        /// Red value
        RED: u8 = 0,
        /// CLUTADD [24:31]
        /// CLUT Address
        CLUTADD: u8 = 0,
    };
    /// Layerx CLUT Write Register
    pub const L2CLUTWR = Register(L2CLUTWR_val).init(base_address + 0x144);
};

/// Serial audio interface
pub const SAI1 = struct {
    const base_address = 0x40015800;
    /// BCR1
    const BCR1_val = packed struct {
        /// MODE [0:1]
        /// Audio block mode
        MODE: u2 = 0,
        /// PRTCFG [2:3]
        /// Protocol configuration
        PRTCFG: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// DS [5:7]
        /// Data size
        DS: u3 = 2,
        /// LSBFIRST [8:8]
        /// Least significant bit
        LSBFIRST: u1 = 0,
        /// CKSTR [9:9]
        /// Clock strobing edge
        CKSTR: u1 = 0,
        /// SYNCEN [10:11]
        /// Synchronization enable
        SYNCEN: u2 = 0,
        /// MONO [12:12]
        /// Mono mode
        MONO: u1 = 0,
        /// OutDri [13:13]
        /// Output drive
        OutDri: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// SAIBEN [16:16]
        /// Audio block B enable
        SAIBEN: u1 = 0,
        /// DMAEN [17:17]
        /// DMA enable
        DMAEN: u1 = 0,
        /// unused [18:18]
        _unused18: u1 = 0,
        /// NODIV [19:19]
        /// No divider
        NODIV: u1 = 0,
        /// MCKDIV [20:23]
        /// Master clock divider
        MCKDIV: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// BConfiguration register 1
    pub const BCR1 = Register(BCR1_val).init(base_address + 0x24);

    /// BCR2
    const BCR2_val = packed struct {
        /// FTH [0:2]
        /// FIFO threshold
        FTH: u3 = 0,
        /// FFLUS [3:3]
        /// FIFO flush
        FFLUS: u1 = 0,
        /// TRIS [4:4]
        /// Tristate management on data
        TRIS: u1 = 0,
        /// MUTE [5:5]
        /// Mute
        MUTE: u1 = 0,
        /// MUTEVAL [6:6]
        /// Mute value
        MUTEVAL: u1 = 0,
        /// MUTECN [7:12]
        /// Mute counter
        MUTECN: u6 = 0,
        /// CPL [13:13]
        /// Complement bit
        CPL: u1 = 0,
        /// COMP [14:15]
        /// Companding mode
        COMP: u2 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BConfiguration register 2
    pub const BCR2 = Register(BCR2_val).init(base_address + 0x28);

    /// BFRCR
    const BFRCR_val = packed struct {
        /// FRL [0:7]
        /// Frame length
        FRL: u8 = 7,
        /// FSALL [8:14]
        /// Frame synchronization active level
        FSALL: u7 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// FSDEF [16:16]
        /// Frame synchronization
        FSDEF: u1 = 0,
        /// FSPOL [17:17]
        /// Frame synchronization
        FSPOL: u1 = 0,
        /// FSOFF [18:18]
        /// Frame synchronization
        FSOFF: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// BFRCR
    pub const BFRCR = Register(BFRCR_val).init(base_address + 0x2c);

    /// BSLOTR
    const BSLOTR_val = packed struct {
        /// FBOFF [0:4]
        /// First bit offset
        FBOFF: u5 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// SLOTSZ [6:7]
        /// Slot size
        SLOTSZ: u2 = 0,
        /// NBSLOT [8:11]
        /// Number of slots in an audio
        NBSLOT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SLOTEN [16:31]
        /// Slot enable
        SLOTEN: u16 = 0,
    };
    /// BSlot register
    pub const BSLOTR = Register(BSLOTR_val).init(base_address + 0x30);

    /// BIM
    const BIM_val = packed struct {
        /// OVRUDRIE [0:0]
        /// Overrun/underrun interrupt
        OVRUDRIE: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection interrupt
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration interrupt
        WCKCFG: u1 = 0,
        /// FREQIE [3:3]
        /// FIFO request interrupt
        FREQIE: u1 = 0,
        /// CNRDYIE [4:4]
        /// Codec not ready interrupt
        CNRDYIE: u1 = 0,
        /// AFSDETIE [5:5]
        /// Anticipated frame synchronization
        AFSDETIE: u1 = 0,
        /// LFSDETIE [6:6]
        /// Late frame synchronization detection
        LFSDETIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BInterrupt mask register2
    pub const BIM = Register(BIM_val).init(base_address + 0x34);

    /// BSR
    const BSR_val = packed struct {
        /// OVRUDR [0:0]
        /// Overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration
        WCKCFG: u1 = 0,
        /// FREQ [3:3]
        /// FIFO request
        FREQ: u1 = 0,
        /// CNRDY [4:4]
        /// Codec not ready
        CNRDY: u1 = 0,
        /// AFSDET [5:5]
        /// Anticipated frame synchronization
        AFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// FLVL [16:18]
        /// FIFO level threshold
        FLVL: u3 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// BStatus register
    pub const BSR = Register(BSR_val).init(base_address + 0x38);

    /// BCLRFR
    const BCLRFR_val = packed struct {
        /// OVRUDR [0:0]
        /// Clear overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection flag
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Clear wrong clock configuration
        WCKCFG: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// CNRDY [4:4]
        /// Clear codec not ready flag
        CNRDY: u1 = 0,
        /// CAFSDET [5:5]
        /// Clear anticipated frame synchronization
        CAFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Clear late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BClear flag register
    pub const BCLRFR = Register(BCLRFR_val).init(base_address + 0x3c);

    /// BDR
    const BDR_val = packed struct {
        /// DATA [0:31]
        /// Data
        DATA: u32 = 0,
    };
    /// BData register
    pub const BDR = Register(BDR_val).init(base_address + 0x40);

    /// ACR1
    const ACR1_val = packed struct {
        /// MODE [0:1]
        /// Audio block mode
        MODE: u2 = 0,
        /// PRTCFG [2:3]
        /// Protocol configuration
        PRTCFG: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// DS [5:7]
        /// Data size
        DS: u3 = 2,
        /// LSBFIRST [8:8]
        /// Least significant bit
        LSBFIRST: u1 = 0,
        /// CKSTR [9:9]
        /// Clock strobing edge
        CKSTR: u1 = 0,
        /// SYNCEN [10:11]
        /// Synchronization enable
        SYNCEN: u2 = 0,
        /// MONO [12:12]
        /// Mono mode
        MONO: u1 = 0,
        /// OutDri [13:13]
        /// Output drive
        OutDri: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// SAIAEN [16:16]
        /// Audio block A enable
        SAIAEN: u1 = 0,
        /// DMAEN [17:17]
        /// DMA enable
        DMAEN: u1 = 0,
        /// unused [18:18]
        _unused18: u1 = 0,
        /// NODIV [19:19]
        /// No divider
        NODIV: u1 = 0,
        /// MCKDIV [20:23]
        /// Master clock divider
        MCKDIV: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// AConfiguration register 1
    pub const ACR1 = Register(ACR1_val).init(base_address + 0x4);

    /// ACR2
    const ACR2_val = packed struct {
        /// FTH [0:2]
        /// FIFO threshold
        FTH: u3 = 0,
        /// FFLUS [3:3]
        /// FIFO flush
        FFLUS: u1 = 0,
        /// TRIS [4:4]
        /// Tristate management on data
        TRIS: u1 = 0,
        /// MUTE [5:5]
        /// Mute
        MUTE: u1 = 0,
        /// MUTEVAL [6:6]
        /// Mute value
        MUTEVAL: u1 = 0,
        /// MUTECN [7:12]
        /// Mute counter
        MUTECN: u6 = 0,
        /// CPL [13:13]
        /// Complement bit
        CPL: u1 = 0,
        /// COMP [14:15]
        /// Companding mode
        COMP: u2 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AConfiguration register 2
    pub const ACR2 = Register(ACR2_val).init(base_address + 0x8);

    /// AFRCR
    const AFRCR_val = packed struct {
        /// FRL [0:7]
        /// Frame length
        FRL: u8 = 7,
        /// FSALL [8:14]
        /// Frame synchronization active level
        FSALL: u7 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// FSDEF [16:16]
        /// Frame synchronization
        FSDEF: u1 = 0,
        /// FSPOL [17:17]
        /// Frame synchronization
        FSPOL: u1 = 0,
        /// FSOFF [18:18]
        /// Frame synchronization
        FSOFF: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// AFRCR
    pub const AFRCR = Register(AFRCR_val).init(base_address + 0xc);

    /// ASLOTR
    const ASLOTR_val = packed struct {
        /// FBOFF [0:4]
        /// First bit offset
        FBOFF: u5 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// SLOTSZ [6:7]
        /// Slot size
        SLOTSZ: u2 = 0,
        /// NBSLOT [8:11]
        /// Number of slots in an audio
        NBSLOT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SLOTEN [16:31]
        /// Slot enable
        SLOTEN: u16 = 0,
    };
    /// ASlot register
    pub const ASLOTR = Register(ASLOTR_val).init(base_address + 0x10);

    /// AIM
    const AIM_val = packed struct {
        /// OVRUDRIE [0:0]
        /// Overrun/underrun interrupt
        OVRUDRIE: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection interrupt
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration interrupt
        WCKCFG: u1 = 0,
        /// FREQIE [3:3]
        /// FIFO request interrupt
        FREQIE: u1 = 0,
        /// CNRDYIE [4:4]
        /// Codec not ready interrupt
        CNRDYIE: u1 = 0,
        /// AFSDETIE [5:5]
        /// Anticipated frame synchronization
        AFSDETIE: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization detection
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AInterrupt mask register2
    pub const AIM = Register(AIM_val).init(base_address + 0x14);

    /// ASR
    const ASR_val = packed struct {
        /// OVRUDR [0:0]
        /// Overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration flag. This bit
        WCKCFG: u1 = 0,
        /// FREQ [3:3]
        /// FIFO request
        FREQ: u1 = 0,
        /// CNRDY [4:4]
        /// Codec not ready
        CNRDY: u1 = 0,
        /// AFSDET [5:5]
        /// Anticipated frame synchronization
        AFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// FLVL [16:18]
        /// FIFO level threshold
        FLVL: u3 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// AStatus register
    pub const ASR = Register(ASR_val).init(base_address + 0x18);

    /// ACLRFR
    const ACLRFR_val = packed struct {
        /// OVRUDR [0:0]
        /// Clear overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection flag
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Clear wrong clock configuration
        WCKCFG: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// CNRDY [4:4]
        /// Clear codec not ready flag
        CNRDY: u1 = 0,
        /// CAFSDET [5:5]
        /// Clear anticipated frame synchronization
        CAFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Clear late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AClear flag register
    pub const ACLRFR = Register(ACLRFR_val).init(base_address + 0x1c);

    /// ADR
    const ADR_val = packed struct {
        /// DATA [0:31]
        /// Data
        DATA: u32 = 0,
    };
    /// AData register
    pub const ADR = Register(ADR_val).init(base_address + 0x20);

    /// GCR
    const GCR_val = packed struct {
        /// SYNCIN [0:1]
        /// Synchronization inputs
        SYNCIN: u2 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// SYNCOUT [4:5]
        /// Synchronization outputs
        SYNCOUT: u2 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Global configuration register
    pub const GCR = Register(GCR_val).init(base_address + 0x0);
};

/// Serial audio interface
pub const SAI2 = struct {
    const base_address = 0x40015c00;
    /// BCR1
    const BCR1_val = packed struct {
        /// MODE [0:1]
        /// Audio block mode
        MODE: u2 = 0,
        /// PRTCFG [2:3]
        /// Protocol configuration
        PRTCFG: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// DS [5:7]
        /// Data size
        DS: u3 = 2,
        /// LSBFIRST [8:8]
        /// Least significant bit
        LSBFIRST: u1 = 0,
        /// CKSTR [9:9]
        /// Clock strobing edge
        CKSTR: u1 = 0,
        /// SYNCEN [10:11]
        /// Synchronization enable
        SYNCEN: u2 = 0,
        /// MONO [12:12]
        /// Mono mode
        MONO: u1 = 0,
        /// OutDri [13:13]
        /// Output drive
        OutDri: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// SAIBEN [16:16]
        /// Audio block B enable
        SAIBEN: u1 = 0,
        /// DMAEN [17:17]
        /// DMA enable
        DMAEN: u1 = 0,
        /// unused [18:18]
        _unused18: u1 = 0,
        /// NODIV [19:19]
        /// No divider
        NODIV: u1 = 0,
        /// MCKDIV [20:23]
        /// Master clock divider
        MCKDIV: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// BConfiguration register 1
    pub const BCR1 = Register(BCR1_val).init(base_address + 0x24);

    /// BCR2
    const BCR2_val = packed struct {
        /// FTH [0:2]
        /// FIFO threshold
        FTH: u3 = 0,
        /// FFLUS [3:3]
        /// FIFO flush
        FFLUS: u1 = 0,
        /// TRIS [4:4]
        /// Tristate management on data
        TRIS: u1 = 0,
        /// MUTE [5:5]
        /// Mute
        MUTE: u1 = 0,
        /// MUTEVAL [6:6]
        /// Mute value
        MUTEVAL: u1 = 0,
        /// MUTECN [7:12]
        /// Mute counter
        MUTECN: u6 = 0,
        /// CPL [13:13]
        /// Complement bit
        CPL: u1 = 0,
        /// COMP [14:15]
        /// Companding mode
        COMP: u2 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BConfiguration register 2
    pub const BCR2 = Register(BCR2_val).init(base_address + 0x28);

    /// BFRCR
    const BFRCR_val = packed struct {
        /// FRL [0:7]
        /// Frame length
        FRL: u8 = 7,
        /// FSALL [8:14]
        /// Frame synchronization active level
        FSALL: u7 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// FSDEF [16:16]
        /// Frame synchronization
        FSDEF: u1 = 0,
        /// FSPOL [17:17]
        /// Frame synchronization
        FSPOL: u1 = 0,
        /// FSOFF [18:18]
        /// Frame synchronization
        FSOFF: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// BFRCR
    pub const BFRCR = Register(BFRCR_val).init(base_address + 0x2c);

    /// BSLOTR
    const BSLOTR_val = packed struct {
        /// FBOFF [0:4]
        /// First bit offset
        FBOFF: u5 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// SLOTSZ [6:7]
        /// Slot size
        SLOTSZ: u2 = 0,
        /// NBSLOT [8:11]
        /// Number of slots in an audio
        NBSLOT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SLOTEN [16:31]
        /// Slot enable
        SLOTEN: u16 = 0,
    };
    /// BSlot register
    pub const BSLOTR = Register(BSLOTR_val).init(base_address + 0x30);

    /// BIM
    const BIM_val = packed struct {
        /// OVRUDRIE [0:0]
        /// Overrun/underrun interrupt
        OVRUDRIE: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection interrupt
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration interrupt
        WCKCFG: u1 = 0,
        /// FREQIE [3:3]
        /// FIFO request interrupt
        FREQIE: u1 = 0,
        /// CNRDYIE [4:4]
        /// Codec not ready interrupt
        CNRDYIE: u1 = 0,
        /// AFSDETIE [5:5]
        /// Anticipated frame synchronization
        AFSDETIE: u1 = 0,
        /// LFSDETIE [6:6]
        /// Late frame synchronization detection
        LFSDETIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BInterrupt mask register2
    pub const BIM = Register(BIM_val).init(base_address + 0x34);

    /// BSR
    const BSR_val = packed struct {
        /// OVRUDR [0:0]
        /// Overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration
        WCKCFG: u1 = 0,
        /// FREQ [3:3]
        /// FIFO request
        FREQ: u1 = 0,
        /// CNRDY [4:4]
        /// Codec not ready
        CNRDY: u1 = 0,
        /// AFSDET [5:5]
        /// Anticipated frame synchronization
        AFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// FLVL [16:18]
        /// FIFO level threshold
        FLVL: u3 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// BStatus register
    pub const BSR = Register(BSR_val).init(base_address + 0x38);

    /// BCLRFR
    const BCLRFR_val = packed struct {
        /// OVRUDR [0:0]
        /// Clear overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection flag
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Clear wrong clock configuration
        WCKCFG: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// CNRDY [4:4]
        /// Clear codec not ready flag
        CNRDY: u1 = 0,
        /// CAFSDET [5:5]
        /// Clear anticipated frame synchronization
        CAFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Clear late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// BClear flag register
    pub const BCLRFR = Register(BCLRFR_val).init(base_address + 0x3c);

    /// BDR
    const BDR_val = packed struct {
        /// DATA [0:31]
        /// Data
        DATA: u32 = 0,
    };
    /// BData register
    pub const BDR = Register(BDR_val).init(base_address + 0x40);

    /// ACR1
    const ACR1_val = packed struct {
        /// MODE [0:1]
        /// Audio block mode
        MODE: u2 = 0,
        /// PRTCFG [2:3]
        /// Protocol configuration
        PRTCFG: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// DS [5:7]
        /// Data size
        DS: u3 = 2,
        /// LSBFIRST [8:8]
        /// Least significant bit
        LSBFIRST: u1 = 0,
        /// CKSTR [9:9]
        /// Clock strobing edge
        CKSTR: u1 = 0,
        /// SYNCEN [10:11]
        /// Synchronization enable
        SYNCEN: u2 = 0,
        /// MONO [12:12]
        /// Mono mode
        MONO: u1 = 0,
        /// OutDri [13:13]
        /// Output drive
        OutDri: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// SAIAEN [16:16]
        /// Audio block A enable
        SAIAEN: u1 = 0,
        /// DMAEN [17:17]
        /// DMA enable
        DMAEN: u1 = 0,
        /// unused [18:18]
        _unused18: u1 = 0,
        /// NODIV [19:19]
        /// No divider
        NODIV: u1 = 0,
        /// MCKDIV [20:23]
        /// Master clock divider
        MCKDIV: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// AConfiguration register 1
    pub const ACR1 = Register(ACR1_val).init(base_address + 0x4);

    /// ACR2
    const ACR2_val = packed struct {
        /// FTH [0:2]
        /// FIFO threshold
        FTH: u3 = 0,
        /// FFLUS [3:3]
        /// FIFO flush
        FFLUS: u1 = 0,
        /// TRIS [4:4]
        /// Tristate management on data
        TRIS: u1 = 0,
        /// MUTE [5:5]
        /// Mute
        MUTE: u1 = 0,
        /// MUTEVAL [6:6]
        /// Mute value
        MUTEVAL: u1 = 0,
        /// MUTECN [7:12]
        /// Mute counter
        MUTECN: u6 = 0,
        /// CPL [13:13]
        /// Complement bit
        CPL: u1 = 0,
        /// COMP [14:15]
        /// Companding mode
        COMP: u2 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AConfiguration register 2
    pub const ACR2 = Register(ACR2_val).init(base_address + 0x8);

    /// AFRCR
    const AFRCR_val = packed struct {
        /// FRL [0:7]
        /// Frame length
        FRL: u8 = 7,
        /// FSALL [8:14]
        /// Frame synchronization active level
        FSALL: u7 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// FSDEF [16:16]
        /// Frame synchronization
        FSDEF: u1 = 0,
        /// FSPOL [17:17]
        /// Frame synchronization
        FSPOL: u1 = 0,
        /// FSOFF [18:18]
        /// Frame synchronization
        FSOFF: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// AFRCR
    pub const AFRCR = Register(AFRCR_val).init(base_address + 0xc);

    /// ASLOTR
    const ASLOTR_val = packed struct {
        /// FBOFF [0:4]
        /// First bit offset
        FBOFF: u5 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// SLOTSZ [6:7]
        /// Slot size
        SLOTSZ: u2 = 0,
        /// NBSLOT [8:11]
        /// Number of slots in an audio
        NBSLOT: u4 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// SLOTEN [16:31]
        /// Slot enable
        SLOTEN: u16 = 0,
    };
    /// ASlot register
    pub const ASLOTR = Register(ASLOTR_val).init(base_address + 0x10);

    /// AIM
    const AIM_val = packed struct {
        /// OVRUDRIE [0:0]
        /// Overrun/underrun interrupt
        OVRUDRIE: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection interrupt
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration interrupt
        WCKCFG: u1 = 0,
        /// FREQIE [3:3]
        /// FIFO request interrupt
        FREQIE: u1 = 0,
        /// CNRDYIE [4:4]
        /// Codec not ready interrupt
        CNRDYIE: u1 = 0,
        /// AFSDETIE [5:5]
        /// Anticipated frame synchronization
        AFSDETIE: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization detection
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AInterrupt mask register2
    pub const AIM = Register(AIM_val).init(base_address + 0x14);

    /// ASR
    const ASR_val = packed struct {
        /// OVRUDR [0:0]
        /// Overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Wrong clock configuration flag. This bit
        WCKCFG: u1 = 0,
        /// FREQ [3:3]
        /// FIFO request
        FREQ: u1 = 0,
        /// CNRDY [4:4]
        /// Codec not ready
        CNRDY: u1 = 0,
        /// AFSDET [5:5]
        /// Anticipated frame synchronization
        AFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:15]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        /// FLVL [16:18]
        /// FIFO level threshold
        FLVL: u3 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// AStatus register
    pub const ASR = Register(ASR_val).init(base_address + 0x18);

    /// ACLRFR
    const ACLRFR_val = packed struct {
        /// OVRUDR [0:0]
        /// Clear overrun / underrun
        OVRUDR: u1 = 0,
        /// MUTEDET [1:1]
        /// Mute detection flag
        MUTEDET: u1 = 0,
        /// WCKCFG [2:2]
        /// Clear wrong clock configuration
        WCKCFG: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// CNRDY [4:4]
        /// Clear codec not ready flag
        CNRDY: u1 = 0,
        /// CAFSDET [5:5]
        /// Clear anticipated frame synchronization
        CAFSDET: u1 = 0,
        /// LFSDET [6:6]
        /// Clear late frame synchronization
        LFSDET: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AClear flag register
    pub const ACLRFR = Register(ACLRFR_val).init(base_address + 0x1c);

    /// ADR
    const ADR_val = packed struct {
        /// DATA [0:31]
        /// Data
        DATA: u32 = 0,
    };
    /// AData register
    pub const ADR = Register(ADR_val).init(base_address + 0x20);

    /// GCR
    const GCR_val = packed struct {
        /// SYNCIN [0:1]
        /// Synchronization inputs
        SYNCIN: u2 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// SYNCOUT [4:5]
        /// Synchronization outputs
        SYNCOUT: u2 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Global configuration register
    pub const GCR = Register(GCR_val).init(base_address + 0x0);
};

/// DMA2D controller
pub const DMA2D = struct {
    const base_address = 0x4002b000;
    /// CR
    const CR_val = packed struct {
        /// START [0:0]
        /// Start
        START: u1 = 0,
        /// SUSP [1:1]
        /// Suspend
        SUSP: u1 = 0,
        /// ABORT [2:2]
        /// Abort
        ABORT: u1 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// TEIE [8:8]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// TCIE [9:9]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// TWIE [10:10]
        /// Transfer watermark interrupt
        TWIE: u1 = 0,
        /// CAEIE [11:11]
        /// CLUT access error interrupt
        CAEIE: u1 = 0,
        /// CTCIE [12:12]
        /// CLUT transfer complete interrupt
        CTCIE: u1 = 0,
        /// CEIE [13:13]
        /// Configuration Error Interrupt
        CEIE: u1 = 0,
        /// unused [14:15]
        _unused14: u2 = 0,
        /// MODE [16:17]
        /// DMA2D mode
        MODE: u2 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// ISR
    const ISR_val = packed struct {
        /// TEIF [0:0]
        /// Transfer error interrupt
        TEIF: u1 = 0,
        /// TCIF [1:1]
        /// Transfer complete interrupt
        TCIF: u1 = 0,
        /// TWIF [2:2]
        /// Transfer watermark interrupt
        TWIF: u1 = 0,
        /// CAEIF [3:3]
        /// CLUT access error interrupt
        CAEIF: u1 = 0,
        /// CTCIF [4:4]
        /// CLUT transfer complete interrupt
        CTCIF: u1 = 0,
        /// CEIF [5:5]
        /// Configuration error interrupt
        CEIF: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Status Register
    pub const ISR = Register(ISR_val).init(base_address + 0x4);

    /// IFCR
    const IFCR_val = packed struct {
        /// CTEIF [0:0]
        /// Clear Transfer error interrupt
        CTEIF: u1 = 0,
        /// CTCIF [1:1]
        /// Clear transfer complete interrupt
        CTCIF: u1 = 0,
        /// CTWIF [2:2]
        /// Clear transfer watermark interrupt
        CTWIF: u1 = 0,
        /// CAECIF [3:3]
        /// Clear CLUT access error interrupt
        CAECIF: u1 = 0,
        /// CCTCIF [4:4]
        /// Clear CLUT transfer complete interrupt
        CCTCIF: u1 = 0,
        /// CCEIF [5:5]
        /// Clear configuration error interrupt
        CCEIF: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt flag clear register
    pub const IFCR = Register(IFCR_val).init(base_address + 0x8);

    /// FGMAR
    const FGMAR_val = packed struct {
        /// MA [0:31]
        /// Memory address
        MA: u32 = 0,
    };
    /// foreground memory address
    pub const FGMAR = Register(FGMAR_val).init(base_address + 0xc);

    /// FGOR
    const FGOR_val = packed struct {
        /// LO [0:13]
        /// Line offset
        LO: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// foreground offset register
    pub const FGOR = Register(FGOR_val).init(base_address + 0x10);

    /// BGMAR
    const BGMAR_val = packed struct {
        /// MA [0:31]
        /// Memory address
        MA: u32 = 0,
    };
    /// background memory address
    pub const BGMAR = Register(BGMAR_val).init(base_address + 0x14);

    /// BGOR
    const BGOR_val = packed struct {
        /// LO [0:13]
        /// Line offset
        LO: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// background offset register
    pub const BGOR = Register(BGOR_val).init(base_address + 0x18);

    /// FGPFCCR
    const FGPFCCR_val = packed struct {
        /// CM [0:3]
        /// Color mode
        CM: u4 = 0,
        /// CCM [4:4]
        /// CLUT color mode
        CCM: u1 = 0,
        /// START [5:5]
        /// Start
        START: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// CS [8:15]
        /// CLUT size
        CS: u8 = 0,
        /// AM [16:17]
        /// Alpha mode
        AM: u2 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// ALPHA [24:31]
        /// Alpha value
        ALPHA: u8 = 0,
    };
    /// foreground PFC control
    pub const FGPFCCR = Register(FGPFCCR_val).init(base_address + 0x1c);

    /// FGCOLR
    const FGCOLR_val = packed struct {
        /// BLUE [0:7]
        /// Blue Value
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// Green Value
        GREEN: u8 = 0,
        /// RED [16:23]
        /// Red Value
        RED: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// foreground color register
    pub const FGCOLR = Register(FGCOLR_val).init(base_address + 0x20);

    /// BGPFCCR
    const BGPFCCR_val = packed struct {
        /// CM [0:3]
        /// Color mode
        CM: u4 = 0,
        /// CCM [4:4]
        /// CLUT Color mode
        CCM: u1 = 0,
        /// START [5:5]
        /// Start
        START: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// CS [8:15]
        /// CLUT size
        CS: u8 = 0,
        /// AM [16:17]
        /// Alpha mode
        AM: u2 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// ALPHA [24:31]
        /// Alpha value
        ALPHA: u8 = 0,
    };
    /// background PFC control
    pub const BGPFCCR = Register(BGPFCCR_val).init(base_address + 0x24);

    /// BGCOLR
    const BGCOLR_val = packed struct {
        /// BLUE [0:7]
        /// Blue Value
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// Green Value
        GREEN: u8 = 0,
        /// RED [16:23]
        /// Red Value
        RED: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// background color register
    pub const BGCOLR = Register(BGCOLR_val).init(base_address + 0x28);

    /// FGCMAR
    const FGCMAR_val = packed struct {
        /// MA [0:31]
        /// Memory Address
        MA: u32 = 0,
    };
    /// foreground CLUT memory address
    pub const FGCMAR = Register(FGCMAR_val).init(base_address + 0x2c);

    /// BGCMAR
    const BGCMAR_val = packed struct {
        /// MA [0:31]
        /// Memory address
        MA: u32 = 0,
    };
    /// background CLUT memory address
    pub const BGCMAR = Register(BGCMAR_val).init(base_address + 0x30);

    /// OPFCCR
    const OPFCCR_val = packed struct {
        /// CM [0:2]
        /// Color mode
        CM: u3 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// output PFC control register
    pub const OPFCCR = Register(OPFCCR_val).init(base_address + 0x34);

    /// OCOLR
    const OCOLR_val = packed struct {
        /// BLUE [0:7]
        /// Blue Value
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// Green Value
        GREEN: u8 = 0,
        /// RED [16:23]
        /// Red Value
        RED: u8 = 0,
        /// APLHA [24:31]
        /// Alpha Channel Value
        APLHA: u8 = 0,
    };
    /// output color register
    pub const OCOLR = Register(OCOLR_val).init(base_address + 0x38);

    /// OMAR
    const OMAR_val = packed struct {
        /// MA [0:31]
        /// Memory Address
        MA: u32 = 0,
    };
    /// output memory address register
    pub const OMAR = Register(OMAR_val).init(base_address + 0x3c);

    /// OOR
    const OOR_val = packed struct {
        /// LO [0:13]
        /// Line Offset
        LO: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// output offset register
    pub const OOR = Register(OOR_val).init(base_address + 0x40);

    /// NLR
    const NLR_val = packed struct {
        /// NL [0:15]
        /// Number of lines
        NL: u16 = 0,
        /// PL [16:29]
        /// Pixel per lines
        PL: u14 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// number of line register
    pub const NLR = Register(NLR_val).init(base_address + 0x44);

    /// LWR
    const LWR_val = packed struct {
        /// LW [0:15]
        /// Line watermark
        LW: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// line watermark register
    pub const LWR = Register(LWR_val).init(base_address + 0x48);

    /// AMTCR
    const AMTCR_val = packed struct {
        /// EN [0:0]
        /// Enable
        EN: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// DT [8:15]
        /// Dead Time
        DT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// AHB master timer configuration
    pub const AMTCR = Register(AMTCR_val).init(base_address + 0x4c);

    /// FGCLUT
    const FGCLUT_val = packed struct {
        /// BLUE [0:7]
        /// BLUE
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// GREEN
        GREEN: u8 = 0,
        /// RED [16:23]
        /// RED
        RED: u8 = 0,
        /// APLHA [24:31]
        /// APLHA
        APLHA: u8 = 0,
    };
    /// FGCLUT
    pub const FGCLUT = Register(FGCLUT_val).init(base_address + 0x400);

    /// BGCLUT
    const BGCLUT_val = packed struct {
        /// BLUE [0:7]
        /// BLUE
        BLUE: u8 = 0,
        /// GREEN [8:15]
        /// GREEN
        GREEN: u8 = 0,
        /// RED [16:23]
        /// RED
        RED: u8 = 0,
        /// APLHA [24:31]
        /// APLHA
        APLHA: u8 = 0,
    };
    /// BGCLUT
    pub const BGCLUT = Register(BGCLUT_val).init(base_address + 0x800);
};

/// QuadSPI interface
pub const QUADSPI = struct {
    const base_address = 0xa0001000;
    /// CR
    const CR_val = packed struct {
        /// EN [0:0]
        /// Enable
        EN: u1 = 0,
        /// ABORT [1:1]
        /// Abort request
        ABORT: u1 = 0,
        /// DMAEN [2:2]
        /// DMA enable
        DMAEN: u1 = 0,
        /// TCEN [3:3]
        /// Timeout counter enable
        TCEN: u1 = 0,
        /// SSHIFT [4:4]
        /// Sample shift
        SSHIFT: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// DFM [6:6]
        /// Dual-flash mode
        DFM: u1 = 0,
        /// FSEL [7:7]
        /// FLASH memory selection
        FSEL: u1 = 0,
        /// FTHRES [8:12]
        /// IFO threshold level
        FTHRES: u5 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// TEIE [16:16]
        /// Transfer error interrupt
        TEIE: u1 = 0,
        /// TCIE [17:17]
        /// Transfer complete interrupt
        TCIE: u1 = 0,
        /// FTIE [18:18]
        /// FIFO threshold interrupt
        FTIE: u1 = 0,
        /// SMIE [19:19]
        /// Status match interrupt
        SMIE: u1 = 0,
        /// TOIE [20:20]
        /// TimeOut interrupt enable
        TOIE: u1 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// APMS [22:22]
        /// Automatic poll mode stop
        APMS: u1 = 0,
        /// PMM [23:23]
        /// Polling match mode
        PMM: u1 = 0,
        /// PRESCALER [24:31]
        /// Clock prescaler
        PRESCALER: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// DCR
    const DCR_val = packed struct {
        /// CKMODE [0:0]
        /// Mode 0 / mode 3
        CKMODE: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// CSHT [8:10]
        /// Chip select high time
        CSHT: u3 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// FSIZE [16:20]
        /// FLASH memory size
        FSIZE: u5 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// device configuration register
    pub const DCR = Register(DCR_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// TEF [0:0]
        /// Transfer error flag
        TEF: u1 = 0,
        /// TCF [1:1]
        /// Transfer complete flag
        TCF: u1 = 0,
        /// FTF [2:2]
        /// FIFO threshold flag
        FTF: u1 = 0,
        /// SMF [3:3]
        /// Status match flag
        SMF: u1 = 0,
        /// TOF [4:4]
        /// Timeout flag
        TOF: u1 = 0,
        /// BUSY [5:5]
        /// Busy
        BUSY: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// FLEVEL [8:14]
        /// FIFO level
        FLEVEL: u7 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// FCR
    const FCR_val = packed struct {
        /// CTEF [0:0]
        /// Clear transfer error flag
        CTEF: u1 = 0,
        /// CTCF [1:1]
        /// Clear transfer complete
        CTCF: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// CSMF [3:3]
        /// Clear status match flag
        CSMF: u1 = 0,
        /// CTOF [4:4]
        /// Clear timeout flag
        CTOF: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// flag clear register
    pub const FCR = Register(FCR_val).init(base_address + 0xc);

    /// DLR
    const DLR_val = packed struct {
        /// DL [0:31]
        /// Data length
        DL: u32 = 0,
    };
    /// data length register
    pub const DLR = Register(DLR_val).init(base_address + 0x10);

    /// CCR
    const CCR_val = packed struct {
        /// INSTRUCTION [0:7]
        /// Instruction
        INSTRUCTION: u8 = 0,
        /// IMODE [8:9]
        /// Instruction mode
        IMODE: u2 = 0,
        /// ADMODE [10:11]
        /// Address mode
        ADMODE: u2 = 0,
        /// ADSIZE [12:13]
        /// Address size
        ADSIZE: u2 = 0,
        /// ABMODE [14:15]
        /// Alternate bytes mode
        ABMODE: u2 = 0,
        /// ABSIZE [16:17]
        /// Alternate bytes size
        ABSIZE: u2 = 0,
        /// DCYC [18:22]
        /// Number of dummy cycles
        DCYC: u5 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// DMODE [24:25]
        /// Data mode
        DMODE: u2 = 0,
        /// FMODE [26:27]
        /// Functional mode
        FMODE: u2 = 0,
        /// SIOO [28:28]
        /// Send instruction only once
        SIOO: u1 = 0,
        /// unused [29:29]
        _unused29: u1 = 0,
        /// DHHC [30:30]
        /// DDR hold half cycle
        DHHC: u1 = 0,
        /// DDRM [31:31]
        /// Double data rate mode
        DDRM: u1 = 0,
    };
    /// communication configuration
    pub const CCR = Register(CCR_val).init(base_address + 0x14);

    /// AR
    const AR_val = packed struct {
        /// ADDRESS [0:31]
        /// Address
        ADDRESS: u32 = 0,
    };
    /// address register
    pub const AR = Register(AR_val).init(base_address + 0x18);

    /// ABR
    const ABR_val = packed struct {
        /// ALTERNATE [0:31]
        /// ALTERNATE
        ALTERNATE: u32 = 0,
    };
    /// ABR
    pub const ABR = Register(ABR_val).init(base_address + 0x1c);

    /// DR
    const DR_val = packed struct {
        /// DATA [0:31]
        /// Data
        DATA: u32 = 0,
    };
    /// data register
    pub const DR = Register(DR_val).init(base_address + 0x20);

    /// PSMKR
    const PSMKR_val = packed struct {
        /// MASK [0:31]
        /// Status mask
        MASK: u32 = 0,
    };
    /// polling status mask register
    pub const PSMKR = Register(PSMKR_val).init(base_address + 0x24);

    /// PSMAR
    const PSMAR_val = packed struct {
        /// MATCH [0:31]
        /// Status match
        MATCH: u32 = 0,
    };
    /// polling status match register
    pub const PSMAR = Register(PSMAR_val).init(base_address + 0x28);

    /// PIR
    const PIR_val = packed struct {
        /// INTERVAL [0:15]
        /// Polling interval
        INTERVAL: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// polling interval register
    pub const PIR = Register(PIR_val).init(base_address + 0x2c);

    /// LPTR
    const LPTR_val = packed struct {
        /// TIMEOUT [0:15]
        /// Timeout period
        TIMEOUT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// low-power timeout register
    pub const LPTR = Register(LPTR_val).init(base_address + 0x30);
};

/// HDMI-CEC controller
pub const CEC = struct {
    const base_address = 0x40006c00;
    /// CR
    const CR_val = packed struct {
        /// CECEN [0:0]
        /// CEC Enable
        CECEN: u1 = 0,
        /// TXSOM [1:1]
        /// Tx start of message
        TXSOM: u1 = 0,
        /// TXEOM [2:2]
        /// Tx End Of Message
        TXEOM: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// CFGR
    const CFGR_val = packed struct {
        /// SFT [0:2]
        /// Signal Free Time
        SFT: u3 = 0,
        /// RXTOL [3:3]
        /// Rx-Tolerance
        RXTOL: u1 = 0,
        /// BRESTP [4:4]
        /// Rx-stop on bit rising
        BRESTP: u1 = 0,
        /// BREGEN [5:5]
        /// Generate error-bit on bit rising
        BREGEN: u1 = 0,
        /// LBPEGEN [6:6]
        /// Generate Error-Bit on Long Bit Period
        LBPEGEN: u1 = 0,
        /// BRDNOGEN [7:7]
        /// Avoid Error-Bit Generation in
        BRDNOGEN: u1 = 0,
        /// SFTOP [8:8]
        /// SFT Option Bit
        SFTOP: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// OAR [16:30]
        /// Own addresses
        OAR: u15 = 0,
        /// LSTN [31:31]
        /// Listen mode
        LSTN: u1 = 0,
    };
    /// configuration register
    pub const CFGR = Register(CFGR_val).init(base_address + 0x4);

    /// TXDR
    const TXDR_val = packed struct {
        /// TXD [0:7]
        /// Tx Data register
        TXD: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Tx data register
    pub const TXDR = Register(TXDR_val).init(base_address + 0x8);

    /// RXDR
    const RXDR_val = packed struct {
        /// RXDR [0:7]
        /// CEC Rx Data Register
        RXDR: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Rx Data Register
    pub const RXDR = Register(RXDR_val).init(base_address + 0xc);

    /// ISR
    const ISR_val = packed struct {
        /// RXBR [0:0]
        /// Rx-Byte Received
        RXBR: u1 = 0,
        /// RXEND [1:1]
        /// End Of Reception
        RXEND: u1 = 0,
        /// RXOVR [2:2]
        /// Rx-Overrun
        RXOVR: u1 = 0,
        /// BRE [3:3]
        /// Rx-Bit rising error
        BRE: u1 = 0,
        /// SBPE [4:4]
        /// Rx-Short Bit period error
        SBPE: u1 = 0,
        /// LBPE [5:5]
        /// Rx-Long Bit Period Error
        LBPE: u1 = 0,
        /// RXACKE [6:6]
        /// Rx-Missing Acknowledge
        RXACKE: u1 = 0,
        /// ARBLST [7:7]
        /// Arbitration Lost
        ARBLST: u1 = 0,
        /// TXBR [8:8]
        /// Tx-Byte Request
        TXBR: u1 = 0,
        /// TXEND [9:9]
        /// End of Transmission
        TXEND: u1 = 0,
        /// TXUDR [10:10]
        /// Tx-Buffer Underrun
        TXUDR: u1 = 0,
        /// TXERR [11:11]
        /// Tx-Error
        TXERR: u1 = 0,
        /// TXACKE [12:12]
        /// Tx-Missing acknowledge
        TXACKE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt and Status Register
    pub const ISR = Register(ISR_val).init(base_address + 0x10);

    /// IER
    const IER_val = packed struct {
        /// RXBRIE [0:0]
        /// Rx-Byte Received Interrupt
        RXBRIE: u1 = 0,
        /// RXENDIE [1:1]
        /// End Of Reception Interrupt
        RXENDIE: u1 = 0,
        /// RXOVRIE [2:2]
        /// Rx-Buffer Overrun Interrupt
        RXOVRIE: u1 = 0,
        /// BREIE [3:3]
        /// Bit Rising Error Interrupt
        BREIE: u1 = 0,
        /// SBPEIE [4:4]
        /// Short Bit Period Error Interrupt
        SBPEIE: u1 = 0,
        /// LBPEIE [5:5]
        /// Long Bit Period Error Interrupt
        LBPEIE: u1 = 0,
        /// RXACKIE [6:6]
        /// Rx-Missing Acknowledge Error Interrupt
        RXACKIE: u1 = 0,
        /// ARBLSTIE [7:7]
        /// Arbitration Lost Interrupt
        ARBLSTIE: u1 = 0,
        /// TXBRIE [8:8]
        /// Tx-Byte Request Interrupt
        TXBRIE: u1 = 0,
        /// TXENDIE [9:9]
        /// Tx-End of message interrupt
        TXENDIE: u1 = 0,
        /// TXUDRIE [10:10]
        /// Tx-Underrun interrupt
        TXUDRIE: u1 = 0,
        /// TXERRIE [11:11]
        /// Tx-Error Interrupt Enable
        TXERRIE: u1 = 0,
        /// TXACKIE [12:12]
        /// Tx-Missing Acknowledge Error Interrupt
        TXACKIE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// interrupt enable register
    pub const IER = Register(IER_val).init(base_address + 0x14);
};

/// Receiver Interface
pub const SPDIFRX = struct {
    const base_address = 0x40004000;
    /// CR
    const CR_val = packed struct {
        /// SPDIFEN [0:1]
        /// Peripheral Block Enable
        SPDIFEN: u2 = 0,
        /// RXDMAEN [2:2]
        /// Receiver DMA ENable for data
        RXDMAEN: u1 = 0,
        /// RXSTEO [3:3]
        /// STerEO Mode
        RXSTEO: u1 = 0,
        /// DRFMT [4:5]
        /// RX Data format
        DRFMT: u2 = 0,
        /// PMSK [6:6]
        /// Mask Parity error bit
        PMSK: u1 = 0,
        /// VMSK [7:7]
        /// Mask of Validity bit
        VMSK: u1 = 0,
        /// CUMSK [8:8]
        /// Mask of channel status and user
        CUMSK: u1 = 0,
        /// PTMSK [9:9]
        /// Mask of Preamble Type bits
        PTMSK: u1 = 0,
        /// CBDMAEN [10:10]
        /// Control Buffer DMA ENable for control
        CBDMAEN: u1 = 0,
        /// CHSEL [11:11]
        /// Channel Selection
        CHSEL: u1 = 0,
        /// NBTR [12:13]
        /// Maximum allowed re-tries during
        NBTR: u2 = 0,
        /// WFA [14:14]
        /// Wait For Activity
        WFA: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// INSEL [16:18]
        /// input selection
        INSEL: u3 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Control register
    pub const CR = Register(CR_val).init(base_address + 0x0);

    /// IMR
    const IMR_val = packed struct {
        /// RXNEIE [0:0]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// CSRNEIE [1:1]
        /// Control Buffer Ready Interrupt
        CSRNEIE: u1 = 0,
        /// PERRIE [2:2]
        /// Parity error interrupt
        PERRIE: u1 = 0,
        /// OVRIE [3:3]
        /// Overrun error Interrupt
        OVRIE: u1 = 0,
        /// SBLKIE [4:4]
        /// Synchronization Block Detected Interrupt
        SBLKIE: u1 = 0,
        /// SYNCDIE [5:5]
        /// Synchronization Done
        SYNCDIE: u1 = 0,
        /// IFEIE [6:6]
        /// Serial Interface Error Interrupt
        IFEIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt mask register
    pub const IMR = Register(IMR_val).init(base_address + 0x4);

    /// SR
    const SR_val = packed struct {
        /// RXNE [0:0]
        /// Read data register not
        RXNE: u1 = 0,
        /// CSRNE [1:1]
        /// Control Buffer register is not
        CSRNE: u1 = 0,
        /// PERR [2:2]
        /// Parity error
        PERR: u1 = 0,
        /// OVR [3:3]
        /// Overrun error
        OVR: u1 = 0,
        /// SBD [4:4]
        /// Synchronization Block
        SBD: u1 = 0,
        /// SYNCD [5:5]
        /// Synchronization Done
        SYNCD: u1 = 0,
        /// FERR [6:6]
        /// Framing error
        FERR: u1 = 0,
        /// SERR [7:7]
        /// Synchronization error
        SERR: u1 = 0,
        /// TERR [8:8]
        /// Time-out error
        TERR: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// WIDTH5 [16:30]
        /// Duration of 5 symbols counted with
        WIDTH5: u15 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// Status register
    pub const SR = Register(SR_val).init(base_address + 0x8);

    /// IFCR
    const IFCR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// PERRCF [2:2]
        /// Clears the Parity error
        PERRCF: u1 = 0,
        /// OVRCF [3:3]
        /// Clears the Overrun error
        OVRCF: u1 = 0,
        /// SBDCF [4:4]
        /// Clears the Synchronization Block
        SBDCF: u1 = 0,
        /// SYNCDCF [5:5]
        /// Clears the Synchronization Done
        SYNCDCF: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Flag Clear register
    pub const IFCR = Register(IFCR_val).init(base_address + 0xc);

    /// DR
    const DR_val = packed struct {
        /// DR [0:23]
        /// Parity Error bit
        DR: u24 = 0,
        /// PE [24:24]
        /// Parity Error bit
        PE: u1 = 0,
        /// V [25:25]
        /// Validity bit
        V: u1 = 0,
        /// U [26:26]
        /// User bit
        U: u1 = 0,
        /// C [27:27]
        /// Channel Status bit
        C: u1 = 0,
        /// PT [28:29]
        /// Preamble Type
        PT: u2 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Data input register
    pub const DR = Register(DR_val).init(base_address + 0x10);

    /// CSR
    const CSR_val = packed struct {
        /// USR [0:15]
        /// User data information
        USR: u16 = 0,
        /// CS [16:23]
        /// Channel A status
        CS: u8 = 0,
        /// SOB [24:24]
        /// Start Of Block
        SOB: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Channel Status register
    pub const CSR = Register(CSR_val).init(base_address + 0x14);

    /// DIR
    const DIR_val = packed struct {
        /// THI [0:12]
        /// Threshold HIGH
        THI: u13 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// TLO [16:28]
        /// Threshold LOW
        TLO: u13 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Debug Information register
    pub const DIR = Register(DIR_val).init(base_address + 0x18);
};

/// Secure digital input/output
pub const SDMMC1 = struct {
    const base_address = 0x40012c00;
    /// POWER
    const POWER_val = packed struct {
        /// PWRCTRL [0:1]
        /// PWRCTRL
        PWRCTRL: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// power control register
    pub const POWER = Register(POWER_val).init(base_address + 0x0);

    /// CLKCR
    const CLKCR_val = packed struct {
        /// CLKDIV [0:7]
        /// Clock divide factor
        CLKDIV: u8 = 0,
        /// CLKEN [8:8]
        /// Clock enable bit
        CLKEN: u1 = 0,
        /// PWRSAV [9:9]
        /// Power saving configuration
        PWRSAV: u1 = 0,
        /// BYPASS [10:10]
        /// Clock divider bypass enable
        BYPASS: u1 = 0,
        /// WIDBUS [11:12]
        /// Wide bus mode enable bit
        WIDBUS: u2 = 0,
        /// NEGEDGE [13:13]
        /// SDIO_CK dephasing selection
        NEGEDGE: u1 = 0,
        /// HWFC_EN [14:14]
        /// HW Flow Control enable
        HWFC_EN: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDI clock control register
    pub const CLKCR = Register(CLKCR_val).init(base_address + 0x4);

    /// ARG
    const ARG_val = packed struct {
        /// CMDARG [0:31]
        /// Command argument
        CMDARG: u32 = 0,
    };
    /// argument register
    pub const ARG = Register(ARG_val).init(base_address + 0x8);

    /// CMD
    const CMD_val = packed struct {
        /// CMDINDEX [0:5]
        /// Command index
        CMDINDEX: u6 = 0,
        /// WAITRESP [6:7]
        /// Wait for response bits
        WAITRESP: u2 = 0,
        /// WAITINT [8:8]
        /// CPSM waits for interrupt
        WAITINT: u1 = 0,
        /// WAITPEND [9:9]
        /// CPSM Waits for ends of data transfer
        WAITPEND: u1 = 0,
        /// CPSMEN [10:10]
        /// Command path state machine (CPSM) Enable
        CPSMEN: u1 = 0,
        /// SDIOSuspend [11:11]
        /// SD I/O suspend command
        SDIOSuspend: u1 = 0,
        /// ENCMDcompl [12:12]
        /// Enable CMD completion
        ENCMDcompl: u1 = 0,
        /// nIEN [13:13]
        /// not Interrupt Enable
        nIEN: u1 = 0,
        /// CE_ATACMD [14:14]
        /// CE-ATA command
        CE_ATACMD: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// command register
    pub const CMD = Register(CMD_val).init(base_address + 0xc);

    /// RESPCMD
    const RESPCMD_val = packed struct {
        /// RESPCMD [0:5]
        /// Response command index
        RESPCMD: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// command response register
    pub const RESPCMD = Register(RESPCMD_val).init(base_address + 0x10);

    /// RESP1
    const RESP1_val = packed struct {
        /// CARDSTATUS1 [0:31]
        /// see Table 132
        CARDSTATUS1: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP1 = Register(RESP1_val).init(base_address + 0x14);

    /// RESP2
    const RESP2_val = packed struct {
        /// CARDSTATUS2 [0:31]
        /// see Table 132
        CARDSTATUS2: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP2 = Register(RESP2_val).init(base_address + 0x18);

    /// RESP3
    const RESP3_val = packed struct {
        /// CARDSTATUS3 [0:31]
        /// see Table 132
        CARDSTATUS3: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP3 = Register(RESP3_val).init(base_address + 0x1c);

    /// RESP4
    const RESP4_val = packed struct {
        /// CARDSTATUS4 [0:31]
        /// see Table 132
        CARDSTATUS4: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP4 = Register(RESP4_val).init(base_address + 0x20);

    /// DTIMER
    const DTIMER_val = packed struct {
        /// DATATIME [0:31]
        /// Data timeout period
        DATATIME: u32 = 0,
    };
    /// data timer register
    pub const DTIMER = Register(DTIMER_val).init(base_address + 0x24);

    /// DLEN
    const DLEN_val = packed struct {
        /// DATALENGTH [0:24]
        /// Data length value
        DATALENGTH: u25 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// data length register
    pub const DLEN = Register(DLEN_val).init(base_address + 0x28);

    /// DCTRL
    const DCTRL_val = packed struct {
        /// DTEN [0:0]
        /// DTEN
        DTEN: u1 = 0,
        /// DTDIR [1:1]
        /// Data transfer direction
        DTDIR: u1 = 0,
        /// DTMODE [2:2]
        /// Data transfer mode selection 1: Stream
        DTMODE: u1 = 0,
        /// DMAEN [3:3]
        /// DMA enable bit
        DMAEN: u1 = 0,
        /// DBLOCKSIZE [4:7]
        /// Data block size
        DBLOCKSIZE: u4 = 0,
        /// RWSTART [8:8]
        /// Read wait start
        RWSTART: u1 = 0,
        /// RWSTOP [9:9]
        /// Read wait stop
        RWSTOP: u1 = 0,
        /// RWMOD [10:10]
        /// Read wait mode
        RWMOD: u1 = 0,
        /// SDIOEN [11:11]
        /// SD I/O enable functions
        SDIOEN: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data control register
    pub const DCTRL = Register(DCTRL_val).init(base_address + 0x2c);

    /// DCOUNT
    const DCOUNT_val = packed struct {
        /// DATACOUNT [0:24]
        /// Data count value
        DATACOUNT: u25 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// data counter register
    pub const DCOUNT = Register(DCOUNT_val).init(base_address + 0x30);

    /// STA
    const STA_val = packed struct {
        /// CCRCFAIL [0:0]
        /// Command response received (CRC check
        CCRCFAIL: u1 = 0,
        /// DCRCFAIL [1:1]
        /// Data block sent/received (CRC check
        DCRCFAIL: u1 = 0,
        /// CTIMEOUT [2:2]
        /// Command response timeout
        CTIMEOUT: u1 = 0,
        /// DTIMEOUT [3:3]
        /// Data timeout
        DTIMEOUT: u1 = 0,
        /// TXUNDERR [4:4]
        /// Transmit FIFO underrun
        TXUNDERR: u1 = 0,
        /// RXOVERR [5:5]
        /// Received FIFO overrun
        RXOVERR: u1 = 0,
        /// CMDREND [6:6]
        /// Command response received (CRC check
        CMDREND: u1 = 0,
        /// CMDSENT [7:7]
        /// Command sent (no response
        CMDSENT: u1 = 0,
        /// DATAEND [8:8]
        /// Data end (data counter, SDIDCOUNT, is
        DATAEND: u1 = 0,
        /// STBITERR [9:9]
        /// Start bit not detected on all data
        STBITERR: u1 = 0,
        /// DBCKEND [10:10]
        /// Data block sent/received (CRC check
        DBCKEND: u1 = 0,
        /// CMDACT [11:11]
        /// Command transfer in
        CMDACT: u1 = 0,
        /// TXACT [12:12]
        /// Data transmit in progress
        TXACT: u1 = 0,
        /// RXACT [13:13]
        /// Data receive in progress
        RXACT: u1 = 0,
        /// TXFIFOHE [14:14]
        /// Transmit FIFO half empty: at least 8
        TXFIFOHE: u1 = 0,
        /// RXFIFOHF [15:15]
        /// Receive FIFO half full: there are at
        RXFIFOHF: u1 = 0,
        /// TXFIFOF [16:16]
        /// Transmit FIFO full
        TXFIFOF: u1 = 0,
        /// RXFIFOF [17:17]
        /// Receive FIFO full
        RXFIFOF: u1 = 0,
        /// TXFIFOE [18:18]
        /// Transmit FIFO empty
        TXFIFOE: u1 = 0,
        /// RXFIFOE [19:19]
        /// Receive FIFO empty
        RXFIFOE: u1 = 0,
        /// TXDAVL [20:20]
        /// Data available in transmit
        TXDAVL: u1 = 0,
        /// RXDAVL [21:21]
        /// Data available in receive
        RXDAVL: u1 = 0,
        /// SDIOIT [22:22]
        /// SDIO interrupt received
        SDIOIT: u1 = 0,
        /// CEATAEND [23:23]
        /// CE-ATA command completion signal
        CEATAEND: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// status register
    pub const STA = Register(STA_val).init(base_address + 0x34);

    /// ICR
    const ICR_val = packed struct {
        /// CCRCFAILC [0:0]
        /// CCRCFAIL flag clear bit
        CCRCFAILC: u1 = 0,
        /// DCRCFAILC [1:1]
        /// DCRCFAIL flag clear bit
        DCRCFAILC: u1 = 0,
        /// CTIMEOUTC [2:2]
        /// CTIMEOUT flag clear bit
        CTIMEOUTC: u1 = 0,
        /// DTIMEOUTC [3:3]
        /// DTIMEOUT flag clear bit
        DTIMEOUTC: u1 = 0,
        /// TXUNDERRC [4:4]
        /// TXUNDERR flag clear bit
        TXUNDERRC: u1 = 0,
        /// RXOVERRC [5:5]
        /// RXOVERR flag clear bit
        RXOVERRC: u1 = 0,
        /// CMDRENDC [6:6]
        /// CMDREND flag clear bit
        CMDRENDC: u1 = 0,
        /// CMDSENTC [7:7]
        /// CMDSENT flag clear bit
        CMDSENTC: u1 = 0,
        /// DATAENDC [8:8]
        /// DATAEND flag clear bit
        DATAENDC: u1 = 0,
        /// STBITERRC [9:9]
        /// STBITERR flag clear bit
        STBITERRC: u1 = 0,
        /// DBCKENDC [10:10]
        /// DBCKEND flag clear bit
        DBCKENDC: u1 = 0,
        /// unused [11:21]
        _unused11: u5 = 0,
        _unused16: u6 = 0,
        /// SDIOITC [22:22]
        /// SDIOIT flag clear bit
        SDIOITC: u1 = 0,
        /// CEATAENDC [23:23]
        /// CEATAEND flag clear bit
        CEATAENDC: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x38);

    /// MASK
    const MASK_val = packed struct {
        /// CCRCFAILIE [0:0]
        /// Command CRC fail interrupt
        CCRCFAILIE: u1 = 0,
        /// DCRCFAILIE [1:1]
        /// Data CRC fail interrupt
        DCRCFAILIE: u1 = 0,
        /// CTIMEOUTIE [2:2]
        /// Command timeout interrupt
        CTIMEOUTIE: u1 = 0,
        /// DTIMEOUTIE [3:3]
        /// Data timeout interrupt
        DTIMEOUTIE: u1 = 0,
        /// TXUNDERRIE [4:4]
        /// Tx FIFO underrun error interrupt
        TXUNDERRIE: u1 = 0,
        /// RXOVERRIE [5:5]
        /// Rx FIFO overrun error interrupt
        RXOVERRIE: u1 = 0,
        /// CMDRENDIE [6:6]
        /// Command response received interrupt
        CMDRENDIE: u1 = 0,
        /// CMDSENTIE [7:7]
        /// Command sent interrupt
        CMDSENTIE: u1 = 0,
        /// DATAENDIE [8:8]
        /// Data end interrupt enable
        DATAENDIE: u1 = 0,
        /// STBITERRIE [9:9]
        /// Start bit error interrupt
        STBITERRIE: u1 = 0,
        /// DBCKENDIE [10:10]
        /// Data block end interrupt
        DBCKENDIE: u1 = 0,
        /// CMDACTIE [11:11]
        /// Command acting interrupt
        CMDACTIE: u1 = 0,
        /// TXACTIE [12:12]
        /// Data transmit acting interrupt
        TXACTIE: u1 = 0,
        /// RXACTIE [13:13]
        /// Data receive acting interrupt
        RXACTIE: u1 = 0,
        /// TXFIFOHEIE [14:14]
        /// Tx FIFO half empty interrupt
        TXFIFOHEIE: u1 = 0,
        /// RXFIFOHFIE [15:15]
        /// Rx FIFO half full interrupt
        RXFIFOHFIE: u1 = 0,
        /// TXFIFOFIE [16:16]
        /// Tx FIFO full interrupt
        TXFIFOFIE: u1 = 0,
        /// RXFIFOFIE [17:17]
        /// Rx FIFO full interrupt
        RXFIFOFIE: u1 = 0,
        /// TXFIFOEIE [18:18]
        /// Tx FIFO empty interrupt
        TXFIFOEIE: u1 = 0,
        /// RXFIFOEIE [19:19]
        /// Rx FIFO empty interrupt
        RXFIFOEIE: u1 = 0,
        /// TXDAVLIE [20:20]
        /// Data available in Tx FIFO interrupt
        TXDAVLIE: u1 = 0,
        /// RXDAVLIE [21:21]
        /// Data available in Rx FIFO interrupt
        RXDAVLIE: u1 = 0,
        /// SDIOITIE [22:22]
        /// SDIO mode interrupt received interrupt
        SDIOITIE: u1 = 0,
        /// CEATAENDIE [23:23]
        /// CE-ATA command completion signal
        CEATAENDIE: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// mask register
    pub const MASK = Register(MASK_val).init(base_address + 0x3c);

    /// FIFOCNT
    const FIFOCNT_val = packed struct {
        /// FIFOCOUNT [0:23]
        /// Remaining number of words to be written
        FIFOCOUNT: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// FIFO counter register
    pub const FIFOCNT = Register(FIFOCNT_val).init(base_address + 0x48);

    /// FIFO
    const FIFO_val = packed struct {
        /// FIFOData [0:31]
        /// Receive and transmit FIFO
        FIFOData: u32 = 0,
    };
    /// data FIFO register
    pub const FIFO = Register(FIFO_val).init(base_address + 0x80);
};

/// Secure digital input/output
pub const SDMMC2 = struct {
    const base_address = 0x40011c00;
    /// POWER
    const POWER_val = packed struct {
        /// PWRCTRL [0:1]
        /// PWRCTRL
        PWRCTRL: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// power control register
    pub const POWER = Register(POWER_val).init(base_address + 0x0);

    /// CLKCR
    const CLKCR_val = packed struct {
        /// CLKDIV [0:7]
        /// Clock divide factor
        CLKDIV: u8 = 0,
        /// CLKEN [8:8]
        /// Clock enable bit
        CLKEN: u1 = 0,
        /// PWRSAV [9:9]
        /// Power saving configuration
        PWRSAV: u1 = 0,
        /// BYPASS [10:10]
        /// Clock divider bypass enable
        BYPASS: u1 = 0,
        /// WIDBUS [11:12]
        /// Wide bus mode enable bit
        WIDBUS: u2 = 0,
        /// NEGEDGE [13:13]
        /// SDIO_CK dephasing selection
        NEGEDGE: u1 = 0,
        /// HWFC_EN [14:14]
        /// HW Flow Control enable
        HWFC_EN: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// SDI clock control register
    pub const CLKCR = Register(CLKCR_val).init(base_address + 0x4);

    /// ARG
    const ARG_val = packed struct {
        /// CMDARG [0:31]
        /// Command argument
        CMDARG: u32 = 0,
    };
    /// argument register
    pub const ARG = Register(ARG_val).init(base_address + 0x8);

    /// CMD
    const CMD_val = packed struct {
        /// CMDINDEX [0:5]
        /// Command index
        CMDINDEX: u6 = 0,
        /// WAITRESP [6:7]
        /// Wait for response bits
        WAITRESP: u2 = 0,
        /// WAITINT [8:8]
        /// CPSM waits for interrupt
        WAITINT: u1 = 0,
        /// WAITPEND [9:9]
        /// CPSM Waits for ends of data transfer
        WAITPEND: u1 = 0,
        /// CPSMEN [10:10]
        /// Command path state machine (CPSM) Enable
        CPSMEN: u1 = 0,
        /// SDIOSuspend [11:11]
        /// SD I/O suspend command
        SDIOSuspend: u1 = 0,
        /// ENCMDcompl [12:12]
        /// Enable CMD completion
        ENCMDcompl: u1 = 0,
        /// nIEN [13:13]
        /// not Interrupt Enable
        nIEN: u1 = 0,
        /// CE_ATACMD [14:14]
        /// CE-ATA command
        CE_ATACMD: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// command register
    pub const CMD = Register(CMD_val).init(base_address + 0xc);

    /// RESPCMD
    const RESPCMD_val = packed struct {
        /// RESPCMD [0:5]
        /// Response command index
        RESPCMD: u6 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// command response register
    pub const RESPCMD = Register(RESPCMD_val).init(base_address + 0x10);

    /// RESP1
    const RESP1_val = packed struct {
        /// CARDSTATUS1 [0:31]
        /// see Table 132
        CARDSTATUS1: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP1 = Register(RESP1_val).init(base_address + 0x14);

    /// RESP2
    const RESP2_val = packed struct {
        /// CARDSTATUS2 [0:31]
        /// see Table 132
        CARDSTATUS2: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP2 = Register(RESP2_val).init(base_address + 0x18);

    /// RESP3
    const RESP3_val = packed struct {
        /// CARDSTATUS3 [0:31]
        /// see Table 132
        CARDSTATUS3: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP3 = Register(RESP3_val).init(base_address + 0x1c);

    /// RESP4
    const RESP4_val = packed struct {
        /// CARDSTATUS4 [0:31]
        /// see Table 132
        CARDSTATUS4: u32 = 0,
    };
    /// response 1..4 register
    pub const RESP4 = Register(RESP4_val).init(base_address + 0x20);

    /// DTIMER
    const DTIMER_val = packed struct {
        /// DATATIME [0:31]
        /// Data timeout period
        DATATIME: u32 = 0,
    };
    /// data timer register
    pub const DTIMER = Register(DTIMER_val).init(base_address + 0x24);

    /// DLEN
    const DLEN_val = packed struct {
        /// DATALENGTH [0:24]
        /// Data length value
        DATALENGTH: u25 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// data length register
    pub const DLEN = Register(DLEN_val).init(base_address + 0x28);

    /// DCTRL
    const DCTRL_val = packed struct {
        /// DTEN [0:0]
        /// DTEN
        DTEN: u1 = 0,
        /// DTDIR [1:1]
        /// Data transfer direction
        DTDIR: u1 = 0,
        /// DTMODE [2:2]
        /// Data transfer mode selection 1: Stream
        DTMODE: u1 = 0,
        /// DMAEN [3:3]
        /// DMA enable bit
        DMAEN: u1 = 0,
        /// DBLOCKSIZE [4:7]
        /// Data block size
        DBLOCKSIZE: u4 = 0,
        /// RWSTART [8:8]
        /// Read wait start
        RWSTART: u1 = 0,
        /// RWSTOP [9:9]
        /// Read wait stop
        RWSTOP: u1 = 0,
        /// RWMOD [10:10]
        /// Read wait mode
        RWMOD: u1 = 0,
        /// SDIOEN [11:11]
        /// SD I/O enable functions
        SDIOEN: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// data control register
    pub const DCTRL = Register(DCTRL_val).init(base_address + 0x2c);

    /// DCOUNT
    const DCOUNT_val = packed struct {
        /// DATACOUNT [0:24]
        /// Data count value
        DATACOUNT: u25 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// data counter register
    pub const DCOUNT = Register(DCOUNT_val).init(base_address + 0x30);

    /// STA
    const STA_val = packed struct {
        /// CCRCFAIL [0:0]
        /// Command response received (CRC check
        CCRCFAIL: u1 = 0,
        /// DCRCFAIL [1:1]
        /// Data block sent/received (CRC check
        DCRCFAIL: u1 = 0,
        /// CTIMEOUT [2:2]
        /// Command response timeout
        CTIMEOUT: u1 = 0,
        /// DTIMEOUT [3:3]
        /// Data timeout
        DTIMEOUT: u1 = 0,
        /// TXUNDERR [4:4]
        /// Transmit FIFO underrun
        TXUNDERR: u1 = 0,
        /// RXOVERR [5:5]
        /// Received FIFO overrun
        RXOVERR: u1 = 0,
        /// CMDREND [6:6]
        /// Command response received (CRC check
        CMDREND: u1 = 0,
        /// CMDSENT [7:7]
        /// Command sent (no response
        CMDSENT: u1 = 0,
        /// DATAEND [8:8]
        /// Data end (data counter, SDIDCOUNT, is
        DATAEND: u1 = 0,
        /// STBITERR [9:9]
        /// Start bit not detected on all data
        STBITERR: u1 = 0,
        /// DBCKEND [10:10]
        /// Data block sent/received (CRC check
        DBCKEND: u1 = 0,
        /// CMDACT [11:11]
        /// Command transfer in
        CMDACT: u1 = 0,
        /// TXACT [12:12]
        /// Data transmit in progress
        TXACT: u1 = 0,
        /// RXACT [13:13]
        /// Data receive in progress
        RXACT: u1 = 0,
        /// TXFIFOHE [14:14]
        /// Transmit FIFO half empty: at least 8
        TXFIFOHE: u1 = 0,
        /// RXFIFOHF [15:15]
        /// Receive FIFO half full: there are at
        RXFIFOHF: u1 = 0,
        /// TXFIFOF [16:16]
        /// Transmit FIFO full
        TXFIFOF: u1 = 0,
        /// RXFIFOF [17:17]
        /// Receive FIFO full
        RXFIFOF: u1 = 0,
        /// TXFIFOE [18:18]
        /// Transmit FIFO empty
        TXFIFOE: u1 = 0,
        /// RXFIFOE [19:19]
        /// Receive FIFO empty
        RXFIFOE: u1 = 0,
        /// TXDAVL [20:20]
        /// Data available in transmit
        TXDAVL: u1 = 0,
        /// RXDAVL [21:21]
        /// Data available in receive
        RXDAVL: u1 = 0,
        /// SDIOIT [22:22]
        /// SDIO interrupt received
        SDIOIT: u1 = 0,
        /// CEATAEND [23:23]
        /// CE-ATA command completion signal
        CEATAEND: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// status register
    pub const STA = Register(STA_val).init(base_address + 0x34);

    /// ICR
    const ICR_val = packed struct {
        /// CCRCFAILC [0:0]
        /// CCRCFAIL flag clear bit
        CCRCFAILC: u1 = 0,
        /// DCRCFAILC [1:1]
        /// DCRCFAIL flag clear bit
        DCRCFAILC: u1 = 0,
        /// CTIMEOUTC [2:2]
        /// CTIMEOUT flag clear bit
        CTIMEOUTC: u1 = 0,
        /// DTIMEOUTC [3:3]
        /// DTIMEOUT flag clear bit
        DTIMEOUTC: u1 = 0,
        /// TXUNDERRC [4:4]
        /// TXUNDERR flag clear bit
        TXUNDERRC: u1 = 0,
        /// RXOVERRC [5:5]
        /// RXOVERR flag clear bit
        RXOVERRC: u1 = 0,
        /// CMDRENDC [6:6]
        /// CMDREND flag clear bit
        CMDRENDC: u1 = 0,
        /// CMDSENTC [7:7]
        /// CMDSENT flag clear bit
        CMDSENTC: u1 = 0,
        /// DATAENDC [8:8]
        /// DATAEND flag clear bit
        DATAENDC: u1 = 0,
        /// STBITERRC [9:9]
        /// STBITERR flag clear bit
        STBITERRC: u1 = 0,
        /// DBCKENDC [10:10]
        /// DBCKEND flag clear bit
        DBCKENDC: u1 = 0,
        /// unused [11:21]
        _unused11: u5 = 0,
        _unused16: u6 = 0,
        /// SDIOITC [22:22]
        /// SDIOIT flag clear bit
        SDIOITC: u1 = 0,
        /// CEATAENDC [23:23]
        /// CEATAEND flag clear bit
        CEATAENDC: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x38);

    /// MASK
    const MASK_val = packed struct {
        /// CCRCFAILIE [0:0]
        /// Command CRC fail interrupt
        CCRCFAILIE: u1 = 0,
        /// DCRCFAILIE [1:1]
        /// Data CRC fail interrupt
        DCRCFAILIE: u1 = 0,
        /// CTIMEOUTIE [2:2]
        /// Command timeout interrupt
        CTIMEOUTIE: u1 = 0,
        /// DTIMEOUTIE [3:3]
        /// Data timeout interrupt
        DTIMEOUTIE: u1 = 0,
        /// TXUNDERRIE [4:4]
        /// Tx FIFO underrun error interrupt
        TXUNDERRIE: u1 = 0,
        /// RXOVERRIE [5:5]
        /// Rx FIFO overrun error interrupt
        RXOVERRIE: u1 = 0,
        /// CMDRENDIE [6:6]
        /// Command response received interrupt
        CMDRENDIE: u1 = 0,
        /// CMDSENTIE [7:7]
        /// Command sent interrupt
        CMDSENTIE: u1 = 0,
        /// DATAENDIE [8:8]
        /// Data end interrupt enable
        DATAENDIE: u1 = 0,
        /// STBITERRIE [9:9]
        /// Start bit error interrupt
        STBITERRIE: u1 = 0,
        /// DBCKENDIE [10:10]
        /// Data block end interrupt
        DBCKENDIE: u1 = 0,
        /// CMDACTIE [11:11]
        /// Command acting interrupt
        CMDACTIE: u1 = 0,
        /// TXACTIE [12:12]
        /// Data transmit acting interrupt
        TXACTIE: u1 = 0,
        /// RXACTIE [13:13]
        /// Data receive acting interrupt
        RXACTIE: u1 = 0,
        /// TXFIFOHEIE [14:14]
        /// Tx FIFO half empty interrupt
        TXFIFOHEIE: u1 = 0,
        /// RXFIFOHFIE [15:15]
        /// Rx FIFO half full interrupt
        RXFIFOHFIE: u1 = 0,
        /// TXFIFOFIE [16:16]
        /// Tx FIFO full interrupt
        TXFIFOFIE: u1 = 0,
        /// RXFIFOFIE [17:17]
        /// Rx FIFO full interrupt
        RXFIFOFIE: u1 = 0,
        /// TXFIFOEIE [18:18]
        /// Tx FIFO empty interrupt
        TXFIFOEIE: u1 = 0,
        /// RXFIFOEIE [19:19]
        /// Rx FIFO empty interrupt
        RXFIFOEIE: u1 = 0,
        /// TXDAVLIE [20:20]
        /// Data available in Tx FIFO interrupt
        TXDAVLIE: u1 = 0,
        /// RXDAVLIE [21:21]
        /// Data available in Rx FIFO interrupt
        RXDAVLIE: u1 = 0,
        /// SDIOITIE [22:22]
        /// SDIO mode interrupt received interrupt
        SDIOITIE: u1 = 0,
        /// CEATAENDIE [23:23]
        /// CE-ATA command completion signal
        CEATAENDIE: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// mask register
    pub const MASK = Register(MASK_val).init(base_address + 0x3c);

    /// FIFOCNT
    const FIFOCNT_val = packed struct {
        /// FIFOCOUNT [0:23]
        /// Remaining number of words to be written
        FIFOCOUNT: u24 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// FIFO counter register
    pub const FIFOCNT = Register(FIFOCNT_val).init(base_address + 0x48);

    /// FIFO
    const FIFO_val = packed struct {
        /// FIFOData [0:31]
        /// Receive and transmit FIFO
        FIFOData: u32 = 0,
    };
    /// data FIFO register
    pub const FIFO = Register(FIFO_val).init(base_address + 0x80);
};

/// Low power timer
pub const LPTIM1 = struct {
    const base_address = 0x40002400;
    /// ISR
    const ISR_val = packed struct {
        /// CMPM [0:0]
        /// Compare match
        CMPM: u1 = 0,
        /// ARRM [1:1]
        /// Autoreload match
        ARRM: u1 = 0,
        /// EXTTRIG [2:2]
        /// External trigger edge
        EXTTRIG: u1 = 0,
        /// CMPOK [3:3]
        /// Compare register update OK
        CMPOK: u1 = 0,
        /// ARROK [4:4]
        /// Autoreload register update
        ARROK: u1 = 0,
        /// UP [5:5]
        /// Counter direction change down to
        UP: u1 = 0,
        /// DOWN [6:6]
        /// Counter direction change up to
        DOWN: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt and Status Register
    pub const ISR = Register(ISR_val).init(base_address + 0x0);

    /// ICR
    const ICR_val = packed struct {
        /// CMPMCF [0:0]
        /// compare match Clear Flag
        CMPMCF: u1 = 0,
        /// ARRMCF [1:1]
        /// Autoreload match Clear
        ARRMCF: u1 = 0,
        /// EXTTRIGCF [2:2]
        /// External trigger valid edge Clear
        EXTTRIGCF: u1 = 0,
        /// CMPOKCF [3:3]
        /// Compare register update OK Clear
        CMPOKCF: u1 = 0,
        /// ARROKCF [4:4]
        /// Autoreload register update OK Clear
        ARROKCF: u1 = 0,
        /// UPCF [5:5]
        /// Direction change to UP Clear
        UPCF: u1 = 0,
        /// DOWNCF [6:6]
        /// Direction change to down Clear
        DOWNCF: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Clear Register
    pub const ICR = Register(ICR_val).init(base_address + 0x4);

    /// IER
    const IER_val = packed struct {
        /// CMPMIE [0:0]
        /// Compare match Interrupt
        CMPMIE: u1 = 0,
        /// ARRMIE [1:1]
        /// Autoreload match Interrupt
        ARRMIE: u1 = 0,
        /// EXTTRIGIE [2:2]
        /// External trigger valid edge Interrupt
        EXTTRIGIE: u1 = 0,
        /// CMPOKIE [3:3]
        /// Compare register update OK Interrupt
        CMPOKIE: u1 = 0,
        /// ARROKIE [4:4]
        /// Autoreload register update OK Interrupt
        ARROKIE: u1 = 0,
        /// UPIE [5:5]
        /// Direction change to UP Interrupt
        UPIE: u1 = 0,
        /// DOWNIE [6:6]
        /// Direction change to down Interrupt
        DOWNIE: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt Enable Register
    pub const IER = Register(IER_val).init(base_address + 0x8);

    /// CFGR
    const CFGR_val = packed struct {
        /// CKSEL [0:0]
        /// Clock selector
        CKSEL: u1 = 0,
        /// CKPOL [1:2]
        /// Clock Polarity
        CKPOL: u2 = 0,
        /// CKFLT [3:4]
        /// Configurable digital filter for external
        CKFLT: u2 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TRGFLT [6:7]
        /// Configurable digital filter for
        TRGFLT: u2 = 0,
        /// unused [8:8]
        _unused8: u1 = 0,
        /// PRESC [9:11]
        /// Clock prescaler
        PRESC: u3 = 0,
        /// unused [12:12]
        _unused12: u1 = 0,
        /// TRIGSEL [13:15]
        /// Trigger selector
        TRIGSEL: u3 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// TRIGEN [17:18]
        /// Trigger enable and
        TRIGEN: u2 = 0,
        /// TIMOUT [19:19]
        /// Timeout enable
        TIMOUT: u1 = 0,
        /// WAVE [20:20]
        /// Waveform shape
        WAVE: u1 = 0,
        /// WAVPOL [21:21]
        /// Waveform shape polarity
        WAVPOL: u1 = 0,
        /// PRELOAD [22:22]
        /// Registers update mode
        PRELOAD: u1 = 0,
        /// COUNTMODE [23:23]
        /// counter mode enabled
        COUNTMODE: u1 = 0,
        /// ENC [24:24]
        /// Encoder mode enable
        ENC: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// Configuration Register
    pub const CFGR = Register(CFGR_val).init(base_address + 0xc);

    /// CR
    const CR_val = packed struct {
        /// ENABLE [0:0]
        /// LPTIM Enable
        ENABLE: u1 = 0,
        /// SNGSTRT [1:1]
        /// LPTIM start in single mode
        SNGSTRT: u1 = 0,
        /// CNTSTRT [2:2]
        /// Timer start in continuous
        CNTSTRT: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Control Register
    pub const CR = Register(CR_val).init(base_address + 0x10);

    /// CMP
    const CMP_val = packed struct {
        /// CMP [0:15]
        /// Compare value
        CMP: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Compare Register
    pub const CMP = Register(CMP_val).init(base_address + 0x14);

    /// ARR
    const ARR_val = packed struct {
        /// ARR [0:15]
        /// Auto reload value
        ARR: u16 = 1,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Autoreload Register
    pub const ARR = Register(ARR_val).init(base_address + 0x18);

    /// CNT
    const CNT_val = packed struct {
        /// CNT [0:15]
        /// Counter value
        CNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Counter Register
    pub const CNT = Register(CNT_val).init(base_address + 0x1c);
};

/// Inter-integrated circuit
pub const I2C1 = struct {
    const base_address = 0x40005400;
    /// CR1
    const CR1_val = packed struct {
        /// PE [0:0]
        /// Peripheral enable
        PE: u1 = 0,
        /// TXIE [1:1]
        /// TX Interrupt enable
        TXIE: u1 = 0,
        /// RXIE [2:2]
        /// RX Interrupt enable
        RXIE: u1 = 0,
        /// ADDRIE [3:3]
        /// Address match interrupt enable (slave
        ADDRIE: u1 = 0,
        /// NACKIE [4:4]
        /// Not acknowledge received interrupt
        NACKIE: u1 = 0,
        /// STOPIE [5:5]
        /// STOP detection Interrupt
        STOPIE: u1 = 0,
        /// TCIE [6:6]
        /// Transfer Complete interrupt
        TCIE: u1 = 0,
        /// ERRIE [7:7]
        /// Error interrupts enable
        ERRIE: u1 = 0,
        /// DNF [8:11]
        /// Digital noise filter
        DNF: u4 = 0,
        /// ANFOFF [12:12]
        /// Analog noise filter OFF
        ANFOFF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TXDMAEN [14:14]
        /// DMA transmission requests
        TXDMAEN: u1 = 0,
        /// RXDMAEN [15:15]
        /// DMA reception requests
        RXDMAEN: u1 = 0,
        /// SBC [16:16]
        /// Slave byte control
        SBC: u1 = 0,
        /// NOSTRETCH [17:17]
        /// Clock stretching disable
        NOSTRETCH: u1 = 0,
        /// WUPEN [18:18]
        /// Wakeup from STOP enable
        WUPEN: u1 = 0,
        /// GCEN [19:19]
        /// General call enable
        GCEN: u1 = 0,
        /// SMBHEN [20:20]
        /// SMBus Host address enable
        SMBHEN: u1 = 0,
        /// SMBDEN [21:21]
        /// SMBus Device Default address
        SMBDEN: u1 = 0,
        /// ALERTEN [22:22]
        /// SMBUS alert enable
        ALERTEN: u1 = 0,
        /// PECEN [23:23]
        /// PEC enable
        PECEN: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// SADD [0:9]
        /// Slave address bit (master
        SADD: u10 = 0,
        /// RD_WRN [10:10]
        /// Transfer direction (master
        RD_WRN: u1 = 0,
        /// ADD10 [11:11]
        /// 10-bit addressing mode (master
        ADD10: u1 = 0,
        /// HEAD10R [12:12]
        /// 10-bit address header only read
        HEAD10R: u1 = 0,
        /// START [13:13]
        /// Start generation
        START: u1 = 0,
        /// STOP [14:14]
        /// Stop generation (master
        STOP: u1 = 0,
        /// NACK [15:15]
        /// NACK generation (slave
        NACK: u1 = 0,
        /// NBYTES [16:23]
        /// Number of bytes
        NBYTES: u8 = 0,
        /// RELOAD [24:24]
        /// NBYTES reload mode
        RELOAD: u1 = 0,
        /// AUTOEND [25:25]
        /// Automatic end mode (master
        AUTOEND: u1 = 0,
        /// PECBYTE [26:26]
        /// Packet error checking byte
        PECBYTE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// OAR1
    const OAR1_val = packed struct {
        /// OA1 [0:9]
        /// Interface address
        OA1: u10 = 0,
        /// OA1MODE [10:10]
        /// Own Address 1 10-bit mode
        OA1MODE: u1 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA1EN [15:15]
        /// Own Address 1 enable
        OA1EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 1
    pub const OAR1 = Register(OAR1_val).init(base_address + 0x8);

    /// OAR2
    const OAR2_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// OA2 [1:7]
        /// Interface address
        OA2: u7 = 0,
        /// OA2MSK [8:10]
        /// Own Address 2 masks
        OA2MSK: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA2EN [15:15]
        /// Own Address 2 enable
        OA2EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 2
    pub const OAR2 = Register(OAR2_val).init(base_address + 0xc);

    /// TIMINGR
    const TIMINGR_val = packed struct {
        /// SCLL [0:7]
        /// SCL low period (master
        SCLL: u8 = 0,
        /// SCLH [8:15]
        /// SCL high period (master
        SCLH: u8 = 0,
        /// SDADEL [16:19]
        /// Data hold time
        SDADEL: u4 = 0,
        /// SCLDEL [20:23]
        /// Data setup time
        SCLDEL: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRESC [28:31]
        /// Timing prescaler
        PRESC: u4 = 0,
    };
    /// Timing register
    pub const TIMINGR = Register(TIMINGR_val).init(base_address + 0x10);

    /// TIMEOUTR
    const TIMEOUTR_val = packed struct {
        /// TIMEOUTA [0:11]
        /// Bus timeout A
        TIMEOUTA: u12 = 0,
        /// TIDLE [12:12]
        /// Idle clock timeout
        TIDLE: u1 = 0,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// TIMOUTEN [15:15]
        /// Clock timeout enable
        TIMOUTEN: u1 = 0,
        /// TIMEOUTB [16:27]
        /// Bus timeout B
        TIMEOUTB: u12 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// TEXTEN [31:31]
        /// Extended clock timeout
        TEXTEN: u1 = 0,
    };
    /// Status register 1
    pub const TIMEOUTR = Register(TIMEOUTR_val).init(base_address + 0x14);

    /// ISR
    const ISR_val = packed struct {
        /// TXE [0:0]
        /// Transmit data register empty
        TXE: u1 = 1,
        /// TXIS [1:1]
        /// Transmit interrupt status
        TXIS: u1 = 0,
        /// RXNE [2:2]
        /// Receive data register not empty
        RXNE: u1 = 0,
        /// ADDR [3:3]
        /// Address matched (slave
        ADDR: u1 = 0,
        /// NACKF [4:4]
        /// Not acknowledge received
        NACKF: u1 = 0,
        /// STOPF [5:5]
        /// Stop detection flag
        STOPF: u1 = 0,
        /// TC [6:6]
        /// Transfer Complete (master
        TC: u1 = 0,
        /// TCR [7:7]
        /// Transfer Complete Reload
        TCR: u1 = 0,
        /// BERR [8:8]
        /// Bus error
        BERR: u1 = 0,
        /// ARLO [9:9]
        /// Arbitration lost
        ARLO: u1 = 0,
        /// OVR [10:10]
        /// Overrun/Underrun (slave
        OVR: u1 = 0,
        /// PECERR [11:11]
        /// PEC Error in reception
        PECERR: u1 = 0,
        /// TIMEOUT [12:12]
        /// Timeout or t_low detection
        TIMEOUT: u1 = 0,
        /// ALERT [13:13]
        /// SMBus alert
        ALERT: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BUSY [15:15]
        /// Bus busy
        BUSY: u1 = 0,
        /// DIR [16:16]
        /// Transfer direction (Slave
        DIR: u1 = 0,
        /// ADDCODE [17:23]
        /// Address match code (Slave
        ADDCODE: u7 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt and Status register
    pub const ISR = Register(ISR_val).init(base_address + 0x18);

    /// ICR
    const ICR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRCF [3:3]
        /// Address Matched flag clear
        ADDRCF: u1 = 0,
        /// NACKCF [4:4]
        /// Not Acknowledge flag clear
        NACKCF: u1 = 0,
        /// STOPCF [5:5]
        /// Stop detection flag clear
        STOPCF: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BERRCF [8:8]
        /// Bus error flag clear
        BERRCF: u1 = 0,
        /// ARLOCF [9:9]
        /// Arbitration lost flag
        ARLOCF: u1 = 0,
        /// OVRCF [10:10]
        /// Overrun/Underrun flag
        OVRCF: u1 = 0,
        /// PECCF [11:11]
        /// PEC Error flag clear
        PECCF: u1 = 0,
        /// TIMOUTCF [12:12]
        /// Timeout detection flag
        TIMOUTCF: u1 = 0,
        /// ALERTCF [13:13]
        /// Alert flag clear
        ALERTCF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x1c);

    /// PECR
    const PECR_val = packed struct {
        /// PEC [0:7]
        /// Packet error checking
        PEC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PEC register
    pub const PECR = Register(PECR_val).init(base_address + 0x20);

    /// RXDR
    const RXDR_val = packed struct {
        /// RXDATA [0:7]
        /// 8-bit receive data
        RXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RXDR = Register(RXDR_val).init(base_address + 0x24);

    /// TXDR
    const TXDR_val = packed struct {
        /// TXDATA [0:7]
        /// 8-bit transmit data
        TXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TXDR = Register(TXDR_val).init(base_address + 0x28);
};

/// Inter-integrated circuit
pub const I2C2 = struct {
    const base_address = 0x40005800;
    /// CR1
    const CR1_val = packed struct {
        /// PE [0:0]
        /// Peripheral enable
        PE: u1 = 0,
        /// TXIE [1:1]
        /// TX Interrupt enable
        TXIE: u1 = 0,
        /// RXIE [2:2]
        /// RX Interrupt enable
        RXIE: u1 = 0,
        /// ADDRIE [3:3]
        /// Address match interrupt enable (slave
        ADDRIE: u1 = 0,
        /// NACKIE [4:4]
        /// Not acknowledge received interrupt
        NACKIE: u1 = 0,
        /// STOPIE [5:5]
        /// STOP detection Interrupt
        STOPIE: u1 = 0,
        /// TCIE [6:6]
        /// Transfer Complete interrupt
        TCIE: u1 = 0,
        /// ERRIE [7:7]
        /// Error interrupts enable
        ERRIE: u1 = 0,
        /// DNF [8:11]
        /// Digital noise filter
        DNF: u4 = 0,
        /// ANFOFF [12:12]
        /// Analog noise filter OFF
        ANFOFF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TXDMAEN [14:14]
        /// DMA transmission requests
        TXDMAEN: u1 = 0,
        /// RXDMAEN [15:15]
        /// DMA reception requests
        RXDMAEN: u1 = 0,
        /// SBC [16:16]
        /// Slave byte control
        SBC: u1 = 0,
        /// NOSTRETCH [17:17]
        /// Clock stretching disable
        NOSTRETCH: u1 = 0,
        /// WUPEN [18:18]
        /// Wakeup from STOP enable
        WUPEN: u1 = 0,
        /// GCEN [19:19]
        /// General call enable
        GCEN: u1 = 0,
        /// SMBHEN [20:20]
        /// SMBus Host address enable
        SMBHEN: u1 = 0,
        /// SMBDEN [21:21]
        /// SMBus Device Default address
        SMBDEN: u1 = 0,
        /// ALERTEN [22:22]
        /// SMBUS alert enable
        ALERTEN: u1 = 0,
        /// PECEN [23:23]
        /// PEC enable
        PECEN: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// SADD [0:9]
        /// Slave address bit (master
        SADD: u10 = 0,
        /// RD_WRN [10:10]
        /// Transfer direction (master
        RD_WRN: u1 = 0,
        /// ADD10 [11:11]
        /// 10-bit addressing mode (master
        ADD10: u1 = 0,
        /// HEAD10R [12:12]
        /// 10-bit address header only read
        HEAD10R: u1 = 0,
        /// START [13:13]
        /// Start generation
        START: u1 = 0,
        /// STOP [14:14]
        /// Stop generation (master
        STOP: u1 = 0,
        /// NACK [15:15]
        /// NACK generation (slave
        NACK: u1 = 0,
        /// NBYTES [16:23]
        /// Number of bytes
        NBYTES: u8 = 0,
        /// RELOAD [24:24]
        /// NBYTES reload mode
        RELOAD: u1 = 0,
        /// AUTOEND [25:25]
        /// Automatic end mode (master
        AUTOEND: u1 = 0,
        /// PECBYTE [26:26]
        /// Packet error checking byte
        PECBYTE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// OAR1
    const OAR1_val = packed struct {
        /// OA1 [0:9]
        /// Interface address
        OA1: u10 = 0,
        /// OA1MODE [10:10]
        /// Own Address 1 10-bit mode
        OA1MODE: u1 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA1EN [15:15]
        /// Own Address 1 enable
        OA1EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 1
    pub const OAR1 = Register(OAR1_val).init(base_address + 0x8);

    /// OAR2
    const OAR2_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// OA2 [1:7]
        /// Interface address
        OA2: u7 = 0,
        /// OA2MSK [8:10]
        /// Own Address 2 masks
        OA2MSK: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA2EN [15:15]
        /// Own Address 2 enable
        OA2EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 2
    pub const OAR2 = Register(OAR2_val).init(base_address + 0xc);

    /// TIMINGR
    const TIMINGR_val = packed struct {
        /// SCLL [0:7]
        /// SCL low period (master
        SCLL: u8 = 0,
        /// SCLH [8:15]
        /// SCL high period (master
        SCLH: u8 = 0,
        /// SDADEL [16:19]
        /// Data hold time
        SDADEL: u4 = 0,
        /// SCLDEL [20:23]
        /// Data setup time
        SCLDEL: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRESC [28:31]
        /// Timing prescaler
        PRESC: u4 = 0,
    };
    /// Timing register
    pub const TIMINGR = Register(TIMINGR_val).init(base_address + 0x10);

    /// TIMEOUTR
    const TIMEOUTR_val = packed struct {
        /// TIMEOUTA [0:11]
        /// Bus timeout A
        TIMEOUTA: u12 = 0,
        /// TIDLE [12:12]
        /// Idle clock timeout
        TIDLE: u1 = 0,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// TIMOUTEN [15:15]
        /// Clock timeout enable
        TIMOUTEN: u1 = 0,
        /// TIMEOUTB [16:27]
        /// Bus timeout B
        TIMEOUTB: u12 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// TEXTEN [31:31]
        /// Extended clock timeout
        TEXTEN: u1 = 0,
    };
    /// Status register 1
    pub const TIMEOUTR = Register(TIMEOUTR_val).init(base_address + 0x14);

    /// ISR
    const ISR_val = packed struct {
        /// TXE [0:0]
        /// Transmit data register empty
        TXE: u1 = 1,
        /// TXIS [1:1]
        /// Transmit interrupt status
        TXIS: u1 = 0,
        /// RXNE [2:2]
        /// Receive data register not empty
        RXNE: u1 = 0,
        /// ADDR [3:3]
        /// Address matched (slave
        ADDR: u1 = 0,
        /// NACKF [4:4]
        /// Not acknowledge received
        NACKF: u1 = 0,
        /// STOPF [5:5]
        /// Stop detection flag
        STOPF: u1 = 0,
        /// TC [6:6]
        /// Transfer Complete (master
        TC: u1 = 0,
        /// TCR [7:7]
        /// Transfer Complete Reload
        TCR: u1 = 0,
        /// BERR [8:8]
        /// Bus error
        BERR: u1 = 0,
        /// ARLO [9:9]
        /// Arbitration lost
        ARLO: u1 = 0,
        /// OVR [10:10]
        /// Overrun/Underrun (slave
        OVR: u1 = 0,
        /// PECERR [11:11]
        /// PEC Error in reception
        PECERR: u1 = 0,
        /// TIMEOUT [12:12]
        /// Timeout or t_low detection
        TIMEOUT: u1 = 0,
        /// ALERT [13:13]
        /// SMBus alert
        ALERT: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BUSY [15:15]
        /// Bus busy
        BUSY: u1 = 0,
        /// DIR [16:16]
        /// Transfer direction (Slave
        DIR: u1 = 0,
        /// ADDCODE [17:23]
        /// Address match code (Slave
        ADDCODE: u7 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt and Status register
    pub const ISR = Register(ISR_val).init(base_address + 0x18);

    /// ICR
    const ICR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRCF [3:3]
        /// Address Matched flag clear
        ADDRCF: u1 = 0,
        /// NACKCF [4:4]
        /// Not Acknowledge flag clear
        NACKCF: u1 = 0,
        /// STOPCF [5:5]
        /// Stop detection flag clear
        STOPCF: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BERRCF [8:8]
        /// Bus error flag clear
        BERRCF: u1 = 0,
        /// ARLOCF [9:9]
        /// Arbitration lost flag
        ARLOCF: u1 = 0,
        /// OVRCF [10:10]
        /// Overrun/Underrun flag
        OVRCF: u1 = 0,
        /// PECCF [11:11]
        /// PEC Error flag clear
        PECCF: u1 = 0,
        /// TIMOUTCF [12:12]
        /// Timeout detection flag
        TIMOUTCF: u1 = 0,
        /// ALERTCF [13:13]
        /// Alert flag clear
        ALERTCF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x1c);

    /// PECR
    const PECR_val = packed struct {
        /// PEC [0:7]
        /// Packet error checking
        PEC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PEC register
    pub const PECR = Register(PECR_val).init(base_address + 0x20);

    /// RXDR
    const RXDR_val = packed struct {
        /// RXDATA [0:7]
        /// 8-bit receive data
        RXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RXDR = Register(RXDR_val).init(base_address + 0x24);

    /// TXDR
    const TXDR_val = packed struct {
        /// TXDATA [0:7]
        /// 8-bit transmit data
        TXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TXDR = Register(TXDR_val).init(base_address + 0x28);
};

/// Inter-integrated circuit
pub const I2C3 = struct {
    const base_address = 0x40005c00;
    /// CR1
    const CR1_val = packed struct {
        /// PE [0:0]
        /// Peripheral enable
        PE: u1 = 0,
        /// TXIE [1:1]
        /// TX Interrupt enable
        TXIE: u1 = 0,
        /// RXIE [2:2]
        /// RX Interrupt enable
        RXIE: u1 = 0,
        /// ADDRIE [3:3]
        /// Address match interrupt enable (slave
        ADDRIE: u1 = 0,
        /// NACKIE [4:4]
        /// Not acknowledge received interrupt
        NACKIE: u1 = 0,
        /// STOPIE [5:5]
        /// STOP detection Interrupt
        STOPIE: u1 = 0,
        /// TCIE [6:6]
        /// Transfer Complete interrupt
        TCIE: u1 = 0,
        /// ERRIE [7:7]
        /// Error interrupts enable
        ERRIE: u1 = 0,
        /// DNF [8:11]
        /// Digital noise filter
        DNF: u4 = 0,
        /// ANFOFF [12:12]
        /// Analog noise filter OFF
        ANFOFF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TXDMAEN [14:14]
        /// DMA transmission requests
        TXDMAEN: u1 = 0,
        /// RXDMAEN [15:15]
        /// DMA reception requests
        RXDMAEN: u1 = 0,
        /// SBC [16:16]
        /// Slave byte control
        SBC: u1 = 0,
        /// NOSTRETCH [17:17]
        /// Clock stretching disable
        NOSTRETCH: u1 = 0,
        /// WUPEN [18:18]
        /// Wakeup from STOP enable
        WUPEN: u1 = 0,
        /// GCEN [19:19]
        /// General call enable
        GCEN: u1 = 0,
        /// SMBHEN [20:20]
        /// SMBus Host address enable
        SMBHEN: u1 = 0,
        /// SMBDEN [21:21]
        /// SMBus Device Default address
        SMBDEN: u1 = 0,
        /// ALERTEN [22:22]
        /// SMBUS alert enable
        ALERTEN: u1 = 0,
        /// PECEN [23:23]
        /// PEC enable
        PECEN: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// SADD [0:9]
        /// Slave address bit (master
        SADD: u10 = 0,
        /// RD_WRN [10:10]
        /// Transfer direction (master
        RD_WRN: u1 = 0,
        /// ADD10 [11:11]
        /// 10-bit addressing mode (master
        ADD10: u1 = 0,
        /// HEAD10R [12:12]
        /// 10-bit address header only read
        HEAD10R: u1 = 0,
        /// START [13:13]
        /// Start generation
        START: u1 = 0,
        /// STOP [14:14]
        /// Stop generation (master
        STOP: u1 = 0,
        /// NACK [15:15]
        /// NACK generation (slave
        NACK: u1 = 0,
        /// NBYTES [16:23]
        /// Number of bytes
        NBYTES: u8 = 0,
        /// RELOAD [24:24]
        /// NBYTES reload mode
        RELOAD: u1 = 0,
        /// AUTOEND [25:25]
        /// Automatic end mode (master
        AUTOEND: u1 = 0,
        /// PECBYTE [26:26]
        /// Packet error checking byte
        PECBYTE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// OAR1
    const OAR1_val = packed struct {
        /// OA1 [0:9]
        /// Interface address
        OA1: u10 = 0,
        /// OA1MODE [10:10]
        /// Own Address 1 10-bit mode
        OA1MODE: u1 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA1EN [15:15]
        /// Own Address 1 enable
        OA1EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 1
    pub const OAR1 = Register(OAR1_val).init(base_address + 0x8);

    /// OAR2
    const OAR2_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// OA2 [1:7]
        /// Interface address
        OA2: u7 = 0,
        /// OA2MSK [8:10]
        /// Own Address 2 masks
        OA2MSK: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA2EN [15:15]
        /// Own Address 2 enable
        OA2EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 2
    pub const OAR2 = Register(OAR2_val).init(base_address + 0xc);

    /// TIMINGR
    const TIMINGR_val = packed struct {
        /// SCLL [0:7]
        /// SCL low period (master
        SCLL: u8 = 0,
        /// SCLH [8:15]
        /// SCL high period (master
        SCLH: u8 = 0,
        /// SDADEL [16:19]
        /// Data hold time
        SDADEL: u4 = 0,
        /// SCLDEL [20:23]
        /// Data setup time
        SCLDEL: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRESC [28:31]
        /// Timing prescaler
        PRESC: u4 = 0,
    };
    /// Timing register
    pub const TIMINGR = Register(TIMINGR_val).init(base_address + 0x10);

    /// TIMEOUTR
    const TIMEOUTR_val = packed struct {
        /// TIMEOUTA [0:11]
        /// Bus timeout A
        TIMEOUTA: u12 = 0,
        /// TIDLE [12:12]
        /// Idle clock timeout
        TIDLE: u1 = 0,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// TIMOUTEN [15:15]
        /// Clock timeout enable
        TIMOUTEN: u1 = 0,
        /// TIMEOUTB [16:27]
        /// Bus timeout B
        TIMEOUTB: u12 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// TEXTEN [31:31]
        /// Extended clock timeout
        TEXTEN: u1 = 0,
    };
    /// Status register 1
    pub const TIMEOUTR = Register(TIMEOUTR_val).init(base_address + 0x14);

    /// ISR
    const ISR_val = packed struct {
        /// TXE [0:0]
        /// Transmit data register empty
        TXE: u1 = 1,
        /// TXIS [1:1]
        /// Transmit interrupt status
        TXIS: u1 = 0,
        /// RXNE [2:2]
        /// Receive data register not empty
        RXNE: u1 = 0,
        /// ADDR [3:3]
        /// Address matched (slave
        ADDR: u1 = 0,
        /// NACKF [4:4]
        /// Not acknowledge received
        NACKF: u1 = 0,
        /// STOPF [5:5]
        /// Stop detection flag
        STOPF: u1 = 0,
        /// TC [6:6]
        /// Transfer Complete (master
        TC: u1 = 0,
        /// TCR [7:7]
        /// Transfer Complete Reload
        TCR: u1 = 0,
        /// BERR [8:8]
        /// Bus error
        BERR: u1 = 0,
        /// ARLO [9:9]
        /// Arbitration lost
        ARLO: u1 = 0,
        /// OVR [10:10]
        /// Overrun/Underrun (slave
        OVR: u1 = 0,
        /// PECERR [11:11]
        /// PEC Error in reception
        PECERR: u1 = 0,
        /// TIMEOUT [12:12]
        /// Timeout or t_low detection
        TIMEOUT: u1 = 0,
        /// ALERT [13:13]
        /// SMBus alert
        ALERT: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BUSY [15:15]
        /// Bus busy
        BUSY: u1 = 0,
        /// DIR [16:16]
        /// Transfer direction (Slave
        DIR: u1 = 0,
        /// ADDCODE [17:23]
        /// Address match code (Slave
        ADDCODE: u7 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt and Status register
    pub const ISR = Register(ISR_val).init(base_address + 0x18);

    /// ICR
    const ICR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRCF [3:3]
        /// Address Matched flag clear
        ADDRCF: u1 = 0,
        /// NACKCF [4:4]
        /// Not Acknowledge flag clear
        NACKCF: u1 = 0,
        /// STOPCF [5:5]
        /// Stop detection flag clear
        STOPCF: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BERRCF [8:8]
        /// Bus error flag clear
        BERRCF: u1 = 0,
        /// ARLOCF [9:9]
        /// Arbitration lost flag
        ARLOCF: u1 = 0,
        /// OVRCF [10:10]
        /// Overrun/Underrun flag
        OVRCF: u1 = 0,
        /// PECCF [11:11]
        /// PEC Error flag clear
        PECCF: u1 = 0,
        /// TIMOUTCF [12:12]
        /// Timeout detection flag
        TIMOUTCF: u1 = 0,
        /// ALERTCF [13:13]
        /// Alert flag clear
        ALERTCF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x1c);

    /// PECR
    const PECR_val = packed struct {
        /// PEC [0:7]
        /// Packet error checking
        PEC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PEC register
    pub const PECR = Register(PECR_val).init(base_address + 0x20);

    /// RXDR
    const RXDR_val = packed struct {
        /// RXDATA [0:7]
        /// 8-bit receive data
        RXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RXDR = Register(RXDR_val).init(base_address + 0x24);

    /// TXDR
    const TXDR_val = packed struct {
        /// TXDATA [0:7]
        /// 8-bit transmit data
        TXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TXDR = Register(TXDR_val).init(base_address + 0x28);
};

/// Inter-integrated circuit
pub const I2C4 = struct {
    const base_address = 0x40006000;
    /// CR1
    const CR1_val = packed struct {
        /// PE [0:0]
        /// Peripheral enable
        PE: u1 = 0,
        /// TXIE [1:1]
        /// TX Interrupt enable
        TXIE: u1 = 0,
        /// RXIE [2:2]
        /// RX Interrupt enable
        RXIE: u1 = 0,
        /// ADDRIE [3:3]
        /// Address match interrupt enable (slave
        ADDRIE: u1 = 0,
        /// NACKIE [4:4]
        /// Not acknowledge received interrupt
        NACKIE: u1 = 0,
        /// STOPIE [5:5]
        /// STOP detection Interrupt
        STOPIE: u1 = 0,
        /// TCIE [6:6]
        /// Transfer Complete interrupt
        TCIE: u1 = 0,
        /// ERRIE [7:7]
        /// Error interrupts enable
        ERRIE: u1 = 0,
        /// DNF [8:11]
        /// Digital noise filter
        DNF: u4 = 0,
        /// ANFOFF [12:12]
        /// Analog noise filter OFF
        ANFOFF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// TXDMAEN [14:14]
        /// DMA transmission requests
        TXDMAEN: u1 = 0,
        /// RXDMAEN [15:15]
        /// DMA reception requests
        RXDMAEN: u1 = 0,
        /// SBC [16:16]
        /// Slave byte control
        SBC: u1 = 0,
        /// NOSTRETCH [17:17]
        /// Clock stretching disable
        NOSTRETCH: u1 = 0,
        /// WUPEN [18:18]
        /// Wakeup from STOP enable
        WUPEN: u1 = 0,
        /// GCEN [19:19]
        /// General call enable
        GCEN: u1 = 0,
        /// SMBHEN [20:20]
        /// SMBus Host address enable
        SMBHEN: u1 = 0,
        /// SMBDEN [21:21]
        /// SMBus Device Default address
        SMBDEN: u1 = 0,
        /// ALERTEN [22:22]
        /// SMBUS alert enable
        ALERTEN: u1 = 0,
        /// PECEN [23:23]
        /// PEC enable
        PECEN: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// SADD [0:9]
        /// Slave address bit (master
        SADD: u10 = 0,
        /// RD_WRN [10:10]
        /// Transfer direction (master
        RD_WRN: u1 = 0,
        /// ADD10 [11:11]
        /// 10-bit addressing mode (master
        ADD10: u1 = 0,
        /// HEAD10R [12:12]
        /// 10-bit address header only read
        HEAD10R: u1 = 0,
        /// START [13:13]
        /// Start generation
        START: u1 = 0,
        /// STOP [14:14]
        /// Stop generation (master
        STOP: u1 = 0,
        /// NACK [15:15]
        /// NACK generation (slave
        NACK: u1 = 0,
        /// NBYTES [16:23]
        /// Number of bytes
        NBYTES: u8 = 0,
        /// RELOAD [24:24]
        /// NBYTES reload mode
        RELOAD: u1 = 0,
        /// AUTOEND [25:25]
        /// Automatic end mode (master
        AUTOEND: u1 = 0,
        /// PECBYTE [26:26]
        /// Packet error checking byte
        PECBYTE: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// OAR1
    const OAR1_val = packed struct {
        /// OA1 [0:9]
        /// Interface address
        OA1: u10 = 0,
        /// OA1MODE [10:10]
        /// Own Address 1 10-bit mode
        OA1MODE: u1 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA1EN [15:15]
        /// Own Address 1 enable
        OA1EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 1
    pub const OAR1 = Register(OAR1_val).init(base_address + 0x8);

    /// OAR2
    const OAR2_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// OA2 [1:7]
        /// Interface address
        OA2: u7 = 0,
        /// OA2MSK [8:10]
        /// Own Address 2 masks
        OA2MSK: u3 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// OA2EN [15:15]
        /// Own Address 2 enable
        OA2EN: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Own address register 2
    pub const OAR2 = Register(OAR2_val).init(base_address + 0xc);

    /// TIMINGR
    const TIMINGR_val = packed struct {
        /// SCLL [0:7]
        /// SCL low period (master
        SCLL: u8 = 0,
        /// SCLH [8:15]
        /// SCL high period (master
        SCLH: u8 = 0,
        /// SDADEL [16:19]
        /// Data hold time
        SDADEL: u4 = 0,
        /// SCLDEL [20:23]
        /// Data setup time
        SCLDEL: u4 = 0,
        /// unused [24:27]
        _unused24: u4 = 0,
        /// PRESC [28:31]
        /// Timing prescaler
        PRESC: u4 = 0,
    };
    /// Timing register
    pub const TIMINGR = Register(TIMINGR_val).init(base_address + 0x10);

    /// TIMEOUTR
    const TIMEOUTR_val = packed struct {
        /// TIMEOUTA [0:11]
        /// Bus timeout A
        TIMEOUTA: u12 = 0,
        /// TIDLE [12:12]
        /// Idle clock timeout
        TIDLE: u1 = 0,
        /// unused [13:14]
        _unused13: u2 = 0,
        /// TIMOUTEN [15:15]
        /// Clock timeout enable
        TIMOUTEN: u1 = 0,
        /// TIMEOUTB [16:27]
        /// Bus timeout B
        TIMEOUTB: u12 = 0,
        /// unused [28:30]
        _unused28: u3 = 0,
        /// TEXTEN [31:31]
        /// Extended clock timeout
        TEXTEN: u1 = 0,
    };
    /// Status register 1
    pub const TIMEOUTR = Register(TIMEOUTR_val).init(base_address + 0x14);

    /// ISR
    const ISR_val = packed struct {
        /// TXE [0:0]
        /// Transmit data register empty
        TXE: u1 = 1,
        /// TXIS [1:1]
        /// Transmit interrupt status
        TXIS: u1 = 0,
        /// RXNE [2:2]
        /// Receive data register not empty
        RXNE: u1 = 0,
        /// ADDR [3:3]
        /// Address matched (slave
        ADDR: u1 = 0,
        /// NACKF [4:4]
        /// Not acknowledge received
        NACKF: u1 = 0,
        /// STOPF [5:5]
        /// Stop detection flag
        STOPF: u1 = 0,
        /// TC [6:6]
        /// Transfer Complete (master
        TC: u1 = 0,
        /// TCR [7:7]
        /// Transfer Complete Reload
        TCR: u1 = 0,
        /// BERR [8:8]
        /// Bus error
        BERR: u1 = 0,
        /// ARLO [9:9]
        /// Arbitration lost
        ARLO: u1 = 0,
        /// OVR [10:10]
        /// Overrun/Underrun (slave
        OVR: u1 = 0,
        /// PECERR [11:11]
        /// PEC Error in reception
        PECERR: u1 = 0,
        /// TIMEOUT [12:12]
        /// Timeout or t_low detection
        TIMEOUT: u1 = 0,
        /// ALERT [13:13]
        /// SMBus alert
        ALERT: u1 = 0,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// BUSY [15:15]
        /// Bus busy
        BUSY: u1 = 0,
        /// DIR [16:16]
        /// Transfer direction (Slave
        DIR: u1 = 0,
        /// ADDCODE [17:23]
        /// Address match code (Slave
        ADDCODE: u7 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// Interrupt and Status register
    pub const ISR = Register(ISR_val).init(base_address + 0x18);

    /// ICR
    const ICR_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// ADDRCF [3:3]
        /// Address Matched flag clear
        ADDRCF: u1 = 0,
        /// NACKCF [4:4]
        /// Not Acknowledge flag clear
        NACKCF: u1 = 0,
        /// STOPCF [5:5]
        /// Stop detection flag clear
        STOPCF: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// BERRCF [8:8]
        /// Bus error flag clear
        BERRCF: u1 = 0,
        /// ARLOCF [9:9]
        /// Arbitration lost flag
        ARLOCF: u1 = 0,
        /// OVRCF [10:10]
        /// Overrun/Underrun flag
        OVRCF: u1 = 0,
        /// PECCF [11:11]
        /// PEC Error flag clear
        PECCF: u1 = 0,
        /// TIMOUTCF [12:12]
        /// Timeout detection flag
        TIMOUTCF: u1 = 0,
        /// ALERTCF [13:13]
        /// Alert flag clear
        ALERTCF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x1c);

    /// PECR
    const PECR_val = packed struct {
        /// PEC [0:7]
        /// Packet error checking
        PEC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// PEC register
    pub const PECR = Register(PECR_val).init(base_address + 0x20);

    /// RXDR
    const RXDR_val = packed struct {
        /// RXDATA [0:7]
        /// 8-bit receive data
        RXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RXDR = Register(RXDR_val).init(base_address + 0x24);

    /// TXDR
    const TXDR_val = packed struct {
        /// TXDATA [0:7]
        /// 8-bit transmit data
        TXDATA: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TXDR = Register(TXDR_val).init(base_address + 0x28);
};

/// Real-time clock
pub const RTC = struct {
    const base_address = 0x40002800;
    /// TR
    const TR_val = packed struct {
        /// SU [0:3]
        /// Second units in BCD format
        SU: u4 = 0,
        /// ST [4:6]
        /// Second tens in BCD format
        ST: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// MNU [8:11]
        /// Minute units in BCD format
        MNU: u4 = 0,
        /// MNT [12:14]
        /// Minute tens in BCD format
        MNT: u3 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// HU [16:19]
        /// Hour units in BCD format
        HU: u4 = 0,
        /// HT [20:21]
        /// Hour tens in BCD format
        HT: u2 = 0,
        /// PM [22:22]
        /// AM/PM notation
        PM: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// time register
    pub const TR = Register(TR_val).init(base_address + 0x0);

    /// DR
    const DR_val = packed struct {
        /// DU [0:3]
        /// Date units in BCD format
        DU: u4 = 1,
        /// DT [4:5]
        /// Date tens in BCD format
        DT: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// MU [8:11]
        /// Month units in BCD format
        MU: u4 = 1,
        /// MT [12:12]
        /// Month tens in BCD format
        MT: u1 = 0,
        /// WDU [13:15]
        /// Week day units
        WDU: u3 = 1,
        /// YU [16:19]
        /// Year units in BCD format
        YU: u4 = 0,
        /// YT [20:23]
        /// Year tens in BCD format
        YT: u4 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// date register
    pub const DR = Register(DR_val).init(base_address + 0x4);

    /// CR
    const CR_val = packed struct {
        /// WCKSEL [0:2]
        /// Wakeup clock selection
        WCKSEL: u3 = 0,
        /// TSEDGE [3:3]
        /// Time-stamp event active
        TSEDGE: u1 = 0,
        /// REFCKON [4:4]
        /// Reference clock detection enable (50 or
        REFCKON: u1 = 0,
        /// BYPSHAD [5:5]
        /// Bypass the shadow
        BYPSHAD: u1 = 0,
        /// FMT [6:6]
        /// Hour format
        FMT: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// ALRAE [8:8]
        /// Alarm A enable
        ALRAE: u1 = 0,
        /// ALRBE [9:9]
        /// Alarm B enable
        ALRBE: u1 = 0,
        /// WUTE [10:10]
        /// Wakeup timer enable
        WUTE: u1 = 0,
        /// TSE [11:11]
        /// Time stamp enable
        TSE: u1 = 0,
        /// ALRAIE [12:12]
        /// Alarm A interrupt enable
        ALRAIE: u1 = 0,
        /// ALRBIE [13:13]
        /// Alarm B interrupt enable
        ALRBIE: u1 = 0,
        /// WUTIE [14:14]
        /// Wakeup timer interrupt
        WUTIE: u1 = 0,
        /// TSIE [15:15]
        /// Time-stamp interrupt
        TSIE: u1 = 0,
        /// ADD1H [16:16]
        /// Add 1 hour (summer time
        ADD1H: u1 = 0,
        /// SUB1H [17:17]
        /// Subtract 1 hour (winter time
        SUB1H: u1 = 0,
        /// BKP [18:18]
        /// Backup
        BKP: u1 = 0,
        /// COSEL [19:19]
        /// Calibration output
        COSEL: u1 = 0,
        /// POL [20:20]
        /// Output polarity
        POL: u1 = 0,
        /// OSEL [21:22]
        /// Output selection
        OSEL: u2 = 0,
        /// COE [23:23]
        /// Calibration output enable
        COE: u1 = 0,
        /// ITSE [24:24]
        /// timestamp on internal event
        ITSE: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// control register
    pub const CR = Register(CR_val).init(base_address + 0x8);

    /// ISR
    const ISR_val = packed struct {
        /// ALRAWF [0:0]
        /// Alarm A write flag
        ALRAWF: u1 = 1,
        /// ALRBWF [1:1]
        /// Alarm B write flag
        ALRBWF: u1 = 1,
        /// WUTWF [2:2]
        /// Wakeup timer write flag
        WUTWF: u1 = 1,
        /// SHPF [3:3]
        /// Shift operation pending
        SHPF: u1 = 0,
        /// INITS [4:4]
        /// Initialization status flag
        INITS: u1 = 0,
        /// RSF [5:5]
        /// Registers synchronization
        RSF: u1 = 0,
        /// INITF [6:6]
        /// Initialization flag
        INITF: u1 = 0,
        /// INIT [7:7]
        /// Initialization mode
        INIT: u1 = 0,
        /// ALRAF [8:8]
        /// Alarm A flag
        ALRAF: u1 = 0,
        /// ALRBF [9:9]
        /// Alarm B flag
        ALRBF: u1 = 0,
        /// WUTF [10:10]
        /// Wakeup timer flag
        WUTF: u1 = 0,
        /// TSF [11:11]
        /// Time-stamp flag
        TSF: u1 = 0,
        /// TSOVF [12:12]
        /// Time-stamp overflow flag
        TSOVF: u1 = 0,
        /// TAMP1F [13:13]
        /// Tamper detection flag
        TAMP1F: u1 = 0,
        /// TAMP2F [14:14]
        /// RTC_TAMP2 detection flag
        TAMP2F: u1 = 0,
        /// TAMP3F [15:15]
        /// RTC_TAMP3 detection flag
        TAMP3F: u1 = 0,
        /// RECALPF [16:16]
        /// Recalibration pending Flag
        RECALPF: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// initialization and status
    pub const ISR = Register(ISR_val).init(base_address + 0xc);

    /// PRER
    const PRER_val = packed struct {
        /// PREDIV_S [0:14]
        /// Synchronous prescaler
        PREDIV_S: u15 = 255,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// PREDIV_A [16:22]
        /// Asynchronous prescaler
        PREDIV_A: u7 = 127,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// prescaler register
    pub const PRER = Register(PRER_val).init(base_address + 0x10);

    /// WUTR
    const WUTR_val = packed struct {
        /// WUT [0:15]
        /// Wakeup auto-reload value
        WUT: u16 = 65535,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// wakeup timer register
    pub const WUTR = Register(WUTR_val).init(base_address + 0x14);

    /// ALRMAR
    const ALRMAR_val = packed struct {
        /// SU [0:3]
        /// Second units in BCD format
        SU: u4 = 0,
        /// ST [4:6]
        /// Second tens in BCD format
        ST: u3 = 0,
        /// MSK1 [7:7]
        /// Alarm A seconds mask
        MSK1: u1 = 0,
        /// MNU [8:11]
        /// Minute units in BCD format
        MNU: u4 = 0,
        /// MNT [12:14]
        /// Minute tens in BCD format
        MNT: u3 = 0,
        /// MSK2 [15:15]
        /// Alarm A minutes mask
        MSK2: u1 = 0,
        /// HU [16:19]
        /// Hour units in BCD format
        HU: u4 = 0,
        /// HT [20:21]
        /// Hour tens in BCD format
        HT: u2 = 0,
        /// PM [22:22]
        /// AM/PM notation
        PM: u1 = 0,
        /// MSK3 [23:23]
        /// Alarm A hours mask
        MSK3: u1 = 0,
        /// DU [24:27]
        /// Date units or day in BCD
        DU: u4 = 0,
        /// DT [28:29]
        /// Date tens in BCD format
        DT: u2 = 0,
        /// WDSEL [30:30]
        /// Week day selection
        WDSEL: u1 = 0,
        /// MSK4 [31:31]
        /// Alarm A date mask
        MSK4: u1 = 0,
    };
    /// alarm A register
    pub const ALRMAR = Register(ALRMAR_val).init(base_address + 0x1c);

    /// ALRMBR
    const ALRMBR_val = packed struct {
        /// SU [0:3]
        /// Second units in BCD format
        SU: u4 = 0,
        /// ST [4:6]
        /// Second tens in BCD format
        ST: u3 = 0,
        /// MSK1 [7:7]
        /// Alarm B seconds mask
        MSK1: u1 = 0,
        /// MNU [8:11]
        /// Minute units in BCD format
        MNU: u4 = 0,
        /// MNT [12:14]
        /// Minute tens in BCD format
        MNT: u3 = 0,
        /// MSK2 [15:15]
        /// Alarm B minutes mask
        MSK2: u1 = 0,
        /// HU [16:19]
        /// Hour units in BCD format
        HU: u4 = 0,
        /// HT [20:21]
        /// Hour tens in BCD format
        HT: u2 = 0,
        /// PM [22:22]
        /// AM/PM notation
        PM: u1 = 0,
        /// MSK3 [23:23]
        /// Alarm B hours mask
        MSK3: u1 = 0,
        /// DU [24:27]
        /// Date units or day in BCD
        DU: u4 = 0,
        /// DT [28:29]
        /// Date tens in BCD format
        DT: u2 = 0,
        /// WDSEL [30:30]
        /// Week day selection
        WDSEL: u1 = 0,
        /// MSK4 [31:31]
        /// Alarm B date mask
        MSK4: u1 = 0,
    };
    /// alarm B register
    pub const ALRMBR = Register(ALRMBR_val).init(base_address + 0x20);

    /// WPR
    const WPR_val = packed struct {
        /// KEY [0:7]
        /// Write protection key
        KEY: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// write protection register
    pub const WPR = Register(WPR_val).init(base_address + 0x24);

    /// SSR
    const SSR_val = packed struct {
        /// SS [0:15]
        /// Sub second value
        SS: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// sub second register
    pub const SSR = Register(SSR_val).init(base_address + 0x28);

    /// SHIFTR
    const SHIFTR_val = packed struct {
        /// SUBFS [0:14]
        /// Subtract a fraction of a
        SUBFS: u15 = 0,
        /// unused [15:30]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 0,
        /// ADD1S [31:31]
        /// Add one second
        ADD1S: u1 = 0,
    };
    /// shift control register
    pub const SHIFTR = Register(SHIFTR_val).init(base_address + 0x2c);

    /// TSTR
    const TSTR_val = packed struct {
        /// SU [0:3]
        /// Second units in BCD format
        SU: u4 = 0,
        /// ST [4:6]
        /// Second tens in BCD format
        ST: u3 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// MNU [8:11]
        /// Minute units in BCD format
        MNU: u4 = 0,
        /// MNT [12:14]
        /// Minute tens in BCD format
        MNT: u3 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// HU [16:19]
        /// Hour units in BCD format
        HU: u4 = 0,
        /// HT [20:21]
        /// Hour tens in BCD format
        HT: u2 = 0,
        /// PM [22:22]
        /// AM/PM notation
        PM: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// time stamp time register
    pub const TSTR = Register(TSTR_val).init(base_address + 0x30);

    /// TSDR
    const TSDR_val = packed struct {
        /// DU [0:3]
        /// Date units in BCD format
        DU: u4 = 0,
        /// DT [4:5]
        /// Date tens in BCD format
        DT: u2 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// MU [8:11]
        /// Month units in BCD format
        MU: u4 = 0,
        /// MT [12:12]
        /// Month tens in BCD format
        MT: u1 = 0,
        /// WDU [13:15]
        /// Week day units
        WDU: u3 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// time stamp date register
    pub const TSDR = Register(TSDR_val).init(base_address + 0x34);

    /// TSSSR
    const TSSSR_val = packed struct {
        /// SS [0:15]
        /// Sub second value
        SS: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// timestamp sub second register
    pub const TSSSR = Register(TSSSR_val).init(base_address + 0x38);

    /// CALR
    const CALR_val = packed struct {
        /// CALM [0:8]
        /// Calibration minus
        CALM: u9 = 0,
        /// unused [9:12]
        _unused9: u4 = 0,
        /// CALW16 [13:13]
        /// Use a 16-second calibration cycle
        CALW16: u1 = 0,
        /// CALW8 [14:14]
        /// Use an 8-second calibration cycle
        CALW8: u1 = 0,
        /// CALP [15:15]
        /// Increase frequency of RTC by 488.5
        CALP: u1 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// calibration register
    pub const CALR = Register(CALR_val).init(base_address + 0x3c);

    /// TAMPCR
    const TAMPCR_val = packed struct {
        /// TAMP1E [0:0]
        /// Tamper 1 detection enable
        TAMP1E: u1 = 0,
        /// TAMP1TRG [1:1]
        /// Active level for tamper 1
        TAMP1TRG: u1 = 0,
        /// TAMPIE [2:2]
        /// Tamper interrupt enable
        TAMPIE: u1 = 0,
        /// TAMP2E [3:3]
        /// Tamper 2 detection enable
        TAMP2E: u1 = 0,
        /// TAMP2TRG [4:4]
        /// Active level for tamper 2
        TAMP2TRG: u1 = 0,
        /// TAMP3E [5:5]
        /// Tamper 3 detection enable
        TAMP3E: u1 = 0,
        /// TAMP3TRG [6:6]
        /// Active level for tamper 3
        TAMP3TRG: u1 = 0,
        /// TAMPTS [7:7]
        /// Activate timestamp on tamper detection
        TAMPTS: u1 = 0,
        /// TAMPFREQ [8:10]
        /// Tamper sampling frequency
        TAMPFREQ: u3 = 0,
        /// TAMPFLT [11:12]
        /// Tamper filter count
        TAMPFLT: u2 = 0,
        /// TAMPPRCH [13:14]
        /// Tamper precharge duration
        TAMPPRCH: u2 = 0,
        /// TAMPPUDIS [15:15]
        /// TAMPER pull-up disable
        TAMPPUDIS: u1 = 0,
        /// TAMP1IE [16:16]
        /// Tamper 1 interrupt enable
        TAMP1IE: u1 = 0,
        /// TAMP1NOERASE [17:17]
        /// Tamper 1 no erase
        TAMP1NOERASE: u1 = 0,
        /// TAMP1MF [18:18]
        /// Tamper 1 mask flag
        TAMP1MF: u1 = 0,
        /// TAMP2IE [19:19]
        /// Tamper 2 interrupt enable
        TAMP2IE: u1 = 0,
        /// TAMP2NOERASE [20:20]
        /// Tamper 2 no erase
        TAMP2NOERASE: u1 = 0,
        /// TAMP2MF [21:21]
        /// Tamper 2 mask flag
        TAMP2MF: u1 = 0,
        /// TAMP3IE [22:22]
        /// Tamper 3 interrupt enable
        TAMP3IE: u1 = 0,
        /// TAMP3NOERASE [23:23]
        /// Tamper 3 no erase
        TAMP3NOERASE: u1 = 0,
        /// TAMP3MF [24:24]
        /// Tamper 3 mask flag
        TAMP3MF: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// tamper configuration register
    pub const TAMPCR = Register(TAMPCR_val).init(base_address + 0x40);

    /// ALRMASSR
    const ALRMASSR_val = packed struct {
        /// SS [0:14]
        /// Sub seconds value
        SS: u15 = 0,
        /// unused [15:23]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        /// MASKSS [24:27]
        /// Mask the most-significant bits starting
        MASKSS: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// alarm A sub second register
    pub const ALRMASSR = Register(ALRMASSR_val).init(base_address + 0x44);

    /// ALRMBSSR
    const ALRMBSSR_val = packed struct {
        /// SS [0:14]
        /// Sub seconds value
        SS: u15 = 0,
        /// unused [15:23]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        /// MASKSS [24:27]
        /// Mask the most-significant bits starting
        MASKSS: u4 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// alarm B sub second register
    pub const ALRMBSSR = Register(ALRMBSSR_val).init(base_address + 0x48);

    /// OR
    const OR_val = packed struct {
        /// RTC_ALARM_TYPE [0:0]
        /// RTC_ALARM on PC13 output
        RTC_ALARM_TYPE: u1 = 0,
        /// RTC_OUT_RMP [1:1]
        /// RTC_OUT remap
        RTC_OUT_RMP: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// option register
    pub const OR = Register(OR_val).init(base_address + 0x4c);

    /// BKP0R
    const BKP0R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP0R = Register(BKP0R_val).init(base_address + 0x50);

    /// BKP1R
    const BKP1R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP1R = Register(BKP1R_val).init(base_address + 0x54);

    /// BKP2R
    const BKP2R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP2R = Register(BKP2R_val).init(base_address + 0x58);

    /// BKP3R
    const BKP3R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP3R = Register(BKP3R_val).init(base_address + 0x5c);

    /// BKP4R
    const BKP4R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP4R = Register(BKP4R_val).init(base_address + 0x60);

    /// BKP5R
    const BKP5R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP5R = Register(BKP5R_val).init(base_address + 0x64);

    /// BKP6R
    const BKP6R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP6R = Register(BKP6R_val).init(base_address + 0x68);

    /// BKP7R
    const BKP7R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP7R = Register(BKP7R_val).init(base_address + 0x6c);

    /// BKP8R
    const BKP8R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP8R = Register(BKP8R_val).init(base_address + 0x70);

    /// BKP9R
    const BKP9R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP9R = Register(BKP9R_val).init(base_address + 0x74);

    /// BKP10R
    const BKP10R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP10R = Register(BKP10R_val).init(base_address + 0x78);

    /// BKP11R
    const BKP11R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP11R = Register(BKP11R_val).init(base_address + 0x7c);

    /// BKP12R
    const BKP12R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP12R = Register(BKP12R_val).init(base_address + 0x80);

    /// BKP13R
    const BKP13R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP13R = Register(BKP13R_val).init(base_address + 0x84);

    /// BKP14R
    const BKP14R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP14R = Register(BKP14R_val).init(base_address + 0x88);

    /// BKP15R
    const BKP15R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP15R = Register(BKP15R_val).init(base_address + 0x8c);

    /// BKP16R
    const BKP16R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP16R = Register(BKP16R_val).init(base_address + 0x90);

    /// BKP17R
    const BKP17R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP17R = Register(BKP17R_val).init(base_address + 0x94);

    /// BKP18R
    const BKP18R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP18R = Register(BKP18R_val).init(base_address + 0x98);

    /// BKP19R
    const BKP19R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP19R = Register(BKP19R_val).init(base_address + 0x9c);

    /// BKP20R
    const BKP20R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP20R = Register(BKP20R_val).init(base_address + 0xa0);

    /// BKP21R
    const BKP21R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP21R = Register(BKP21R_val).init(base_address + 0xa4);

    /// BKP22R
    const BKP22R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP22R = Register(BKP22R_val).init(base_address + 0xa8);

    /// BKP23R
    const BKP23R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP23R = Register(BKP23R_val).init(base_address + 0xac);

    /// BKP24R
    const BKP24R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP24R = Register(BKP24R_val).init(base_address + 0xb0);

    /// BKP25R
    const BKP25R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP25R = Register(BKP25R_val).init(base_address + 0xb4);

    /// BKP26R
    const BKP26R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP26R = Register(BKP26R_val).init(base_address + 0xb8);

    /// BKP27R
    const BKP27R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP27R = Register(BKP27R_val).init(base_address + 0xbc);

    /// BKP28R
    const BKP28R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP28R = Register(BKP28R_val).init(base_address + 0xc0);

    /// BKP29R
    const BKP29R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP29R = Register(BKP29R_val).init(base_address + 0xc4);

    /// BKP30R
    const BKP30R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP30R = Register(BKP30R_val).init(base_address + 0xc8);

    /// BKP31R
    const BKP31R_val = packed struct {
        /// BKP [0:31]
        /// BKP
        BKP: u32 = 0,
    };
    /// backup register
    pub const BKP31R = Register(BKP31R_val).init(base_address + 0xcc);
};

/// Universal synchronous asynchronous receiver
pub const USART6 = struct {
    const base_address = 0x40011400;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const USART1 = struct {
    const base_address = 0x40011000;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const USART3 = struct {
    const base_address = 0x40004800;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const USART2 = struct {
    const base_address = 0x40004400;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const UART5 = struct {
    const base_address = 0x40005000;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const UART4 = struct {
    const base_address = 0x40004c00;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const UART8 = struct {
    const base_address = 0x40007c00;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// Universal synchronous asynchronous receiver
pub const UART7 = struct {
    const base_address = 0x40007800;
    /// CR1
    const CR1_val = packed struct {
        /// UE [0:0]
        /// USART enable
        UE: u1 = 0,
        /// UESM [1:1]
        /// USART enable in Stop mode
        UESM: u1 = 0,
        /// RE [2:2]
        /// Receiver enable
        RE: u1 = 0,
        /// TE [3:3]
        /// Transmitter enable
        TE: u1 = 0,
        /// IDLEIE [4:4]
        /// IDLE interrupt enable
        IDLEIE: u1 = 0,
        /// RXNEIE [5:5]
        /// RXNE interrupt enable
        RXNEIE: u1 = 0,
        /// TCIE [6:6]
        /// Transmission complete interrupt
        TCIE: u1 = 0,
        /// TXEIE [7:7]
        /// interrupt enable
        TXEIE: u1 = 0,
        /// PEIE [8:8]
        /// PE interrupt enable
        PEIE: u1 = 0,
        /// PS [9:9]
        /// Parity selection
        PS: u1 = 0,
        /// PCE [10:10]
        /// Parity control enable
        PCE: u1 = 0,
        /// WAKE [11:11]
        /// Receiver wakeup method
        WAKE: u1 = 0,
        /// M0 [12:12]
        /// Word length
        M0: u1 = 0,
        /// MME [13:13]
        /// Mute mode enable
        MME: u1 = 0,
        /// CMIE [14:14]
        /// Character match interrupt
        CMIE: u1 = 0,
        /// OVER8 [15:15]
        /// Oversampling mode
        OVER8: u1 = 0,
        /// DEDT0 [16:16]
        /// DEDT0
        DEDT0: u1 = 0,
        /// DEDT1 [17:17]
        /// DEDT1
        DEDT1: u1 = 0,
        /// DEDT2 [18:18]
        /// DEDT2
        DEDT2: u1 = 0,
        /// DEDT3 [19:19]
        /// DEDT3
        DEDT3: u1 = 0,
        /// DEDT4 [20:20]
        /// Driver Enable de-assertion
        DEDT4: u1 = 0,
        /// DEAT0 [21:21]
        /// DEAT0
        DEAT0: u1 = 0,
        /// DEAT1 [22:22]
        /// DEAT1
        DEAT1: u1 = 0,
        /// DEAT2 [23:23]
        /// DEAT2
        DEAT2: u1 = 0,
        /// DEAT3 [24:24]
        /// DEAT3
        DEAT3: u1 = 0,
        /// DEAT4 [25:25]
        /// Driver Enable assertion
        DEAT4: u1 = 0,
        /// RTOIE [26:26]
        /// Receiver timeout interrupt
        RTOIE: u1 = 0,
        /// EOBIE [27:27]
        /// End of Block interrupt
        EOBIE: u1 = 0,
        /// M1 [28:28]
        /// Word length
        M1: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Control register 1
    pub const CR1 = Register(CR1_val).init(base_address + 0x0);

    /// CR2
    const CR2_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// ADDM7 [4:4]
        /// 7-bit Address Detection/4-bit Address
        ADDM7: u1 = 0,
        /// LBDL [5:5]
        /// LIN break detection length
        LBDL: u1 = 0,
        /// LBDIE [6:6]
        /// LIN break detection interrupt
        LBDIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBCL [8:8]
        /// Last bit clock pulse
        LBCL: u1 = 0,
        /// CPHA [9:9]
        /// Clock phase
        CPHA: u1 = 0,
        /// CPOL [10:10]
        /// Clock polarity
        CPOL: u1 = 0,
        /// CLKEN [11:11]
        /// Clock enable
        CLKEN: u1 = 0,
        /// STOP [12:13]
        /// STOP bits
        STOP: u2 = 0,
        /// LINEN [14:14]
        /// LIN mode enable
        LINEN: u1 = 0,
        /// SWAP [15:15]
        /// Swap TX/RX pins
        SWAP: u1 = 0,
        /// RXINV [16:16]
        /// RX pin active level
        RXINV: u1 = 0,
        /// TXINV [17:17]
        /// TX pin active level
        TXINV: u1 = 0,
        /// TAINV [18:18]
        /// Binary data inversion
        TAINV: u1 = 0,
        /// MSBFIRST [19:19]
        /// Most significant bit first
        MSBFIRST: u1 = 0,
        /// ABREN [20:20]
        /// Auto baud rate enable
        ABREN: u1 = 0,
        /// ABRMOD0 [21:21]
        /// ABRMOD0
        ABRMOD0: u1 = 0,
        /// ABRMOD1 [22:22]
        /// Auto baud rate mode
        ABRMOD1: u1 = 0,
        /// RTOEN [23:23]
        /// Receiver timeout enable
        RTOEN: u1 = 0,
        /// ADD0_3 [24:27]
        /// Address of the USART node
        ADD0_3: u4 = 0,
        /// ADD4_7 [28:31]
        /// Address of the USART node
        ADD4_7: u4 = 0,
    };
    /// Control register 2
    pub const CR2 = Register(CR2_val).init(base_address + 0x4);

    /// CR3
    const CR3_val = packed struct {
        /// EIE [0:0]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// IREN [1:1]
        /// Ir mode enable
        IREN: u1 = 0,
        /// IRLP [2:2]
        /// Ir low-power
        IRLP: u1 = 0,
        /// HDSEL [3:3]
        /// Half-duplex selection
        HDSEL: u1 = 0,
        /// NACK [4:4]
        /// Smartcard NACK enable
        NACK: u1 = 0,
        /// SCEN [5:5]
        /// Smartcard mode enable
        SCEN: u1 = 0,
        /// DMAR [6:6]
        /// DMA enable receiver
        DMAR: u1 = 0,
        /// DMAT [7:7]
        /// DMA enable transmitter
        DMAT: u1 = 0,
        /// RTSE [8:8]
        /// RTS enable
        RTSE: u1 = 0,
        /// CTSE [9:9]
        /// CTS enable
        CTSE: u1 = 0,
        /// CTSIE [10:10]
        /// CTS interrupt enable
        CTSIE: u1 = 0,
        /// ONEBIT [11:11]
        /// One sample bit method
        ONEBIT: u1 = 0,
        /// OVRDIS [12:12]
        /// Overrun Disable
        OVRDIS: u1 = 0,
        /// DDRE [13:13]
        /// DMA Disable on Reception
        DDRE: u1 = 0,
        /// DEM [14:14]
        /// Driver enable mode
        DEM: u1 = 0,
        /// DEP [15:15]
        /// Driver enable polarity
        DEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// SCARCNT [17:19]
        /// Smartcard auto-retry count
        SCARCNT: u3 = 0,
        /// WUS [20:21]
        /// Wakeup from Stop mode interrupt flag
        WUS: u2 = 0,
        /// WUFIE [22:22]
        /// Wakeup from Stop mode interrupt
        WUFIE: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Control register 3
    pub const CR3 = Register(CR3_val).init(base_address + 0x8);

    /// BRR
    const BRR_val = packed struct {
        /// DIV_Fraction [0:3]
        /// DIV_Fraction
        DIV_Fraction: u4 = 0,
        /// DIV_Mantissa [4:15]
        /// DIV_Mantissa
        DIV_Mantissa: u12 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Baud rate register
    pub const BRR = Register(BRR_val).init(base_address + 0xc);

    /// GTPR
    const GTPR_val = packed struct {
        /// PSC [0:7]
        /// Prescaler value
        PSC: u8 = 0,
        /// GT [8:15]
        /// Guard time value
        GT: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Guard time and prescaler
    pub const GTPR = Register(GTPR_val).init(base_address + 0x10);

    /// RTOR
    const RTOR_val = packed struct {
        /// RTO [0:23]
        /// Receiver timeout value
        RTO: u24 = 0,
        /// BLEN [24:31]
        /// Block Length
        BLEN: u8 = 0,
    };
    /// Receiver timeout register
    pub const RTOR = Register(RTOR_val).init(base_address + 0x14);

    /// RQR
    const RQR_val = packed struct {
        /// ABRRQ [0:0]
        /// Auto baud rate request
        ABRRQ: u1 = 0,
        /// SBKRQ [1:1]
        /// Send break request
        SBKRQ: u1 = 0,
        /// MMRQ [2:2]
        /// Mute mode request
        MMRQ: u1 = 0,
        /// RXFRQ [3:3]
        /// Receive data flush request
        RXFRQ: u1 = 0,
        /// TXFRQ [4:4]
        /// Transmit data flush
        TXFRQ: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Request register
    pub const RQR = Register(RQR_val).init(base_address + 0x18);

    /// ISR
    const ISR_val = packed struct {
        /// PE [0:0]
        /// PE
        PE: u1 = 0,
        /// FE [1:1]
        /// FE
        FE: u1 = 0,
        /// NF [2:2]
        /// NF
        NF: u1 = 0,
        /// ORE [3:3]
        /// ORE
        ORE: u1 = 0,
        /// IDLE [4:4]
        /// IDLE
        IDLE: u1 = 0,
        /// RXNE [5:5]
        /// RXNE
        RXNE: u1 = 0,
        /// TC [6:6]
        /// TC
        TC: u1 = 1,
        /// TXE [7:7]
        /// TXE
        TXE: u1 = 1,
        /// LBDF [8:8]
        /// LBDF
        LBDF: u1 = 0,
        /// CTSIF [9:9]
        /// CTSIF
        CTSIF: u1 = 0,
        /// CTS [10:10]
        /// CTS
        CTS: u1 = 0,
        /// RTOF [11:11]
        /// RTOF
        RTOF: u1 = 0,
        /// EOBF [12:12]
        /// EOBF
        EOBF: u1 = 0,
        /// unused [13:13]
        _unused13: u1 = 0,
        /// ABRE [14:14]
        /// ABRE
        ABRE: u1 = 0,
        /// ABRF [15:15]
        /// ABRF
        ABRF: u1 = 0,
        /// BUSY [16:16]
        /// BUSY
        BUSY: u1 = 0,
        /// CMF [17:17]
        /// CMF
        CMF: u1 = 0,
        /// SBKF [18:18]
        /// SBKF
        SBKF: u1 = 0,
        /// RWU [19:19]
        /// RWU
        RWU: u1 = 0,
        /// WUF [20:20]
        /// WUF
        WUF: u1 = 0,
        /// TEACK [21:21]
        /// TEACK
        TEACK: u1 = 0,
        /// REACK [22:22]
        /// REACK
        REACK: u1 = 0,
        /// unused [23:31]
        _unused23: u1 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt &amp; status
    pub const ISR = Register(ISR_val).init(base_address + 0x1c);

    /// ICR
    const ICR_val = packed struct {
        /// PECF [0:0]
        /// Parity error clear flag
        PECF: u1 = 0,
        /// FECF [1:1]
        /// Framing error clear flag
        FECF: u1 = 0,
        /// NCF [2:2]
        /// Noise detected clear flag
        NCF: u1 = 0,
        /// ORECF [3:3]
        /// Overrun error clear flag
        ORECF: u1 = 0,
        /// IDLECF [4:4]
        /// Idle line detected clear
        IDLECF: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// TCCF [6:6]
        /// Transmission complete clear
        TCCF: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// LBDCF [8:8]
        /// LIN break detection clear
        LBDCF: u1 = 0,
        /// CTSCF [9:9]
        /// CTS clear flag
        CTSCF: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// RTOCF [11:11]
        /// Receiver timeout clear
        RTOCF: u1 = 0,
        /// EOBCF [12:12]
        /// End of block clear flag
        EOBCF: u1 = 0,
        /// unused [13:16]
        _unused13: u3 = 0,
        _unused16: u1 = 0,
        /// CMCF [17:17]
        /// Character match clear flag
        CMCF: u1 = 0,
        /// unused [18:19]
        _unused18: u2 = 0,
        /// WUCF [20:20]
        /// Wakeup from Stop mode clear
        WUCF: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// Interrupt flag clear register
    pub const ICR = Register(ICR_val).init(base_address + 0x20);

    /// RDR
    const RDR_val = packed struct {
        /// RDR [0:8]
        /// Receive data value
        RDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Receive data register
    pub const RDR = Register(RDR_val).init(base_address + 0x24);

    /// TDR
    const TDR_val = packed struct {
        /// TDR [0:8]
        /// Transmit data value
        TDR: u9 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Transmit data register
    pub const TDR = Register(TDR_val).init(base_address + 0x28);
};

/// USB on the go full speed
pub const OTG_FS_GLOBAL = struct {
    const base_address = 0x50000000;
    /// OTG_FS_GOTGCTL
    const OTG_FS_GOTGCTL_val = packed struct {
        /// SRQSCS [0:0]
        /// Session request success
        SRQSCS: u1 = 0,
        /// SRQ [1:1]
        /// Session request
        SRQ: u1 = 0,
        /// VBVALOEN [2:2]
        /// VBUS valid override enable
        VBVALOEN: u1 = 0,
        /// VBVALOVAL [3:3]
        /// VBUS valid override value
        VBVALOVAL: u1 = 0,
        /// AVALOEN [4:4]
        /// A-peripheral session valid override
        AVALOEN: u1 = 0,
        /// AVALOVAL [5:5]
        /// A-peripheral session valid override
        AVALOVAL: u1 = 0,
        /// BVALOEN [6:6]
        /// B-peripheral session valid override
        BVALOEN: u1 = 0,
        /// BVALOVAL [7:7]
        /// B-peripheral session valid override
        BVALOVAL: u1 = 0,
        /// HNGSCS [8:8]
        /// Host negotiation success
        HNGSCS: u1 = 0,
        /// HNPRQ [9:9]
        /// HNP request
        HNPRQ: u1 = 0,
        /// HSHNPEN [10:10]
        /// Host set HNP enable
        HSHNPEN: u1 = 0,
        /// DHNPEN [11:11]
        /// Device HNP enabled
        DHNPEN: u1 = 1,
        /// EHEN [12:12]
        /// Embedded host enable
        EHEN: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CIDSTS [16:16]
        /// Connector ID status
        CIDSTS: u1 = 0,
        /// DBCT [17:17]
        /// Long/short debounce time
        DBCT: u1 = 0,
        /// ASVLD [18:18]
        /// A-session valid
        ASVLD: u1 = 0,
        /// BSVLD [19:19]
        /// B-session valid
        BSVLD: u1 = 0,
        /// OTGVER [20:20]
        /// OTG version
        OTGVER: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS control and status register
    pub const OTG_FS_GOTGCTL = Register(OTG_FS_GOTGCTL_val).init(base_address + 0x0);

    /// OTG_FS_GOTGINT
    const OTG_FS_GOTGINT_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// SEDET [2:2]
        /// Session end detected
        SEDET: u1 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// SRSSCHG [8:8]
        /// Session request success status
        SRSSCHG: u1 = 0,
        /// HNSSCHG [9:9]
        /// Host negotiation success status
        HNSSCHG: u1 = 0,
        /// unused [10:16]
        _unused10: u6 = 0,
        _unused16: u1 = 0,
        /// HNGDET [17:17]
        /// Host negotiation detected
        HNGDET: u1 = 0,
        /// ADTOCHG [18:18]
        /// A-device timeout change
        ADTOCHG: u1 = 0,
        /// DBCDNE [19:19]
        /// Debounce done
        DBCDNE: u1 = 0,
        /// IDCHNG [20:20]
        /// ID input pin changed
        IDCHNG: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS interrupt register
    pub const OTG_FS_GOTGINT = Register(OTG_FS_GOTGINT_val).init(base_address + 0x4);

    /// OTG_FS_GAHBCFG
    const OTG_FS_GAHBCFG_val = packed struct {
        /// GINT [0:0]
        /// Global interrupt mask
        GINT: u1 = 0,
        /// unused [1:6]
        _unused1: u6 = 0,
        /// TXFELVL [7:7]
        /// TxFIFO empty level
        TXFELVL: u1 = 0,
        /// PTXFELVL [8:8]
        /// Periodic TxFIFO empty
        PTXFELVL: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS AHB configuration register
    pub const OTG_FS_GAHBCFG = Register(OTG_FS_GAHBCFG_val).init(base_address + 0x8);

    /// OTG_FS_GUSBCFG
    const OTG_FS_GUSBCFG_val = packed struct {
        /// TOCAL [0:2]
        /// FS timeout calibration
        TOCAL: u3 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// PHYSEL [6:6]
        /// Full Speed serial transceiver
        PHYSEL: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// SRPCAP [8:8]
        /// SRP-capable
        SRPCAP: u1 = 0,
        /// HNPCAP [9:9]
        /// HNP-capable
        HNPCAP: u1 = 1,
        /// TRDT [10:13]
        /// USB turnaround time
        TRDT: u4 = 2,
        /// unused [14:28]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u5 = 0,
        /// FHMOD [29:29]
        /// Force host mode
        FHMOD: u1 = 0,
        /// FDMOD [30:30]
        /// Force device mode
        FDMOD: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS USB configuration register
    pub const OTG_FS_GUSBCFG = Register(OTG_FS_GUSBCFG_val).init(base_address + 0xc);

    /// OTG_FS_GRSTCTL
    const OTG_FS_GRSTCTL_val = packed struct {
        /// CSRST [0:0]
        /// Core soft reset
        CSRST: u1 = 0,
        /// HSRST [1:1]
        /// HCLK soft reset
        HSRST: u1 = 0,
        /// FCRST [2:2]
        /// Host frame counter reset
        FCRST: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RXFFLSH [4:4]
        /// RxFIFO flush
        RXFFLSH: u1 = 0,
        /// TXFFLSH [5:5]
        /// TxFIFO flush
        TXFFLSH: u1 = 0,
        /// TXFNUM [6:10]
        /// TxFIFO number
        TXFNUM: u5 = 0,
        /// unused [11:30]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u7 = 32,
        /// AHBIDL [31:31]
        /// AHB master idle
        AHBIDL: u1 = 0,
    };
    /// OTG_FS reset register
    pub const OTG_FS_GRSTCTL = Register(OTG_FS_GRSTCTL_val).init(base_address + 0x10);

    /// OTG_FS_GINTSTS
    const OTG_FS_GINTSTS_val = packed struct {
        /// CMOD [0:0]
        /// Current mode of operation
        CMOD: u1 = 0,
        /// MMIS [1:1]
        /// Mode mismatch interrupt
        MMIS: u1 = 0,
        /// OTGINT [2:2]
        /// OTG interrupt
        OTGINT: u1 = 0,
        /// SOF [3:3]
        /// Start of frame
        SOF: u1 = 0,
        /// RXFLVL [4:4]
        /// RxFIFO non-empty
        RXFLVL: u1 = 0,
        /// NPTXFE [5:5]
        /// Non-periodic TxFIFO empty
        NPTXFE: u1 = 1,
        /// GINAKEFF [6:6]
        /// Global IN non-periodic NAK
        GINAKEFF: u1 = 0,
        /// GOUTNAKEFF [7:7]
        /// Global OUT NAK effective
        GOUTNAKEFF: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// ESUSP [10:10]
        /// Early suspend
        ESUSP: u1 = 0,
        /// USBSUSP [11:11]
        /// USB suspend
        USBSUSP: u1 = 0,
        /// USBRST [12:12]
        /// USB reset
        USBRST: u1 = 0,
        /// ENUMDNE [13:13]
        /// Enumeration done
        ENUMDNE: u1 = 0,
        /// ISOODRP [14:14]
        /// Isochronous OUT packet dropped
        ISOODRP: u1 = 0,
        /// EOPF [15:15]
        /// End of periodic frame
        EOPF: u1 = 0,
        /// unused [16:17]
        _unused16: u2 = 0,
        /// IEPINT [18:18]
        /// IN endpoint interrupt
        IEPINT: u1 = 0,
        /// OEPINT [19:19]
        /// OUT endpoint interrupt
        OEPINT: u1 = 0,
        /// IISOIXFR [20:20]
        /// Incomplete isochronous IN
        IISOIXFR: u1 = 0,
        /// IPXFR_INCOMPISOOUT [21:21]
        /// Incomplete periodic transfer(Host
        IPXFR_INCOMPISOOUT: u1 = 0,
        /// unused [22:22]
        _unused22: u1 = 0,
        /// RSTDET [23:23]
        /// Reset detected interrupt
        RSTDET: u1 = 0,
        /// HPRTINT [24:24]
        /// Host port interrupt
        HPRTINT: u1 = 0,
        /// HCINT [25:25]
        /// Host channels interrupt
        HCINT: u1 = 0,
        /// PTXFE [26:26]
        /// Periodic TxFIFO empty
        PTXFE: u1 = 1,
        /// unused [27:27]
        _unused27: u1 = 0,
        /// CIDSCHG [28:28]
        /// Connector ID status change
        CIDSCHG: u1 = 0,
        /// DISCINT [29:29]
        /// Disconnect detected
        DISCINT: u1 = 0,
        /// SRQINT [30:30]
        /// Session request/new session detected
        SRQINT: u1 = 0,
        /// WKUPINT [31:31]
        /// Resume/remote wakeup detected
        WKUPINT: u1 = 0,
    };
    /// OTG_FS core interrupt register
    pub const OTG_FS_GINTSTS = Register(OTG_FS_GINTSTS_val).init(base_address + 0x14);

    /// OTG_FS_GINTMSK
    const OTG_FS_GINTMSK_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// MMISM [1:1]
        /// Mode mismatch interrupt
        MMISM: u1 = 0,
        /// OTGINT [2:2]
        /// OTG interrupt mask
        OTGINT: u1 = 0,
        /// SOFM [3:3]
        /// Start of frame mask
        SOFM: u1 = 0,
        /// RXFLVLM [4:4]
        /// Receive FIFO non-empty
        RXFLVLM: u1 = 0,
        /// NPTXFEM [5:5]
        /// Non-periodic TxFIFO empty
        NPTXFEM: u1 = 0,
        /// GINAKEFFM [6:6]
        /// Global non-periodic IN NAK effective
        GINAKEFFM: u1 = 0,
        /// GONAKEFFM [7:7]
        /// Global OUT NAK effective
        GONAKEFFM: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// ESUSPM [10:10]
        /// Early suspend mask
        ESUSPM: u1 = 0,
        /// USBSUSPM [11:11]
        /// USB suspend mask
        USBSUSPM: u1 = 0,
        /// USBRST [12:12]
        /// USB reset mask
        USBRST: u1 = 0,
        /// ENUMDNEM [13:13]
        /// Enumeration done mask
        ENUMDNEM: u1 = 0,
        /// ISOODRPM [14:14]
        /// Isochronous OUT packet dropped interrupt
        ISOODRPM: u1 = 0,
        /// EOPFM [15:15]
        /// End of periodic frame interrupt
        EOPFM: u1 = 0,
        /// unused [16:17]
        _unused16: u2 = 0,
        /// IEPINT [18:18]
        /// IN endpoints interrupt
        IEPINT: u1 = 0,
        /// OEPINT [19:19]
        /// OUT endpoints interrupt
        OEPINT: u1 = 0,
        /// IISOIXFRM [20:20]
        /// Incomplete isochronous IN transfer
        IISOIXFRM: u1 = 0,
        /// IPXFRM_IISOOXFRM [21:21]
        /// Incomplete periodic transfer mask(Host
        IPXFRM_IISOOXFRM: u1 = 0,
        /// unused [22:22]
        _unused22: u1 = 0,
        /// RSTDETM [23:23]
        /// Reset detected interrupt
        RSTDETM: u1 = 0,
        /// PRTIM [24:24]
        /// Host port interrupt mask
        PRTIM: u1 = 0,
        /// HCIM [25:25]
        /// Host channels interrupt
        HCIM: u1 = 0,
        /// PTXFEM [26:26]
        /// Periodic TxFIFO empty mask
        PTXFEM: u1 = 0,
        /// LPMIN [27:27]
        /// LPM interrupt mask
        LPMIN: u1 = 0,
        /// CIDSCHGM [28:28]
        /// Connector ID status change
        CIDSCHGM: u1 = 0,
        /// DISCINT [29:29]
        /// Disconnect detected interrupt
        DISCINT: u1 = 0,
        /// SRQIM [30:30]
        /// Session request/new session detected
        SRQIM: u1 = 0,
        /// WUIM [31:31]
        /// Resume/remote wakeup detected interrupt
        WUIM: u1 = 0,
    };
    /// OTG_FS interrupt mask register
    pub const OTG_FS_GINTMSK = Register(OTG_FS_GINTMSK_val).init(base_address + 0x18);

    /// OTG_FS_GRXSTSR_Device
    const OTG_FS_GRXSTSR_Device_val = packed struct {
        /// EPNUM [0:3]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// FRMNUM [21:24]
        /// Frame number
        FRMNUM: u4 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// OTG_FS Receive status debug read(Device
    pub const OTG_FS_GRXSTSR_Device = Register(OTG_FS_GRXSTSR_Device_val).init(base_address + 0x1c);

    /// OTG_FS_GRXSTSR_Host
    const OTG_FS_GRXSTSR_Host_val = packed struct {
        /// CHNUM [0:3]
        /// Endpoint number
        CHNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS Receive status debug read(Host
    pub const OTG_FS_GRXSTSR_Host = Register(OTG_FS_GRXSTSR_Host_val).init(base_address + 0x1c);

    /// OTG_FS_GRXFSIZ
    const OTG_FS_GRXFSIZ_val = packed struct {
        /// RXFD [0:15]
        /// RxFIFO depth
        RXFD: u16 = 512,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS Receive FIFO size register
    pub const OTG_FS_GRXFSIZ = Register(OTG_FS_GRXFSIZ_val).init(base_address + 0x24);

    /// OTG_FS_DIEPTXF0_Device
    const OTG_FS_DIEPTXF0_Device_val = packed struct {
        /// TX0FSA [0:15]
        /// Endpoint 0 transmit RAM start
        TX0FSA: u16 = 512,
        /// TX0FD [16:31]
        /// Endpoint 0 TxFIFO depth
        TX0FD: u16 = 0,
    };
    /// OTG_FS Endpoint 0 Transmit FIFO
    pub const OTG_FS_DIEPTXF0_Device = Register(OTG_FS_DIEPTXF0_Device_val).init(base_address + 0x28);

    /// OTG_FS_HNPTXFSIZ_Host
    const OTG_FS_HNPTXFSIZ_Host_val = packed struct {
        /// NPTXFSA [0:15]
        /// Non-periodic transmit RAM start
        NPTXFSA: u16 = 512,
        /// NPTXFD [16:31]
        /// Non-periodic TxFIFO depth
        NPTXFD: u16 = 0,
    };
    /// OTG_FS Host non-periodic transmit FIFO size
    pub const OTG_FS_HNPTXFSIZ_Host = Register(OTG_FS_HNPTXFSIZ_Host_val).init(base_address + 0x28);

    /// OTG_FS_HNPTXSTS
    const OTG_FS_HNPTXSTS_val = packed struct {
        /// NPTXFSAV [0:15]
        /// Non-periodic TxFIFO space
        NPTXFSAV: u16 = 512,
        /// NPTQXSAV [16:23]
        /// Non-periodic transmit request queue
        NPTQXSAV: u8 = 8,
        /// NPTXQTOP [24:30]
        /// Top of the non-periodic transmit request
        NPTXQTOP: u7 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS non-periodic transmit FIFO/queue
    pub const OTG_FS_HNPTXSTS = Register(OTG_FS_HNPTXSTS_val).init(base_address + 0x2c);

    /// OTG_FS_GCCFG
    const OTG_FS_GCCFG_val = packed struct {
        /// DCDET [0:0]
        /// Data contact detection (DCD)
        DCDET: u1 = 0,
        /// PDET [1:1]
        /// Primary detection (PD)
        PDET: u1 = 0,
        /// SDET [2:2]
        /// Secondary detection (SD)
        SDET: u1 = 0,
        /// PS2DET [3:3]
        /// DM pull-up detection
        PS2DET: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// PWRDWN [16:16]
        /// Power down
        PWRDWN: u1 = 0,
        /// BCDEN [17:17]
        /// Battery charging detector (BCD)
        BCDEN: u1 = 0,
        /// DCDEN [18:18]
        /// Data contact detection (DCD) mode
        DCDEN: u1 = 0,
        /// PDEN [19:19]
        /// Primary detection (PD) mode
        PDEN: u1 = 0,
        /// SDEN [20:20]
        /// Secondary detection (SD) mode
        SDEN: u1 = 0,
        /// VBDEN [21:21]
        /// USB VBUS detection enable
        VBDEN: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS general core configuration register
    pub const OTG_FS_GCCFG = Register(OTG_FS_GCCFG_val).init(base_address + 0x38);

    /// OTG_FS_CID
    const OTG_FS_CID_val = packed struct {
        /// PRODUCT_ID [0:31]
        /// Product ID field
        PRODUCT_ID: u32 = 4096,
    };
    /// core ID register
    pub const OTG_FS_CID = Register(OTG_FS_CID_val).init(base_address + 0x3c);

    /// OTG_FS_HPTXFSIZ
    const OTG_FS_HPTXFSIZ_val = packed struct {
        /// PTXSA [0:15]
        /// Host periodic TxFIFO start
        PTXSA: u16 = 1536,
        /// PTXFSIZ [16:31]
        /// Host periodic TxFIFO depth
        PTXFSIZ: u16 = 512,
    };
    /// OTG_FS Host periodic transmit FIFO size
    pub const OTG_FS_HPTXFSIZ = Register(OTG_FS_HPTXFSIZ_val).init(base_address + 0x100);

    /// OTG_FS_DIEPTXF1
    const OTG_FS_DIEPTXF1_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFO2 transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_FS device IN endpoint transmit FIFO size
    pub const OTG_FS_DIEPTXF1 = Register(OTG_FS_DIEPTXF1_val).init(base_address + 0x104);

    /// OTG_FS_DIEPTXF2
    const OTG_FS_DIEPTXF2_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFO3 transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_FS device IN endpoint transmit FIFO size
    pub const OTG_FS_DIEPTXF2 = Register(OTG_FS_DIEPTXF2_val).init(base_address + 0x108);

    /// OTG_FS_DIEPTXF3
    const OTG_FS_DIEPTXF3_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFO4 transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_FS device IN endpoint transmit FIFO size
    pub const OTG_FS_DIEPTXF3 = Register(OTG_FS_DIEPTXF3_val).init(base_address + 0x10c);

    /// OTG_FS_GRXSTSP_Device
    const OTG_FS_GRXSTSP_Device_val = packed struct {
        /// EPNUM [0:3]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 64,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// FRMNUM [21:24]
        /// Frame number
        FRMNUM: u4 = 0,
        /// unused [25:31]
        _unused25: u7 = 1,
    };
    /// OTG status read and pop register (Device
    pub const OTG_FS_GRXSTSP_Device = Register(OTG_FS_GRXSTSP_Device_val).init(base_address + 0x20);

    /// OTG_FS_GRXSTSP_Host
    const OTG_FS_GRXSTSP_Host_val = packed struct {
        /// CHNUM [0:3]
        /// Channel number
        CHNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 64,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 2,
    };
    /// OTG status read and pop register (Host
    pub const OTG_FS_GRXSTSP_Host = Register(OTG_FS_GRXSTSP_Host_val).init(base_address + 0x20);

    /// OTG_FS_GI2CCTL
    const OTG_FS_GI2CCTL_val = packed struct {
        /// RWDATA [0:7]
        /// I2C Read/Write Data
        RWDATA: u8 = 0,
        /// REGADDR [8:15]
        /// I2C Register Address
        REGADDR: u8 = 4,
        /// ADDR [16:22]
        /// I2C Address
        ADDR: u7 = 0,
        /// I2CEN [23:23]
        /// I2C Enable
        I2CEN: u1 = 0,
        /// ACK [24:24]
        /// I2C ACK
        ACK: u1 = 0,
        /// unused [25:25]
        _unused25: u1 = 1,
        /// I2CDEVADR [26:27]
        /// I2C Device Address
        I2CDEVADR: u2 = 0,
        /// I2CDATSE0 [28:28]
        /// I2C DatSe0 USB mode
        I2CDATSE0: u1 = 0,
        /// unused [29:29]
        _unused29: u1 = 0,
        /// RW [30:30]
        /// Read/Write Indicator
        RW: u1 = 0,
        /// BSYDNE [31:31]
        /// I2C Busy/Done
        BSYDNE: u1 = 0,
    };
    /// OTG I2C access register
    pub const OTG_FS_GI2CCTL = Register(OTG_FS_GI2CCTL_val).init(base_address + 0x30);

    /// OTG_FS_GPWRDN
    const OTG_FS_GPWRDN_val = packed struct {
        /// ADPMEN [0:0]
        /// ADP module enable
        ADPMEN: u1 = 0,
        /// unused [1:22]
        _unused1: u7 = 0,
        _unused8: u8 = 4,
        _unused16: u7 = 0,
        /// ADPIF [23:23]
        /// ADP interrupt flag
        ADPIF: u1 = 0,
        /// unused [24:31]
        _unused24: u8 = 2,
    };
    /// OTG power down register
    pub const OTG_FS_GPWRDN = Register(OTG_FS_GPWRDN_val).init(base_address + 0x58);

    /// OTG_FS_GADPCTL
    const OTG_FS_GADPCTL_val = packed struct {
        /// PRBDSCHG [0:1]
        /// Probe discharge
        PRBDSCHG: u2 = 0,
        /// PRBDELTA [2:3]
        /// Probe delta
        PRBDELTA: u2 = 0,
        /// PRBPER [4:5]
        /// Probe period
        PRBPER: u2 = 0,
        /// RTIM [6:16]
        /// Ramp time
        RTIM: u11 = 16,
        /// ENAPRB [17:17]
        /// Enable probe
        ENAPRB: u1 = 0,
        /// ENASNS [18:18]
        /// Enable sense
        ENASNS: u1 = 0,
        /// ADPRST [19:19]
        /// ADP reset
        ADPRST: u1 = 0,
        /// ADPEN [20:20]
        /// ADP enable
        ADPEN: u1 = 0,
        /// ADPPRBIF [21:21]
        /// ADP probe interrupt flag
        ADPPRBIF: u1 = 0,
        /// ADPSNSIF [22:22]
        /// ADP sense interrupt flag
        ADPSNSIF: u1 = 0,
        /// ADPTOIF [23:23]
        /// ADP timeout interrupt flag
        ADPTOIF: u1 = 0,
        /// ADPPRBIM [24:24]
        /// ADP probe interrupt mask
        ADPPRBIM: u1 = 0,
        /// ADPSNSIM [25:25]
        /// ADP sense interrupt mask
        ADPSNSIM: u1 = 1,
        /// ADPTOIM [26:26]
        /// ADP timeout interrupt mask
        ADPTOIM: u1 = 0,
        /// AR [27:28]
        /// Access request
        AR: u2 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// OTG ADP timer, control and status
    pub const OTG_FS_GADPCTL = Register(OTG_FS_GADPCTL_val).init(base_address + 0x60);

    /// OTG_FS_DIEPTXF4
    const OTG_FS_DIEPTXF4_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint Tx FIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_FS device IN endpoint transmit FIFO size
    pub const OTG_FS_DIEPTXF4 = Register(OTG_FS_DIEPTXF4_val).init(base_address + 0x110);

    /// OTG_FS_DIEPTXF5
    const OTG_FS_DIEPTXF5_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint Tx FIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_FS device IN endpoint transmit FIFO size
    pub const OTG_FS_DIEPTXF5 = Register(OTG_FS_DIEPTXF5_val).init(base_address + 0x114);

    /// OTG_FS_GLPMCFG
    const OTG_FS_GLPMCFG_val = packed struct {
        /// LPMEN [0:0]
        /// LPM support enable
        LPMEN: u1 = 0,
        /// LPMACK [1:1]
        /// LPM token acknowledge
        LPMACK: u1 = 0,
        /// BESL [2:5]
        /// Best effort service
        BESL: u4 = 0,
        /// REMWAKE [6:6]
        /// bRemoteWake value
        REMWAKE: u1 = 0,
        /// L1SSEN [7:7]
        /// L1 Shallow Sleep enable
        L1SSEN: u1 = 0,
        /// BESLTHRS [8:11]
        /// BESL threshold
        BESLTHRS: u4 = 4,
        /// L1DSEN [12:12]
        /// L1 deep sleep enable
        L1DSEN: u1 = 0,
        /// LPMRST [13:14]
        /// LPM response
        LPMRST: u2 = 0,
        /// SLPSTS [15:15]
        /// Port sleep status
        SLPSTS: u1 = 0,
        /// L1RSMOK [16:16]
        /// Sleep State Resume OK
        L1RSMOK: u1 = 0,
        /// LPMCHIDX [17:20]
        /// LPM Channel Index
        LPMCHIDX: u4 = 0,
        /// LPMRCNT [21:23]
        /// LPM retry count
        LPMRCNT: u3 = 0,
        /// SNDLPM [24:24]
        /// Send LPM transaction
        SNDLPM: u1 = 0,
        /// LPMRCNTSTS [25:27]
        /// LPM retry count status
        LPMRCNTSTS: u3 = 1,
        /// ENBESL [28:28]
        /// Enable best effort service
        ENBESL: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// OTG core LPM configuration
    pub const OTG_FS_GLPMCFG = Register(OTG_FS_GLPMCFG_val).init(base_address + 0x54);
};

/// USB on the go high speed
pub const OTG_HS_GLOBAL = struct {
    const base_address = 0x40040000;
    /// OTG_HS_GOTGCTL
    const OTG_HS_GOTGCTL_val = packed struct {
        /// SRQSCS [0:0]
        /// Session request success
        SRQSCS: u1 = 0,
        /// SRQ [1:1]
        /// Session request
        SRQ: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// HNGSCS [8:8]
        /// Host negotiation success
        HNGSCS: u1 = 0,
        /// HNPRQ [9:9]
        /// HNP request
        HNPRQ: u1 = 0,
        /// HSHNPEN [10:10]
        /// Host set HNP enable
        HSHNPEN: u1 = 0,
        /// DHNPEN [11:11]
        /// Device HNP enabled
        DHNPEN: u1 = 1,
        /// EHEN [12:12]
        /// Embedded host enable
        EHEN: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// CIDSTS [16:16]
        /// Connector ID status
        CIDSTS: u1 = 0,
        /// DBCT [17:17]
        /// Long/short debounce time
        DBCT: u1 = 0,
        /// ASVLD [18:18]
        /// A-session valid
        ASVLD: u1 = 0,
        /// BSVLD [19:19]
        /// B-session valid
        BSVLD: u1 = 0,
        /// unused [20:31]
        _unused20: u4 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS control and status
    pub const OTG_HS_GOTGCTL = Register(OTG_HS_GOTGCTL_val).init(base_address + 0x0);

    /// OTG_HS_GOTGINT
    const OTG_HS_GOTGINT_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// SEDET [2:2]
        /// Session end detected
        SEDET: u1 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// SRSSCHG [8:8]
        /// Session request success status
        SRSSCHG: u1 = 0,
        /// HNSSCHG [9:9]
        /// Host negotiation success status
        HNSSCHG: u1 = 0,
        /// unused [10:16]
        _unused10: u6 = 0,
        _unused16: u1 = 0,
        /// HNGDET [17:17]
        /// Host negotiation detected
        HNGDET: u1 = 0,
        /// ADTOCHG [18:18]
        /// A-device timeout change
        ADTOCHG: u1 = 0,
        /// DBCDNE [19:19]
        /// Debounce done
        DBCDNE: u1 = 0,
        /// IDCHNG [20:20]
        /// ID input pin changed
        IDCHNG: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS interrupt register
    pub const OTG_HS_GOTGINT = Register(OTG_HS_GOTGINT_val).init(base_address + 0x4);

    /// OTG_HS_GAHBCFG
    const OTG_HS_GAHBCFG_val = packed struct {
        /// GINT [0:0]
        /// Global interrupt mask
        GINT: u1 = 0,
        /// HBSTLEN [1:4]
        /// Burst length/type
        HBSTLEN: u4 = 0,
        /// DMAEN [5:5]
        /// DMA enable
        DMAEN: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXFELVL [7:7]
        /// TxFIFO empty level
        TXFELVL: u1 = 0,
        /// PTXFELVL [8:8]
        /// Periodic TxFIFO empty
        PTXFELVL: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS AHB configuration
    pub const OTG_HS_GAHBCFG = Register(OTG_HS_GAHBCFG_val).init(base_address + 0x8);

    /// OTG_HS_GUSBCFG
    const OTG_HS_GUSBCFG_val = packed struct {
        /// TOCAL [0:2]
        /// FS timeout calibration
        TOCAL: u3 = 0,
        /// unused [3:5]
        _unused3: u3 = 0,
        /// PHYSEL [6:6]
        /// USB 2.0 high-speed ULPI PHY or USB 1.1
        PHYSEL: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// SRPCAP [8:8]
        /// SRP-capable
        SRPCAP: u1 = 0,
        /// HNPCAP [9:9]
        /// HNP-capable
        HNPCAP: u1 = 1,
        /// TRDT [10:13]
        /// USB turnaround time
        TRDT: u4 = 2,
        /// unused [14:14]
        _unused14: u1 = 0,
        /// PHYLPCS [15:15]
        /// PHY Low-power clock select
        PHYLPCS: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// ULPIFSLS [17:17]
        /// ULPI FS/LS select
        ULPIFSLS: u1 = 0,
        /// ULPIAR [18:18]
        /// ULPI Auto-resume
        ULPIAR: u1 = 0,
        /// ULPICSM [19:19]
        /// ULPI Clock SuspendM
        ULPICSM: u1 = 0,
        /// ULPIEVBUSD [20:20]
        /// ULPI External VBUS Drive
        ULPIEVBUSD: u1 = 0,
        /// ULPIEVBUSI [21:21]
        /// ULPI external VBUS
        ULPIEVBUSI: u1 = 0,
        /// TSDPS [22:22]
        /// TermSel DLine pulsing
        TSDPS: u1 = 0,
        /// PCCI [23:23]
        /// Indicator complement
        PCCI: u1 = 0,
        /// PTCI [24:24]
        /// Indicator pass through
        PTCI: u1 = 0,
        /// ULPIIPD [25:25]
        /// ULPI interface protect
        ULPIIPD: u1 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// FHMOD [29:29]
        /// Forced host mode
        FHMOD: u1 = 0,
        /// FDMOD [30:30]
        /// Forced peripheral mode
        FDMOD: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS USB configuration
    pub const OTG_HS_GUSBCFG = Register(OTG_HS_GUSBCFG_val).init(base_address + 0xc);

    /// OTG_HS_GRSTCTL
    const OTG_HS_GRSTCTL_val = packed struct {
        /// CSRST [0:0]
        /// Core soft reset
        CSRST: u1 = 0,
        /// HSRST [1:1]
        /// HCLK soft reset
        HSRST: u1 = 0,
        /// FCRST [2:2]
        /// Host frame counter reset
        FCRST: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RXFFLSH [4:4]
        /// RxFIFO flush
        RXFFLSH: u1 = 0,
        /// TXFFLSH [5:5]
        /// TxFIFO flush
        TXFFLSH: u1 = 0,
        /// TXFNUM [6:10]
        /// TxFIFO number
        TXFNUM: u5 = 0,
        /// unused [11:29]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u6 = 32,
        /// DMAREQ [30:30]
        /// DMA request signal enabled for USB OTG
        DMAREQ: u1 = 0,
        /// AHBIDL [31:31]
        /// AHB master idle
        AHBIDL: u1 = 0,
    };
    /// OTG_HS reset register
    pub const OTG_HS_GRSTCTL = Register(OTG_HS_GRSTCTL_val).init(base_address + 0x10);

    /// OTG_HS_GINTSTS
    const OTG_HS_GINTSTS_val = packed struct {
        /// CMOD [0:0]
        /// Current mode of operation
        CMOD: u1 = 0,
        /// MMIS [1:1]
        /// Mode mismatch interrupt
        MMIS: u1 = 0,
        /// OTGINT [2:2]
        /// OTG interrupt
        OTGINT: u1 = 0,
        /// SOF [3:3]
        /// Start of frame
        SOF: u1 = 0,
        /// RXFLVL [4:4]
        /// RxFIFO nonempty
        RXFLVL: u1 = 0,
        /// NPTXFE [5:5]
        /// Nonperiodic TxFIFO empty
        NPTXFE: u1 = 1,
        /// GINAKEFF [6:6]
        /// Global IN nonperiodic NAK
        GINAKEFF: u1 = 0,
        /// BOUTNAKEFF [7:7]
        /// Global OUT NAK effective
        BOUTNAKEFF: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// ESUSP [10:10]
        /// Early suspend
        ESUSP: u1 = 0,
        /// USBSUSP [11:11]
        /// USB suspend
        USBSUSP: u1 = 0,
        /// USBRST [12:12]
        /// USB reset
        USBRST: u1 = 0,
        /// ENUMDNE [13:13]
        /// Enumeration done
        ENUMDNE: u1 = 0,
        /// ISOODRP [14:14]
        /// Isochronous OUT packet dropped
        ISOODRP: u1 = 0,
        /// EOPF [15:15]
        /// End of periodic frame
        EOPF: u1 = 0,
        /// unused [16:17]
        _unused16: u2 = 0,
        /// IEPINT [18:18]
        /// IN endpoint interrupt
        IEPINT: u1 = 0,
        /// OEPINT [19:19]
        /// OUT endpoint interrupt
        OEPINT: u1 = 0,
        /// IISOIXFR [20:20]
        /// Incomplete isochronous IN
        IISOIXFR: u1 = 0,
        /// PXFR_INCOMPISOOUT [21:21]
        /// Incomplete periodic
        PXFR_INCOMPISOOUT: u1 = 0,
        /// DATAFSUSP [22:22]
        /// Data fetch suspended
        DATAFSUSP: u1 = 0,
        /// unused [23:23]
        _unused23: u1 = 0,
        /// HPRTINT [24:24]
        /// Host port interrupt
        HPRTINT: u1 = 0,
        /// HCINT [25:25]
        /// Host channels interrupt
        HCINT: u1 = 0,
        /// PTXFE [26:26]
        /// Periodic TxFIFO empty
        PTXFE: u1 = 1,
        /// unused [27:27]
        _unused27: u1 = 0,
        /// CIDSCHG [28:28]
        /// Connector ID status change
        CIDSCHG: u1 = 0,
        /// DISCINT [29:29]
        /// Disconnect detected
        DISCINT: u1 = 0,
        /// SRQINT [30:30]
        /// Session request/new session detected
        SRQINT: u1 = 0,
        /// WKUINT [31:31]
        /// Resume/remote wakeup detected
        WKUINT: u1 = 0,
    };
    /// OTG_HS core interrupt register
    pub const OTG_HS_GINTSTS = Register(OTG_HS_GINTSTS_val).init(base_address + 0x14);

    /// OTG_HS_GINTMSK
    const OTG_HS_GINTMSK_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// MMISM [1:1]
        /// Mode mismatch interrupt
        MMISM: u1 = 0,
        /// OTGINT [2:2]
        /// OTG interrupt mask
        OTGINT: u1 = 0,
        /// SOFM [3:3]
        /// Start of frame mask
        SOFM: u1 = 0,
        /// RXFLVLM [4:4]
        /// Receive FIFO nonempty mask
        RXFLVLM: u1 = 0,
        /// NPTXFEM [5:5]
        /// Nonperiodic TxFIFO empty
        NPTXFEM: u1 = 0,
        /// GINAKEFFM [6:6]
        /// Global nonperiodic IN NAK effective
        GINAKEFFM: u1 = 0,
        /// GONAKEFFM [7:7]
        /// Global OUT NAK effective
        GONAKEFFM: u1 = 0,
        /// unused [8:9]
        _unused8: u2 = 0,
        /// ESUSPM [10:10]
        /// Early suspend mask
        ESUSPM: u1 = 0,
        /// USBSUSPM [11:11]
        /// USB suspend mask
        USBSUSPM: u1 = 0,
        /// USBRST [12:12]
        /// USB reset mask
        USBRST: u1 = 0,
        /// ENUMDNEM [13:13]
        /// Enumeration done mask
        ENUMDNEM: u1 = 0,
        /// ISOODRPM [14:14]
        /// Isochronous OUT packet dropped interrupt
        ISOODRPM: u1 = 0,
        /// EOPFM [15:15]
        /// End of periodic frame interrupt
        EOPFM: u1 = 0,
        /// unused [16:17]
        _unused16: u2 = 0,
        /// IEPINT [18:18]
        /// IN endpoints interrupt
        IEPINT: u1 = 0,
        /// OEPINT [19:19]
        /// OUT endpoints interrupt
        OEPINT: u1 = 0,
        /// IISOIXFRM [20:20]
        /// Incomplete isochronous IN transfer
        IISOIXFRM: u1 = 0,
        /// PXFRM_IISOOXFRM [21:21]
        /// Incomplete periodic transfer
        PXFRM_IISOOXFRM: u1 = 0,
        /// FSUSPM [22:22]
        /// Data fetch suspended mask
        FSUSPM: u1 = 0,
        /// RSTDE [23:23]
        /// Reset detected interrupt
        RSTDE: u1 = 0,
        /// PRTIM [24:24]
        /// Host port interrupt mask
        PRTIM: u1 = 0,
        /// HCIM [25:25]
        /// Host channels interrupt
        HCIM: u1 = 0,
        /// PTXFEM [26:26]
        /// Periodic TxFIFO empty mask
        PTXFEM: u1 = 0,
        /// LPMINTM [27:27]
        /// LPM interrupt mask
        LPMINTM: u1 = 0,
        /// CIDSCHGM [28:28]
        /// Connector ID status change
        CIDSCHGM: u1 = 0,
        /// DISCINT [29:29]
        /// Disconnect detected interrupt
        DISCINT: u1 = 0,
        /// SRQIM [30:30]
        /// Session request/new session detected
        SRQIM: u1 = 0,
        /// WUIM [31:31]
        /// Resume/remote wakeup detected interrupt
        WUIM: u1 = 0,
    };
    /// OTG_HS interrupt mask register
    pub const OTG_HS_GINTMSK = Register(OTG_HS_GINTMSK_val).init(base_address + 0x18);

    /// OTG_HS_GRXSTSR_Host
    const OTG_HS_GRXSTSR_Host_val = packed struct {
        /// CHNUM [0:3]
        /// Channel number
        CHNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS Receive status debug read register
    pub const OTG_HS_GRXSTSR_Host = Register(OTG_HS_GRXSTSR_Host_val).init(base_address + 0x1c);

    /// OTG_HS_GRXSTSP_Host
    const OTG_HS_GRXSTSP_Host_val = packed struct {
        /// CHNUM [0:3]
        /// Channel number
        CHNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS status read and pop register (host
    pub const OTG_HS_GRXSTSP_Host = Register(OTG_HS_GRXSTSP_Host_val).init(base_address + 0x20);

    /// OTG_HS_GRXFSIZ
    const OTG_HS_GRXFSIZ_val = packed struct {
        /// RXFD [0:15]
        /// RxFIFO depth
        RXFD: u16 = 512,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS Receive FIFO size
    pub const OTG_HS_GRXFSIZ = Register(OTG_HS_GRXFSIZ_val).init(base_address + 0x24);

    /// OTG_HS_HNPTXFSIZ_Host
    const OTG_HS_HNPTXFSIZ_Host_val = packed struct {
        /// NPTXFSA [0:15]
        /// Nonperiodic transmit RAM start
        NPTXFSA: u16 = 512,
        /// NPTXFD [16:31]
        /// Nonperiodic TxFIFO depth
        NPTXFD: u16 = 0,
    };
    /// OTG_HS nonperiodic transmit FIFO size
    pub const OTG_HS_HNPTXFSIZ_Host = Register(OTG_HS_HNPTXFSIZ_Host_val).init(base_address + 0x28);

    /// OTG_HS_DIEPTXF0_Device
    const OTG_HS_DIEPTXF0_Device_val = packed struct {
        /// TX0FSA [0:15]
        /// Endpoint 0 transmit RAM start
        TX0FSA: u16 = 512,
        /// TX0FD [16:31]
        /// Endpoint 0 TxFIFO depth
        TX0FD: u16 = 0,
    };
    /// Endpoint 0 transmit FIFO size (peripheral
    pub const OTG_HS_DIEPTXF0_Device = Register(OTG_HS_DIEPTXF0_Device_val).init(base_address + 0x28);

    /// OTG_HS_GNPTXSTS
    const OTG_HS_GNPTXSTS_val = packed struct {
        /// NPTXFSAV [0:15]
        /// Nonperiodic TxFIFO space
        NPTXFSAV: u16 = 512,
        /// NPTQXSAV [16:23]
        /// Nonperiodic transmit request queue space
        NPTQXSAV: u8 = 8,
        /// NPTXQTOP [24:30]
        /// Top of the nonperiodic transmit request
        NPTXQTOP: u7 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS nonperiodic transmit FIFO/queue
    pub const OTG_HS_GNPTXSTS = Register(OTG_HS_GNPTXSTS_val).init(base_address + 0x2c);

    /// OTG_HS_GCCFG
    const OTG_HS_GCCFG_val = packed struct {
        /// DCDET [0:0]
        /// Data contact detection (DCD)
        DCDET: u1 = 0,
        /// PDET [1:1]
        /// Primary detection (PD)
        PDET: u1 = 0,
        /// SDET [2:2]
        /// Secondary detection (SD)
        SDET: u1 = 0,
        /// PS2DET [3:3]
        /// DM pull-up detection
        PS2DET: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// PWRDWN [16:16]
        /// Power down
        PWRDWN: u1 = 0,
        /// BCDEN [17:17]
        /// Battery charging detector (BCD)
        BCDEN: u1 = 0,
        /// DCDEN [18:18]
        /// Data contact detection (DCD) mode
        DCDEN: u1 = 0,
        /// PDEN [19:19]
        /// Primary detection (PD) mode
        PDEN: u1 = 0,
        /// SDEN [20:20]
        /// Secondary detection (SD) mode
        SDEN: u1 = 0,
        /// VBDEN [21:21]
        /// USB VBUS detection enable
        VBDEN: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS general core configuration
    pub const OTG_HS_GCCFG = Register(OTG_HS_GCCFG_val).init(base_address + 0x38);

    /// OTG_HS_CID
    const OTG_HS_CID_val = packed struct {
        /// PRODUCT_ID [0:31]
        /// Product ID field
        PRODUCT_ID: u32 = 4608,
    };
    /// OTG_HS core ID register
    pub const OTG_HS_CID = Register(OTG_HS_CID_val).init(base_address + 0x3c);

    /// OTG_HS_HPTXFSIZ
    const OTG_HS_HPTXFSIZ_val = packed struct {
        /// PTXSA [0:15]
        /// Host periodic TxFIFO start
        PTXSA: u16 = 1536,
        /// PTXFD [16:31]
        /// Host periodic TxFIFO depth
        PTXFD: u16 = 512,
    };
    /// OTG_HS Host periodic transmit FIFO size
    pub const OTG_HS_HPTXFSIZ = Register(OTG_HS_HPTXFSIZ_val).init(base_address + 0x100);

    /// OTG_HS_DIEPTXF1
    const OTG_HS_DIEPTXF1_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 1024,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF1 = Register(OTG_HS_DIEPTXF1_val).init(base_address + 0x104);

    /// OTG_HS_DIEPTXF2
    const OTG_HS_DIEPTXF2_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 1536,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF2 = Register(OTG_HS_DIEPTXF2_val).init(base_address + 0x108);

    /// OTG_HS_DIEPTXF3
    const OTG_HS_DIEPTXF3_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 2048,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF3 = Register(OTG_HS_DIEPTXF3_val).init(base_address + 0x10c);

    /// OTG_HS_DIEPTXF4
    const OTG_HS_DIEPTXF4_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 2560,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF4 = Register(OTG_HS_DIEPTXF4_val).init(base_address + 0x110);

    /// OTG_HS_DIEPTXF5
    const OTG_HS_DIEPTXF5_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 3072,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF5 = Register(OTG_HS_DIEPTXF5_val).init(base_address + 0x114);

    /// OTG_HS_DIEPTXF6
    const OTG_HS_DIEPTXF6_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 3584,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF6 = Register(OTG_HS_DIEPTXF6_val).init(base_address + 0x118);

    /// OTG_HS_DIEPTXF7
    const OTG_HS_DIEPTXF7_val = packed struct {
        /// INEPTXSA [0:15]
        /// IN endpoint FIFOx transmit RAM start
        INEPTXSA: u16 = 4096,
        /// INEPTXFD [16:31]
        /// IN endpoint TxFIFO depth
        INEPTXFD: u16 = 512,
    };
    /// OTG_HS device IN endpoint transmit FIFO size
    pub const OTG_HS_DIEPTXF7 = Register(OTG_HS_DIEPTXF7_val).init(base_address + 0x11c);

    /// OTG_HS_GRXSTSR_Device
    const OTG_HS_GRXSTSR_Device_val = packed struct {
        /// EPNUM [0:3]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// FRMNUM [21:24]
        /// Frame number
        FRMNUM: u4 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// OTG_HS Receive status debug read register
    pub const OTG_HS_GRXSTSR_Device = Register(OTG_HS_GRXSTSR_Device_val).init(base_address + 0x1c);

    /// OTG_HS_GRXSTSP_Device
    const OTG_HS_GRXSTSP_Device_val = packed struct {
        /// EPNUM [0:3]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// BCNT [4:14]
        /// Byte count
        BCNT: u11 = 0,
        /// DPID [15:16]
        /// Data PID
        DPID: u2 = 0,
        /// PKTSTS [17:20]
        /// Packet status
        PKTSTS: u4 = 0,
        /// FRMNUM [21:24]
        /// Frame number
        FRMNUM: u4 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// OTG_HS status read and pop register
    pub const OTG_HS_GRXSTSP_Device = Register(OTG_HS_GRXSTSP_Device_val).init(base_address + 0x20);

    /// OTG_HS_GLPMCFG
    const OTG_HS_GLPMCFG_val = packed struct {
        /// LPMEN [0:0]
        /// LPM support enable
        LPMEN: u1 = 0,
        /// LPMACK [1:1]
        /// LPM token acknowledge
        LPMACK: u1 = 0,
        /// BESL [2:5]
        /// Best effort service
        BESL: u4 = 0,
        /// REMWAKE [6:6]
        /// bRemoteWake value
        REMWAKE: u1 = 0,
        /// L1SSEN [7:7]
        /// L1 Shallow Sleep enable
        L1SSEN: u1 = 0,
        /// BESLTHRS [8:11]
        /// BESL threshold
        BESLTHRS: u4 = 0,
        /// L1DSEN [12:12]
        /// L1 deep sleep enable
        L1DSEN: u1 = 0,
        /// LPMRST [13:14]
        /// LPM response
        LPMRST: u2 = 0,
        /// SLPSTS [15:15]
        /// Port sleep status
        SLPSTS: u1 = 0,
        /// L1RSMOK [16:16]
        /// Sleep State Resume OK
        L1RSMOK: u1 = 0,
        /// LPMCHIDX [17:20]
        /// LPM Channel Index
        LPMCHIDX: u4 = 0,
        /// LPMRCNT [21:23]
        /// LPM retry count
        LPMRCNT: u3 = 0,
        /// SNDLPM [24:24]
        /// Send LPM transaction
        SNDLPM: u1 = 0,
        /// LPMRCNTSTS [25:27]
        /// LPM retry count status
        LPMRCNTSTS: u3 = 0,
        /// ENBESL [28:28]
        /// Enable best effort service
        ENBESL: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// OTG core LPM configuration
    pub const OTG_HS_GLPMCFG = Register(OTG_HS_GLPMCFG_val).init(base_address + 0x54);
};

/// Management data input/output slave
pub const MDIOS = struct {
    const base_address = 0x40017800;
    /// MDIOS_CR
    const MDIOS_CR_val = packed struct {
        /// EN [0:0]
        /// Peripheral enable
        EN: u1 = 0,
        /// WRIE [1:1]
        /// Register write interrupt
        WRIE: u1 = 0,
        /// RDIE [2:2]
        /// Register Read Interrupt
        RDIE: u1 = 0,
        /// EIE [3:3]
        /// Error interrupt enable
        EIE: u1 = 0,
        /// unused [4:6]
        _unused4: u3 = 0,
        /// DPC [7:7]
        /// Disable Preamble Check
        DPC: u1 = 0,
        /// PORT_ADDRESS [8:12]
        /// Slaves's address
        PORT_ADDRESS: u5 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS configuration register
    pub const MDIOS_CR = Register(MDIOS_CR_val).init(base_address + 0x0);

    /// MDIOS_WRFR
    const MDIOS_WRFR_val = packed struct {
        /// WRF [0:31]
        /// Write flags for MDIO registers 0 to
        WRF: u32 = 0,
    };
    /// MDIOS write flag register
    pub const MDIOS_WRFR = Register(MDIOS_WRFR_val).init(base_address + 0x4);

    /// MDIOS_CWRFR
    const MDIOS_CWRFR_val = packed struct {
        /// CWRF [0:31]
        /// Clear the write flag
        CWRF: u32 = 0,
    };
    /// MDIOS clear write flag
    pub const MDIOS_CWRFR = Register(MDIOS_CWRFR_val).init(base_address + 0x8);

    /// MDIOS_RDFR
    const MDIOS_RDFR_val = packed struct {
        /// RDF [0:31]
        /// Read flags for MDIO registers 0 to
        RDF: u32 = 0,
    };
    /// MDIOS read flag register
    pub const MDIOS_RDFR = Register(MDIOS_RDFR_val).init(base_address + 0xc);

    /// MDIOS_CRDFR
    const MDIOS_CRDFR_val = packed struct {
        /// CRDF [0:31]
        /// Clear the read flag
        CRDF: u32 = 0,
    };
    /// MDIOS clear read flag register
    pub const MDIOS_CRDFR = Register(MDIOS_CRDFR_val).init(base_address + 0x10);

    /// MDIOS_SR
    const MDIOS_SR_val = packed struct {
        /// PERF [0:0]
        /// Preamble error flag
        PERF: u1 = 0,
        /// SERF [1:1]
        /// Start error flag
        SERF: u1 = 0,
        /// TERF [2:2]
        /// Turnaround error flag
        TERF: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS status register
    pub const MDIOS_SR = Register(MDIOS_SR_val).init(base_address + 0x14);

    /// MDIOS_CLRFR
    const MDIOS_CLRFR_val = packed struct {
        /// CPERF [0:0]
        /// Clear the preamble error
        CPERF: u1 = 0,
        /// CSERF [1:1]
        /// Clear the start error flag
        CSERF: u1 = 0,
        /// CTERF [2:2]
        /// Clear the turnaround error
        CTERF: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS clear flag register
    pub const MDIOS_CLRFR = Register(MDIOS_CLRFR_val).init(base_address + 0x18);

    /// MDIOS_DINR0
    const MDIOS_DINR0_val = packed struct {
        /// DIN0 [0:15]
        /// Input data received from MDIO Master
        DIN0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 0
    pub const MDIOS_DINR0 = Register(MDIOS_DINR0_val).init(base_address + 0x1c);

    /// MDIOS_DINR1
    const MDIOS_DINR1_val = packed struct {
        /// DIN1 [0:15]
        /// Input data received from MDIO Master
        DIN1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 1
    pub const MDIOS_DINR1 = Register(MDIOS_DINR1_val).init(base_address + 0x20);

    /// MDIOS_DINR2
    const MDIOS_DINR2_val = packed struct {
        /// DIN2 [0:15]
        /// Input data received from MDIO Master
        DIN2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 2
    pub const MDIOS_DINR2 = Register(MDIOS_DINR2_val).init(base_address + 0x24);

    /// MDIOS_DINR3
    const MDIOS_DINR3_val = packed struct {
        /// DIN3 [0:15]
        /// Input data received from MDIO Master
        DIN3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 3
    pub const MDIOS_DINR3 = Register(MDIOS_DINR3_val).init(base_address + 0x28);

    /// MDIOS_DINR4
    const MDIOS_DINR4_val = packed struct {
        /// DIN4 [0:15]
        /// Input data received from MDIO Master
        DIN4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 4
    pub const MDIOS_DINR4 = Register(MDIOS_DINR4_val).init(base_address + 0x2c);

    /// MDIOS_DINR5
    const MDIOS_DINR5_val = packed struct {
        /// DIN5 [0:15]
        /// Input data received from MDIO Master
        DIN5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 5
    pub const MDIOS_DINR5 = Register(MDIOS_DINR5_val).init(base_address + 0x30);

    /// MDIOS_DINR6
    const MDIOS_DINR6_val = packed struct {
        /// DIN6 [0:15]
        /// Input data received from MDIO Master
        DIN6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 6
    pub const MDIOS_DINR6 = Register(MDIOS_DINR6_val).init(base_address + 0x34);

    /// MDIOS_DINR7
    const MDIOS_DINR7_val = packed struct {
        /// DIN7 [0:15]
        /// Input data received from MDIO Master
        DIN7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 7
    pub const MDIOS_DINR7 = Register(MDIOS_DINR7_val).init(base_address + 0x38);

    /// MDIOS_DINR8
    const MDIOS_DINR8_val = packed struct {
        /// DIN8 [0:15]
        /// Input data received from MDIO Master
        DIN8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 8
    pub const MDIOS_DINR8 = Register(MDIOS_DINR8_val).init(base_address + 0x3c);

    /// MDIOS_DINR9
    const MDIOS_DINR9_val = packed struct {
        /// DIN9 [0:15]
        /// Input data received from MDIO Master
        DIN9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 9
    pub const MDIOS_DINR9 = Register(MDIOS_DINR9_val).init(base_address + 0x40);

    /// MDIOS_DINR10
    const MDIOS_DINR10_val = packed struct {
        /// DIN10 [0:15]
        /// Input data received from MDIO Master
        DIN10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 10
    pub const MDIOS_DINR10 = Register(MDIOS_DINR10_val).init(base_address + 0x44);

    /// MDIOS_DINR11
    const MDIOS_DINR11_val = packed struct {
        /// DIN11 [0:15]
        /// Input data received from MDIO Master
        DIN11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 11
    pub const MDIOS_DINR11 = Register(MDIOS_DINR11_val).init(base_address + 0x48);

    /// MDIOS_DINR12
    const MDIOS_DINR12_val = packed struct {
        /// DIN12 [0:15]
        /// Input data received from MDIO Master
        DIN12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 12
    pub const MDIOS_DINR12 = Register(MDIOS_DINR12_val).init(base_address + 0x4c);

    /// MDIOS_DINR13
    const MDIOS_DINR13_val = packed struct {
        /// DIN13 [0:15]
        /// Input data received from MDIO Master
        DIN13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 13
    pub const MDIOS_DINR13 = Register(MDIOS_DINR13_val).init(base_address + 0x50);

    /// MDIOS_DINR14
    const MDIOS_DINR14_val = packed struct {
        /// DIN14 [0:15]
        /// Input data received from MDIO Master
        DIN14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 14
    pub const MDIOS_DINR14 = Register(MDIOS_DINR14_val).init(base_address + 0x54);

    /// MDIOS_DINR15
    const MDIOS_DINR15_val = packed struct {
        /// DIN15 [0:15]
        /// Input data received from MDIO Master
        DIN15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 15
    pub const MDIOS_DINR15 = Register(MDIOS_DINR15_val).init(base_address + 0x58);

    /// MDIOS_DINR16
    const MDIOS_DINR16_val = packed struct {
        /// DIN16 [0:15]
        /// Input data received from MDIO Master
        DIN16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 16
    pub const MDIOS_DINR16 = Register(MDIOS_DINR16_val).init(base_address + 0x5c);

    /// MDIOS_DINR17
    const MDIOS_DINR17_val = packed struct {
        /// DIN17 [0:15]
        /// Input data received from MDIO Master
        DIN17: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 17
    pub const MDIOS_DINR17 = Register(MDIOS_DINR17_val).init(base_address + 0x60);

    /// MDIOS_DINR18
    const MDIOS_DINR18_val = packed struct {
        /// DIN18 [0:15]
        /// Input data received from MDIO Master
        DIN18: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 18
    pub const MDIOS_DINR18 = Register(MDIOS_DINR18_val).init(base_address + 0x64);

    /// MDIOS_DINR19
    const MDIOS_DINR19_val = packed struct {
        /// DIN19 [0:15]
        /// Input data received from MDIO Master
        DIN19: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 19
    pub const MDIOS_DINR19 = Register(MDIOS_DINR19_val).init(base_address + 0x68);

    /// MDIOS_DINR20
    const MDIOS_DINR20_val = packed struct {
        /// DIN20 [0:15]
        /// Input data received from MDIO Master
        DIN20: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 20
    pub const MDIOS_DINR20 = Register(MDIOS_DINR20_val).init(base_address + 0x6c);

    /// MDIOS_DINR21
    const MDIOS_DINR21_val = packed struct {
        /// DIN21 [0:15]
        /// Input data received from MDIO Master
        DIN21: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 21
    pub const MDIOS_DINR21 = Register(MDIOS_DINR21_val).init(base_address + 0x70);

    /// MDIOS_DINR22
    const MDIOS_DINR22_val = packed struct {
        /// DIN22 [0:15]
        /// Input data received from MDIO Master
        DIN22: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 22
    pub const MDIOS_DINR22 = Register(MDIOS_DINR22_val).init(base_address + 0x74);

    /// MDIOS_DINR23
    const MDIOS_DINR23_val = packed struct {
        /// DIN23 [0:15]
        /// Input data received from MDIO Master
        DIN23: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 23
    pub const MDIOS_DINR23 = Register(MDIOS_DINR23_val).init(base_address + 0x78);

    /// MDIOS_DINR24
    const MDIOS_DINR24_val = packed struct {
        /// DIN24 [0:15]
        /// Input data received from MDIO Master
        DIN24: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 24
    pub const MDIOS_DINR24 = Register(MDIOS_DINR24_val).init(base_address + 0x7c);

    /// MDIOS_DINR25
    const MDIOS_DINR25_val = packed struct {
        /// DIN25 [0:15]
        /// Input data received from MDIO Master
        DIN25: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 25
    pub const MDIOS_DINR25 = Register(MDIOS_DINR25_val).init(base_address + 0x80);

    /// MDIOS_DINR26
    const MDIOS_DINR26_val = packed struct {
        /// DIN26 [0:15]
        /// Input data received from MDIO Master
        DIN26: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 26
    pub const MDIOS_DINR26 = Register(MDIOS_DINR26_val).init(base_address + 0x84);

    /// MDIOS_DINR27
    const MDIOS_DINR27_val = packed struct {
        /// DIN27 [0:15]
        /// Input data received from MDIO Master
        DIN27: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 27
    pub const MDIOS_DINR27 = Register(MDIOS_DINR27_val).init(base_address + 0x88);

    /// MDIOS_DINR28
    const MDIOS_DINR28_val = packed struct {
        /// DIN28 [0:15]
        /// Input data received from MDIO Master
        DIN28: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 28
    pub const MDIOS_DINR28 = Register(MDIOS_DINR28_val).init(base_address + 0x8c);

    /// MDIOS_DINR29
    const MDIOS_DINR29_val = packed struct {
        /// DIN29 [0:15]
        /// Input data received from MDIO Master
        DIN29: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 29
    pub const MDIOS_DINR29 = Register(MDIOS_DINR29_val).init(base_address + 0x90);

    /// MDIOS_DINR30
    const MDIOS_DINR30_val = packed struct {
        /// DIN30 [0:15]
        /// Input data received from MDIO Master
        DIN30: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 30
    pub const MDIOS_DINR30 = Register(MDIOS_DINR30_val).init(base_address + 0x94);

    /// MDIOS_DINR31
    const MDIOS_DINR31_val = packed struct {
        /// DIN31 [0:15]
        /// Input data received from MDIO Master
        DIN31: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS input data register 31
    pub const MDIOS_DINR31 = Register(MDIOS_DINR31_val).init(base_address + 0x98);

    /// MDIOS_DOUTR0
    const MDIOS_DOUTR0_val = packed struct {
        /// DOUT0 [0:15]
        /// Output data sent to MDIO Master during
        DOUT0: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 0
    pub const MDIOS_DOUTR0 = Register(MDIOS_DOUTR0_val).init(base_address + 0x9c);

    /// MDIOS_DOUTR1
    const MDIOS_DOUTR1_val = packed struct {
        /// DOUT1 [0:15]
        /// Output data sent to MDIO Master during
        DOUT1: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 1
    pub const MDIOS_DOUTR1 = Register(MDIOS_DOUTR1_val).init(base_address + 0xa0);

    /// MDIOS_DOUTR2
    const MDIOS_DOUTR2_val = packed struct {
        /// DOUT2 [0:15]
        /// Output data sent to MDIO Master during
        DOUT2: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 2
    pub const MDIOS_DOUTR2 = Register(MDIOS_DOUTR2_val).init(base_address + 0xa4);

    /// MDIOS_DOUTR3
    const MDIOS_DOUTR3_val = packed struct {
        /// DOUT3 [0:15]
        /// Output data sent to MDIO Master during
        DOUT3: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 3
    pub const MDIOS_DOUTR3 = Register(MDIOS_DOUTR3_val).init(base_address + 0xa8);

    /// MDIOS_DOUTR4
    const MDIOS_DOUTR4_val = packed struct {
        /// DOUT4 [0:15]
        /// Output data sent to MDIO Master during
        DOUT4: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 4
    pub const MDIOS_DOUTR4 = Register(MDIOS_DOUTR4_val).init(base_address + 0xac);

    /// MDIOS_DOUTR5
    const MDIOS_DOUTR5_val = packed struct {
        /// DOUT5 [0:15]
        /// Output data sent to MDIO Master during
        DOUT5: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 5
    pub const MDIOS_DOUTR5 = Register(MDIOS_DOUTR5_val).init(base_address + 0xb0);

    /// MDIOS_DOUTR6
    const MDIOS_DOUTR6_val = packed struct {
        /// DOUT6 [0:15]
        /// Output data sent to MDIO Master during
        DOUT6: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 6
    pub const MDIOS_DOUTR6 = Register(MDIOS_DOUTR6_val).init(base_address + 0xb4);

    /// MDIOS_DOUTR7
    const MDIOS_DOUTR7_val = packed struct {
        /// DOUT7 [0:15]
        /// Output data sent to MDIO Master during
        DOUT7: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 7
    pub const MDIOS_DOUTR7 = Register(MDIOS_DOUTR7_val).init(base_address + 0xb8);

    /// MDIOS_DOUTR8
    const MDIOS_DOUTR8_val = packed struct {
        /// DOUT8 [0:15]
        /// Output data sent to MDIO Master during
        DOUT8: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 8
    pub const MDIOS_DOUTR8 = Register(MDIOS_DOUTR8_val).init(base_address + 0xbc);

    /// MDIOS_DOUTR9
    const MDIOS_DOUTR9_val = packed struct {
        /// DOUT9 [0:15]
        /// Output data sent to MDIO Master during
        DOUT9: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 9
    pub const MDIOS_DOUTR9 = Register(MDIOS_DOUTR9_val).init(base_address + 0xc0);

    /// MDIOS_DOUTR10
    const MDIOS_DOUTR10_val = packed struct {
        /// DOUT10 [0:15]
        /// Output data sent to MDIO Master during
        DOUT10: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 10
    pub const MDIOS_DOUTR10 = Register(MDIOS_DOUTR10_val).init(base_address + 0xc4);

    /// MDIOS_DOUTR11
    const MDIOS_DOUTR11_val = packed struct {
        /// DOUT11 [0:15]
        /// Output data sent to MDIO Master during
        DOUT11: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 11
    pub const MDIOS_DOUTR11 = Register(MDIOS_DOUTR11_val).init(base_address + 0xc8);

    /// MDIOS_DOUTR12
    const MDIOS_DOUTR12_val = packed struct {
        /// DOUT12 [0:15]
        /// Output data sent to MDIO Master during
        DOUT12: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 12
    pub const MDIOS_DOUTR12 = Register(MDIOS_DOUTR12_val).init(base_address + 0xcc);

    /// MDIOS_DOUTR13
    const MDIOS_DOUTR13_val = packed struct {
        /// DOUT13 [0:15]
        /// Output data sent to MDIO Master during
        DOUT13: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 13
    pub const MDIOS_DOUTR13 = Register(MDIOS_DOUTR13_val).init(base_address + 0xd0);

    /// MDIOS_DOUTR14
    const MDIOS_DOUTR14_val = packed struct {
        /// DOUT14 [0:15]
        /// Output data sent to MDIO Master during
        DOUT14: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 14
    pub const MDIOS_DOUTR14 = Register(MDIOS_DOUTR14_val).init(base_address + 0xd4);

    /// MDIOS_DOUTR15
    const MDIOS_DOUTR15_val = packed struct {
        /// DOUT15 [0:15]
        /// Output data sent to MDIO Master during
        DOUT15: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 15
    pub const MDIOS_DOUTR15 = Register(MDIOS_DOUTR15_val).init(base_address + 0xd8);

    /// MDIOS_DOUTR16
    const MDIOS_DOUTR16_val = packed struct {
        /// DOUT16 [0:15]
        /// Output data sent to MDIO Master during
        DOUT16: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 16
    pub const MDIOS_DOUTR16 = Register(MDIOS_DOUTR16_val).init(base_address + 0xdc);

    /// MDIOS_DOUTR17
    const MDIOS_DOUTR17_val = packed struct {
        /// DOUT17 [0:15]
        /// Output data sent to MDIO Master during
        DOUT17: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 17
    pub const MDIOS_DOUTR17 = Register(MDIOS_DOUTR17_val).init(base_address + 0xe0);

    /// MDIOS_DOUTR18
    const MDIOS_DOUTR18_val = packed struct {
        /// DOUT18 [0:15]
        /// Output data sent to MDIO Master during
        DOUT18: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 18
    pub const MDIOS_DOUTR18 = Register(MDIOS_DOUTR18_val).init(base_address + 0xe4);

    /// MDIOS_DOUTR19
    const MDIOS_DOUTR19_val = packed struct {
        /// DOUT19 [0:15]
        /// Output data sent to MDIO Master during
        DOUT19: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 19
    pub const MDIOS_DOUTR19 = Register(MDIOS_DOUTR19_val).init(base_address + 0xe8);

    /// MDIOS_DOUTR20
    const MDIOS_DOUTR20_val = packed struct {
        /// DOUT20 [0:15]
        /// Output data sent to MDIO Master during
        DOUT20: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 20
    pub const MDIOS_DOUTR20 = Register(MDIOS_DOUTR20_val).init(base_address + 0xec);

    /// MDIOS_DOUTR21
    const MDIOS_DOUTR21_val = packed struct {
        /// DOUT21 [0:15]
        /// Output data sent to MDIO Master during
        DOUT21: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 21
    pub const MDIOS_DOUTR21 = Register(MDIOS_DOUTR21_val).init(base_address + 0xf0);

    /// MDIOS_DOUTR22
    const MDIOS_DOUTR22_val = packed struct {
        /// DOUT22 [0:15]
        /// Output data sent to MDIO Master during
        DOUT22: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 22
    pub const MDIOS_DOUTR22 = Register(MDIOS_DOUTR22_val).init(base_address + 0xf4);

    /// MDIOS_DOUTR23
    const MDIOS_DOUTR23_val = packed struct {
        /// DOUT23 [0:15]
        /// Output data sent to MDIO Master during
        DOUT23: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 23
    pub const MDIOS_DOUTR23 = Register(MDIOS_DOUTR23_val).init(base_address + 0xf8);

    /// MDIOS_DOUTR24
    const MDIOS_DOUTR24_val = packed struct {
        /// DOUT24 [0:15]
        /// Output data sent to MDIO Master during
        DOUT24: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 24
    pub const MDIOS_DOUTR24 = Register(MDIOS_DOUTR24_val).init(base_address + 0xfc);

    /// MDIOS_DOUTR25
    const MDIOS_DOUTR25_val = packed struct {
        /// DOUT25 [0:15]
        /// Output data sent to MDIO Master during
        DOUT25: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 25
    pub const MDIOS_DOUTR25 = Register(MDIOS_DOUTR25_val).init(base_address + 0x100);

    /// MDIOS_DOUTR26
    const MDIOS_DOUTR26_val = packed struct {
        /// DOUT26 [0:15]
        /// Output data sent to MDIO Master during
        DOUT26: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 26
    pub const MDIOS_DOUTR26 = Register(MDIOS_DOUTR26_val).init(base_address + 0x104);

    /// MDIOS_DOUTR27
    const MDIOS_DOUTR27_val = packed struct {
        /// DOUT27 [0:15]
        /// Output data sent to MDIO Master during
        DOUT27: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 27
    pub const MDIOS_DOUTR27 = Register(MDIOS_DOUTR27_val).init(base_address + 0x108);

    /// MDIOS_DOUTR28
    const MDIOS_DOUTR28_val = packed struct {
        /// DOUT28 [0:15]
        /// Output data sent to MDIO Master during
        DOUT28: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 28
    pub const MDIOS_DOUTR28 = Register(MDIOS_DOUTR28_val).init(base_address + 0x10c);

    /// MDIOS_DOUTR29
    const MDIOS_DOUTR29_val = packed struct {
        /// DOUT29 [0:15]
        /// Output data sent to MDIO Master during
        DOUT29: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 29
    pub const MDIOS_DOUTR29 = Register(MDIOS_DOUTR29_val).init(base_address + 0x110);

    /// MDIOS_DOUTR30
    const MDIOS_DOUTR30_val = packed struct {
        /// DOUT30 [0:15]
        /// Output data sent to MDIO Master during
        DOUT30: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 30
    pub const MDIOS_DOUTR30 = Register(MDIOS_DOUTR30_val).init(base_address + 0x114);

    /// MDIOS_DOUTR31
    const MDIOS_DOUTR31_val = packed struct {
        /// DOUT31 [0:15]
        /// Output data sent to MDIO Master during
        DOUT31: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// MDIOS output data register 31
    pub const MDIOS_DOUTR31 = Register(MDIOS_DOUTR31_val).init(base_address + 0x118);
};

/// Digital filter for sigma delta
pub const DFSDM = struct {
    const base_address = 0x40017400;
    /// DFSDM_CHCFG0R1
    const DFSDM_CHCFG0R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 0 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 0 register
    pub const DFSDM_CHCFG0R1 = Register(DFSDM_CHCFG0R1_val).init(base_address + 0x0);

    /// DFSDM_CHCFG1R1
    const DFSDM_CHCFG1R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 1 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 1 register
    pub const DFSDM_CHCFG1R1 = Register(DFSDM_CHCFG1R1_val).init(base_address + 0x20);

    /// DFSDM_CHCFG2R1
    const DFSDM_CHCFG2R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 2 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 2 register
    pub const DFSDM_CHCFG2R1 = Register(DFSDM_CHCFG2R1_val).init(base_address + 0x40);

    /// DFSDM_CHCFG3R1
    const DFSDM_CHCFG3R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 3 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 3 register
    pub const DFSDM_CHCFG3R1 = Register(DFSDM_CHCFG3R1_val).init(base_address + 0x60);

    /// DFSDM_CHCFG4R1
    const DFSDM_CHCFG4R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 4 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 4 register
    pub const DFSDM_CHCFG4R1 = Register(DFSDM_CHCFG4R1_val).init(base_address + 0x80);

    /// DFSDM_CHCFG5R1
    const DFSDM_CHCFG5R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 5 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 5 register
    pub const DFSDM_CHCFG5R1 = Register(DFSDM_CHCFG5R1_val).init(base_address + 0xa0);

    /// DFSDM_CHCFG6R1
    const DFSDM_CHCFG6R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 6 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 6 register
    pub const DFSDM_CHCFG6R1 = Register(DFSDM_CHCFG6R1_val).init(base_address + 0xc0);

    /// DFSDM_CHCFG7R1
    const DFSDM_CHCFG7R1_val = packed struct {
        /// SITP [0:1]
        /// Serial interface type for channel
        SITP: u2 = 0,
        /// SPICKSEL [2:3]
        /// SPI clock select for channel
        SPICKSEL: u2 = 0,
        /// unused [4:4]
        _unused4: u1 = 0,
        /// SCDEN [5:5]
        /// Short-circuit detector enable on channel
        SCDEN: u1 = 0,
        /// CKABEN [6:6]
        /// Clock absence detector enable on channel
        CKABEN: u1 = 0,
        /// CHEN [7:7]
        /// Channel 7 enable
        CHEN: u1 = 0,
        /// CHINSEL [8:8]
        /// Channel inputs selection
        CHINSEL: u1 = 0,
        /// unused [9:11]
        _unused9: u3 = 0,
        /// DATMPX [12:13]
        /// Input data multiplexer for channel
        DATMPX: u2 = 0,
        /// DATPACK [14:15]
        /// Data packing mode in DFSDM_CHDATINyR
        DATPACK: u2 = 0,
        /// CKOUTDIV [16:23]
        /// Output serial clock
        CKOUTDIV: u8 = 0,
        /// unused [24:29]
        _unused24: u6 = 0,
        /// CKOUTSRC [30:30]
        /// Output serial clock source
        CKOUTSRC: u1 = 0,
        /// DFSDMEN [31:31]
        /// Global enable for DFSDM
        DFSDMEN: u1 = 0,
    };
    /// DFSDM channel configuration 7 register
    pub const DFSDM_CHCFG7R1 = Register(DFSDM_CHCFG7R1_val).init(base_address + 0xe0);

    /// DFSDM_CHCFG0R2
    const DFSDM_CHCFG0R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 0 register
    pub const DFSDM_CHCFG0R2 = Register(DFSDM_CHCFG0R2_val).init(base_address + 0x4);

    /// DFSDM_CHCFG1R2
    const DFSDM_CHCFG1R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 1 register
    pub const DFSDM_CHCFG1R2 = Register(DFSDM_CHCFG1R2_val).init(base_address + 0x24);

    /// DFSDM_CHCFG2R2
    const DFSDM_CHCFG2R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 2 register
    pub const DFSDM_CHCFG2R2 = Register(DFSDM_CHCFG2R2_val).init(base_address + 0x44);

    /// DFSDM_CHCFG3R2
    const DFSDM_CHCFG3R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 3 register
    pub const DFSDM_CHCFG3R2 = Register(DFSDM_CHCFG3R2_val).init(base_address + 0x64);

    /// DFSDM_CHCFG4R2
    const DFSDM_CHCFG4R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 4 register
    pub const DFSDM_CHCFG4R2 = Register(DFSDM_CHCFG4R2_val).init(base_address + 0x84);

    /// DFSDM_CHCFG5R2
    const DFSDM_CHCFG5R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 5 register
    pub const DFSDM_CHCFG5R2 = Register(DFSDM_CHCFG5R2_val).init(base_address + 0xa4);

    /// DFSDM_CHCFG6R2
    const DFSDM_CHCFG6R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 6 register
    pub const DFSDM_CHCFG6R2 = Register(DFSDM_CHCFG6R2_val).init(base_address + 0xc4);

    /// DFSDM_CHCFG7R2
    const DFSDM_CHCFG7R2_val = packed struct {
        /// unused [0:2]
        _unused0: u3 = 0,
        /// DTRBS [3:7]
        /// Data right bit-shift for channel
        DTRBS: u5 = 0,
        /// OFFSET [8:31]
        /// 24-bit calibration offset for channel
        OFFSET: u24 = 0,
    };
    /// DFSDM channel configuration 7 register
    pub const DFSDM_CHCFG7R2 = Register(DFSDM_CHCFG7R2_val).init(base_address + 0xe4);

    /// DFSDM_AWSCD0R
    const DFSDM_AWSCD0R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD0R = Register(DFSDM_AWSCD0R_val).init(base_address + 0x8);

    /// DFSDM_AWSCD1R
    const DFSDM_AWSCD1R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD1R = Register(DFSDM_AWSCD1R_val).init(base_address + 0x28);

    /// DFSDM_AWSCD2R
    const DFSDM_AWSCD2R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD2R = Register(DFSDM_AWSCD2R_val).init(base_address + 0x48);

    /// DFSDM_AWSCD3R
    const DFSDM_AWSCD3R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD3R = Register(DFSDM_AWSCD3R_val).init(base_address + 0x68);

    /// DFSDM_AWSCD4R
    const DFSDM_AWSCD4R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD4R = Register(DFSDM_AWSCD4R_val).init(base_address + 0x88);

    /// DFSDM_AWSCD5R
    const DFSDM_AWSCD5R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD5R = Register(DFSDM_AWSCD5R_val).init(base_address + 0xa8);

    /// DFSDM_AWSCD6R
    const DFSDM_AWSCD6R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD6R = Register(DFSDM_AWSCD6R_val).init(base_address + 0xc8);

    /// DFSDM_AWSCD7R
    const DFSDM_AWSCD7R_val = packed struct {
        /// SCDT [0:7]
        /// short-circuit detector threshold for
        SCDT: u8 = 0,
        /// unused [8:11]
        _unused8: u4 = 0,
        /// BKSCD [12:15]
        /// Break signal assignment for
        BKSCD: u4 = 0,
        /// AWFOSR [16:20]
        /// Analog watchdog filter oversampling
        AWFOSR: u5 = 0,
        /// unused [21:21]
        _unused21: u1 = 0,
        /// AWFORD [22:23]
        /// Analog watchdog Sinc filter order on
        AWFORD: u2 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog and short-circuit
    pub const DFSDM_AWSCD7R = Register(DFSDM_AWSCD7R_val).init(base_address + 0xe8);

    /// DFSDM_CHWDAT0R
    const DFSDM_CHWDAT0R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT0R = Register(DFSDM_CHWDAT0R_val).init(base_address + 0xc);

    /// DFSDM_CHWDAT1R
    const DFSDM_CHWDAT1R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT1R = Register(DFSDM_CHWDAT1R_val).init(base_address + 0x2c);

    /// DFSDM_CHWDAT2R
    const DFSDM_CHWDAT2R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT2R = Register(DFSDM_CHWDAT2R_val).init(base_address + 0x4c);

    /// DFSDM_CHWDAT3R
    const DFSDM_CHWDAT3R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT3R = Register(DFSDM_CHWDAT3R_val).init(base_address + 0x6c);

    /// DFSDM_CHWDAT4R
    const DFSDM_CHWDAT4R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT4R = Register(DFSDM_CHWDAT4R_val).init(base_address + 0x8c);

    /// DFSDM_CHWDAT5R
    const DFSDM_CHWDAT5R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT5R = Register(DFSDM_CHWDAT5R_val).init(base_address + 0xac);

    /// DFSDM_CHWDAT6R
    const DFSDM_CHWDAT6R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT6R = Register(DFSDM_CHWDAT6R_val).init(base_address + 0xcc);

    /// DFSDM_CHWDAT7R
    const DFSDM_CHWDAT7R_val = packed struct {
        /// WDATA [0:15]
        /// Input channel y watchdog
        WDATA: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM channel watchdog filter data
    pub const DFSDM_CHWDAT7R = Register(DFSDM_CHWDAT7R_val).init(base_address + 0xec);

    /// DFSDM_CHDATIN0R
    const DFSDM_CHDATIN0R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 0
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 1
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN0R = Register(DFSDM_CHDATIN0R_val).init(base_address + 0x10);

    /// DFSDM_CHDATIN1R
    const DFSDM_CHDATIN1R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 1
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 2
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN1R = Register(DFSDM_CHDATIN1R_val).init(base_address + 0x30);

    /// DFSDM_CHDATIN2R
    const DFSDM_CHDATIN2R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 2
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 3
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN2R = Register(DFSDM_CHDATIN2R_val).init(base_address + 0x50);

    /// DFSDM_CHDATIN3R
    const DFSDM_CHDATIN3R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 3
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 4
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN3R = Register(DFSDM_CHDATIN3R_val).init(base_address + 0x70);

    /// DFSDM_CHDATIN4R
    const DFSDM_CHDATIN4R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 4
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 5
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN4R = Register(DFSDM_CHDATIN4R_val).init(base_address + 0x90);

    /// DFSDM_CHDATIN5R
    const DFSDM_CHDATIN5R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 5
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 6
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN5R = Register(DFSDM_CHDATIN5R_val).init(base_address + 0xb0);

    /// DFSDM_CHDATIN6R
    const DFSDM_CHDATIN6R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 6
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 7
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN6R = Register(DFSDM_CHDATIN6R_val).init(base_address + 0xd0);

    /// DFSDM_CHDATIN7R
    const DFSDM_CHDATIN7R_val = packed struct {
        /// INDAT0 [0:15]
        /// Input data for channel 7
        INDAT0: u16 = 0,
        /// INDAT1 [16:31]
        /// Input data for channel 8
        INDAT1: u16 = 0,
    };
    /// DFSDM channel data input
    pub const DFSDM_CHDATIN7R = Register(DFSDM_CHDATIN7R_val).init(base_address + 0xf0);

    /// DFSDM0_CR1
    const DFSDM0_CR1_val = packed struct {
        /// DFEN [0:0]
        /// DFSDM enable
        DFEN: u1 = 0,
        /// JSWSTART [1:1]
        /// Start a conversion of the injected group
        JSWSTART: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// JSYNC [3:3]
        /// Launch an injected conversion
        JSYNC: u1 = 0,
        /// JSCAN [4:4]
        /// Scanning conversion mode for injected
        JSCAN: u1 = 0,
        /// JDMAEN [5:5]
        /// DMA channel enabled to read data for the
        JDMAEN: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// JEXTSEL [8:12]
        /// Trigger signal selection for launching
        JEXTSEL: u5 = 0,
        /// JEXTEN [13:14]
        /// Trigger enable and trigger edge
        JEXTEN: u2 = 0,
        /// unused [15:16]
        _unused15: u1 = 0,
        _unused16: u1 = 0,
        /// RSWSTART [17:17]
        /// Software start of a conversion on the
        RSWSTART: u1 = 0,
        /// RCONT [18:18]
        /// Continuous mode selection for regular
        RCONT: u1 = 0,
        /// RSYNC [19:19]
        /// Launch regular conversion synchronously
        RSYNC: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// RDMAEN [21:21]
        /// DMA channel enabled to read data for the
        RDMAEN: u1 = 0,
        /// unused [22:23]
        _unused22: u2 = 0,
        /// RCH [24:26]
        /// Regular channel selection
        RCH: u3 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// FAST [29:29]
        /// Fast conversion mode selection for
        FAST: u1 = 0,
        /// AWFSEL [30:30]
        /// Analog watchdog fast mode
        AWFSEL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// DFSDM control register 1
    pub const DFSDM0_CR1 = Register(DFSDM0_CR1_val).init(base_address + 0x100);

    /// DFSDM1_CR1
    const DFSDM1_CR1_val = packed struct {
        /// DFEN [0:0]
        /// DFSDM enable
        DFEN: u1 = 0,
        /// JSWSTART [1:1]
        /// Start a conversion of the injected group
        JSWSTART: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// JSYNC [3:3]
        /// Launch an injected conversion
        JSYNC: u1 = 0,
        /// JSCAN [4:4]
        /// Scanning conversion mode for injected
        JSCAN: u1 = 0,
        /// JDMAEN [5:5]
        /// DMA channel enabled to read data for the
        JDMAEN: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// JEXTSEL [8:12]
        /// Trigger signal selection for launching
        JEXTSEL: u5 = 0,
        /// JEXTEN [13:14]
        /// Trigger enable and trigger edge
        JEXTEN: u2 = 0,
        /// unused [15:16]
        _unused15: u1 = 0,
        _unused16: u1 = 0,
        /// RSWSTART [17:17]
        /// Software start of a conversion on the
        RSWSTART: u1 = 0,
        /// RCONT [18:18]
        /// Continuous mode selection for regular
        RCONT: u1 = 0,
        /// RSYNC [19:19]
        /// Launch regular conversion synchronously
        RSYNC: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// RDMAEN [21:21]
        /// DMA channel enabled to read data for the
        RDMAEN: u1 = 0,
        /// unused [22:23]
        _unused22: u2 = 0,
        /// RCH [24:26]
        /// Regular channel selection
        RCH: u3 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// FAST [29:29]
        /// Fast conversion mode selection for
        FAST: u1 = 0,
        /// AWFSEL [30:30]
        /// Analog watchdog fast mode
        AWFSEL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// DFSDM control register 1
    pub const DFSDM1_CR1 = Register(DFSDM1_CR1_val).init(base_address + 0x180);

    /// DFSDM2_CR1
    const DFSDM2_CR1_val = packed struct {
        /// DFEN [0:0]
        /// DFSDM enable
        DFEN: u1 = 0,
        /// JSWSTART [1:1]
        /// Start a conversion of the injected group
        JSWSTART: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// JSYNC [3:3]
        /// Launch an injected conversion
        JSYNC: u1 = 0,
        /// JSCAN [4:4]
        /// Scanning conversion mode for injected
        JSCAN: u1 = 0,
        /// JDMAEN [5:5]
        /// DMA channel enabled to read data for the
        JDMAEN: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// JEXTSEL [8:12]
        /// Trigger signal selection for launching
        JEXTSEL: u5 = 0,
        /// JEXTEN [13:14]
        /// Trigger enable and trigger edge
        JEXTEN: u2 = 0,
        /// unused [15:16]
        _unused15: u1 = 0,
        _unused16: u1 = 0,
        /// RSWSTART [17:17]
        /// Software start of a conversion on the
        RSWSTART: u1 = 0,
        /// RCONT [18:18]
        /// Continuous mode selection for regular
        RCONT: u1 = 0,
        /// RSYNC [19:19]
        /// Launch regular conversion synchronously
        RSYNC: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// RDMAEN [21:21]
        /// DMA channel enabled to read data for the
        RDMAEN: u1 = 0,
        /// unused [22:23]
        _unused22: u2 = 0,
        /// RCH [24:26]
        /// Regular channel selection
        RCH: u3 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// FAST [29:29]
        /// Fast conversion mode selection for
        FAST: u1 = 0,
        /// AWFSEL [30:30]
        /// Analog watchdog fast mode
        AWFSEL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// DFSDM control register 1
    pub const DFSDM2_CR1 = Register(DFSDM2_CR1_val).init(base_address + 0x200);

    /// DFSDM3_CR1
    const DFSDM3_CR1_val = packed struct {
        /// DFEN [0:0]
        /// DFSDM enable
        DFEN: u1 = 0,
        /// JSWSTART [1:1]
        /// Start a conversion of the injected group
        JSWSTART: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// JSYNC [3:3]
        /// Launch an injected conversion
        JSYNC: u1 = 0,
        /// JSCAN [4:4]
        /// Scanning conversion mode for injected
        JSCAN: u1 = 0,
        /// JDMAEN [5:5]
        /// DMA channel enabled to read data for the
        JDMAEN: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// JEXTSEL [8:12]
        /// Trigger signal selection for launching
        JEXTSEL: u5 = 0,
        /// JEXTEN [13:14]
        /// Trigger enable and trigger edge
        JEXTEN: u2 = 0,
        /// unused [15:16]
        _unused15: u1 = 0,
        _unused16: u1 = 0,
        /// RSWSTART [17:17]
        /// Software start of a conversion on the
        RSWSTART: u1 = 0,
        /// RCONT [18:18]
        /// Continuous mode selection for regular
        RCONT: u1 = 0,
        /// RSYNC [19:19]
        /// Launch regular conversion synchronously
        RSYNC: u1 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// RDMAEN [21:21]
        /// DMA channel enabled to read data for the
        RDMAEN: u1 = 0,
        /// unused [22:23]
        _unused22: u2 = 0,
        /// RCH [24:26]
        /// Regular channel selection
        RCH: u3 = 0,
        /// unused [27:28]
        _unused27: u2 = 0,
        /// FAST [29:29]
        /// Fast conversion mode selection for
        FAST: u1 = 0,
        /// AWFSEL [30:30]
        /// Analog watchdog fast mode
        AWFSEL: u1 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// DFSDM control register 1
    pub const DFSDM3_CR1 = Register(DFSDM3_CR1_val).init(base_address + 0x380);

    /// DFSDM0_CR2
    const DFSDM0_CR2_val = packed struct {
        /// JEOCIE [0:0]
        /// Injected end of conversion interrupt
        JEOCIE: u1 = 0,
        /// REOCIE [1:1]
        /// Regular end of conversion interrupt
        REOCIE: u1 = 0,
        /// JOVRIE [2:2]
        /// Injected data overrun interrupt
        JOVRIE: u1 = 0,
        /// ROVRIE [3:3]
        /// Regular data overrun interrupt
        ROVRIE: u1 = 0,
        /// AWDIE [4:4]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// SCDIE [5:5]
        /// Short-circuit detector interrupt
        SCDIE: u1 = 0,
        /// CKABIE [6:6]
        /// Clock absence interrupt
        CKABIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EXCH [8:15]
        /// Extremes detector channel
        EXCH: u8 = 0,
        /// AWDCH [16:23]
        /// Analog watchdog channel
        AWDCH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM control register 2
    pub const DFSDM0_CR2 = Register(DFSDM0_CR2_val).init(base_address + 0x104);

    /// DFSDM1_CR2
    const DFSDM1_CR2_val = packed struct {
        /// JEOCIE [0:0]
        /// Injected end of conversion interrupt
        JEOCIE: u1 = 0,
        /// REOCIE [1:1]
        /// Regular end of conversion interrupt
        REOCIE: u1 = 0,
        /// JOVRIE [2:2]
        /// Injected data overrun interrupt
        JOVRIE: u1 = 0,
        /// ROVRIE [3:3]
        /// Regular data overrun interrupt
        ROVRIE: u1 = 0,
        /// AWDIE [4:4]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// SCDIE [5:5]
        /// Short-circuit detector interrupt
        SCDIE: u1 = 0,
        /// CKABIE [6:6]
        /// Clock absence interrupt
        CKABIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EXCH [8:15]
        /// Extremes detector channel
        EXCH: u8 = 0,
        /// AWDCH [16:23]
        /// Analog watchdog channel
        AWDCH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM control register 2
    pub const DFSDM1_CR2 = Register(DFSDM1_CR2_val).init(base_address + 0x184);

    /// DFSDM2_CR2
    const DFSDM2_CR2_val = packed struct {
        /// JEOCIE [0:0]
        /// Injected end of conversion interrupt
        JEOCIE: u1 = 0,
        /// REOCIE [1:1]
        /// Regular end of conversion interrupt
        REOCIE: u1 = 0,
        /// JOVRIE [2:2]
        /// Injected data overrun interrupt
        JOVRIE: u1 = 0,
        /// ROVRIE [3:3]
        /// Regular data overrun interrupt
        ROVRIE: u1 = 0,
        /// AWDIE [4:4]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// SCDIE [5:5]
        /// Short-circuit detector interrupt
        SCDIE: u1 = 0,
        /// CKABIE [6:6]
        /// Clock absence interrupt
        CKABIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EXCH [8:15]
        /// Extremes detector channel
        EXCH: u8 = 0,
        /// AWDCH [16:23]
        /// Analog watchdog channel
        AWDCH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM control register 2
    pub const DFSDM2_CR2 = Register(DFSDM2_CR2_val).init(base_address + 0x204);

    /// DFSDM3_CR2
    const DFSDM3_CR2_val = packed struct {
        /// JEOCIE [0:0]
        /// Injected end of conversion interrupt
        JEOCIE: u1 = 0,
        /// REOCIE [1:1]
        /// Regular end of conversion interrupt
        REOCIE: u1 = 0,
        /// JOVRIE [2:2]
        /// Injected data overrun interrupt
        JOVRIE: u1 = 0,
        /// ROVRIE [3:3]
        /// Regular data overrun interrupt
        ROVRIE: u1 = 0,
        /// AWDIE [4:4]
        /// Analog watchdog interrupt
        AWDIE: u1 = 0,
        /// SCDIE [5:5]
        /// Short-circuit detector interrupt
        SCDIE: u1 = 0,
        /// CKABIE [6:6]
        /// Clock absence interrupt
        CKABIE: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// EXCH [8:15]
        /// Extremes detector channel
        EXCH: u8 = 0,
        /// AWDCH [16:23]
        /// Analog watchdog channel
        AWDCH: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DFSDM control register 2
    pub const DFSDM3_CR2 = Register(DFSDM3_CR2_val).init(base_address + 0x384);

    /// DFSDM0_ISR
    const DFSDM0_ISR_val = packed struct {
        /// JEOCF [0:0]
        /// End of injected conversion
        JEOCF: u1 = 0,
        /// REOCF [1:1]
        /// End of regular conversion
        REOCF: u1 = 0,
        /// JOVRF [2:2]
        /// Injected conversion overrun
        JOVRF: u1 = 0,
        /// ROVRF [3:3]
        /// Regular conversion overrun
        ROVRF: u1 = 0,
        /// AWDF [4:4]
        /// Analog watchdog
        AWDF: u1 = 0,
        /// unused [5:12]
        _unused5: u3 = 0,
        _unused8: u5 = 0,
        /// JCIP [13:13]
        /// Injected conversion in progress
        JCIP: u1 = 0,
        /// RCIP [14:14]
        /// Regular conversion in progress
        RCIP: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// CKABF [16:23]
        /// Clock absence flag
        CKABF: u8 = 255,
        /// SCDF [24:31]
        /// short-circuit detector
        SCDF: u8 = 0,
    };
    /// DFSDM interrupt and status
    pub const DFSDM0_ISR = Register(DFSDM0_ISR_val).init(base_address + 0x108);

    /// DFSDM1_ISR
    const DFSDM1_ISR_val = packed struct {
        /// JEOCF [0:0]
        /// End of injected conversion
        JEOCF: u1 = 0,
        /// REOCF [1:1]
        /// End of regular conversion
        REOCF: u1 = 0,
        /// JOVRF [2:2]
        /// Injected conversion overrun
        JOVRF: u1 = 0,
        /// ROVRF [3:3]
        /// Regular conversion overrun
        ROVRF: u1 = 0,
        /// AWDF [4:4]
        /// Analog watchdog
        AWDF: u1 = 0,
        /// unused [5:12]
        _unused5: u3 = 0,
        _unused8: u5 = 0,
        /// JCIP [13:13]
        /// Injected conversion in progress
        JCIP: u1 = 0,
        /// RCIP [14:14]
        /// Regular conversion in progress
        RCIP: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// CKABF [16:23]
        /// Clock absence flag
        CKABF: u8 = 255,
        /// SCDF [24:31]
        /// short-circuit detector
        SCDF: u8 = 0,
    };
    /// DFSDM interrupt and status
    pub const DFSDM1_ISR = Register(DFSDM1_ISR_val).init(base_address + 0x188);

    /// DFSDM2_ISR
    const DFSDM2_ISR_val = packed struct {
        /// JEOCF [0:0]
        /// End of injected conversion
        JEOCF: u1 = 0,
        /// REOCF [1:1]
        /// End of regular conversion
        REOCF: u1 = 0,
        /// JOVRF [2:2]
        /// Injected conversion overrun
        JOVRF: u1 = 0,
        /// ROVRF [3:3]
        /// Regular conversion overrun
        ROVRF: u1 = 0,
        /// AWDF [4:4]
        /// Analog watchdog
        AWDF: u1 = 0,
        /// unused [5:12]
        _unused5: u3 = 0,
        _unused8: u5 = 0,
        /// JCIP [13:13]
        /// Injected conversion in progress
        JCIP: u1 = 0,
        /// RCIP [14:14]
        /// Regular conversion in progress
        RCIP: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// CKABF [16:23]
        /// Clock absence flag
        CKABF: u8 = 255,
        /// SCDF [24:31]
        /// short-circuit detector
        SCDF: u8 = 0,
    };
    /// DFSDM interrupt and status
    pub const DFSDM2_ISR = Register(DFSDM2_ISR_val).init(base_address + 0x208);

    /// DFSDM3_ISR
    const DFSDM3_ISR_val = packed struct {
        /// JEOCF [0:0]
        /// End of injected conversion
        JEOCF: u1 = 0,
        /// REOCF [1:1]
        /// End of regular conversion
        REOCF: u1 = 0,
        /// JOVRF [2:2]
        /// Injected conversion overrun
        JOVRF: u1 = 0,
        /// ROVRF [3:3]
        /// Regular conversion overrun
        ROVRF: u1 = 0,
        /// AWDF [4:4]
        /// Analog watchdog
        AWDF: u1 = 0,
        /// unused [5:12]
        _unused5: u3 = 0,
        _unused8: u5 = 0,
        /// JCIP [13:13]
        /// Injected conversion in progress
        JCIP: u1 = 0,
        /// RCIP [14:14]
        /// Regular conversion in progress
        RCIP: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// CKABF [16:23]
        /// Clock absence flag
        CKABF: u8 = 255,
        /// SCDF [24:31]
        /// short-circuit detector
        SCDF: u8 = 0,
    };
    /// DFSDM interrupt and status
    pub const DFSDM3_ISR = Register(DFSDM3_ISR_val).init(base_address + 0x388);

    /// DFSDM0_ICR
    const DFSDM0_ICR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// CLRJOVRF [2:2]
        /// Clear the injected conversion overrun
        CLRJOVRF: u1 = 0,
        /// CLRROVRF [3:3]
        /// Clear the regular conversion overrun
        CLRROVRF: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// CLRCKABF [16:23]
        /// Clear the clock absence
        CLRCKABF: u8 = 0,
        /// CLRSCDF [24:31]
        /// Clear the short-circuit detector
        CLRSCDF: u8 = 0,
    };
    /// DFSDM interrupt flag clear
    pub const DFSDM0_ICR = Register(DFSDM0_ICR_val).init(base_address + 0x10c);

    /// DFSDM1_ICR
    const DFSDM1_ICR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// CLRJOVRF [2:2]
        /// Clear the injected conversion overrun
        CLRJOVRF: u1 = 0,
        /// CLRROVRF [3:3]
        /// Clear the regular conversion overrun
        CLRROVRF: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// CLRCKABF [16:23]
        /// Clear the clock absence
        CLRCKABF: u8 = 0,
        /// CLRSCDF [24:31]
        /// Clear the short-circuit detector
        CLRSCDF: u8 = 0,
    };
    /// DFSDM interrupt flag clear
    pub const DFSDM1_ICR = Register(DFSDM1_ICR_val).init(base_address + 0x18c);

    /// DFSDM2_ICR
    const DFSDM2_ICR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// CLRJOVRF [2:2]
        /// Clear the injected conversion overrun
        CLRJOVRF: u1 = 0,
        /// CLRROVRF [3:3]
        /// Clear the regular conversion overrun
        CLRROVRF: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// CLRCKABF [16:23]
        /// Clear the clock absence
        CLRCKABF: u8 = 0,
        /// CLRSCDF [24:31]
        /// Clear the short-circuit detector
        CLRSCDF: u8 = 0,
    };
    /// DFSDM interrupt flag clear
    pub const DFSDM2_ICR = Register(DFSDM2_ICR_val).init(base_address + 0x20c);

    /// DFSDM3_ICR
    const DFSDM3_ICR_val = packed struct {
        /// unused [0:1]
        _unused0: u2 = 0,
        /// CLRJOVRF [2:2]
        /// Clear the injected conversion overrun
        CLRJOVRF: u1 = 0,
        /// CLRROVRF [3:3]
        /// Clear the regular conversion overrun
        CLRROVRF: u1 = 0,
        /// unused [4:15]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        /// CLRCKABF [16:23]
        /// Clear the clock absence
        CLRCKABF: u8 = 0,
        /// CLRSCDF [24:31]
        /// Clear the short-circuit detector
        CLRSCDF: u8 = 0,
    };
    /// DFSDM interrupt flag clear
    pub const DFSDM3_ICR = Register(DFSDM3_ICR_val).init(base_address + 0x38c);

    /// DFSDM0_JCHGR
    const DFSDM0_JCHGR_val = packed struct {
        /// JCHG [0:7]
        /// Injected channel group
        JCHG: u8 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM injected channel group selection
    pub const DFSDM0_JCHGR = Register(DFSDM0_JCHGR_val).init(base_address + 0x110);

    /// DFSDM1_JCHGR
    const DFSDM1_JCHGR_val = packed struct {
        /// JCHG [0:7]
        /// Injected channel group
        JCHG: u8 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM injected channel group selection
    pub const DFSDM1_JCHGR = Register(DFSDM1_JCHGR_val).init(base_address + 0x190);

    /// DFSDM2_JCHGR
    const DFSDM2_JCHGR_val = packed struct {
        /// JCHG [0:7]
        /// Injected channel group
        JCHG: u8 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM injected channel group selection
    pub const DFSDM2_JCHGR = Register(DFSDM2_JCHGR_val).init(base_address + 0x210);

    /// DFSDM3_JCHGR
    const DFSDM3_JCHGR_val = packed struct {
        /// JCHG [0:7]
        /// Injected channel group
        JCHG: u8 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM injected channel group selection
    pub const DFSDM3_JCHGR = Register(DFSDM3_JCHGR_val).init(base_address + 0x310);

    /// DFSDM0_FCR
    const DFSDM0_FCR_val = packed struct {
        /// IOSR [0:7]
        /// Integrator oversampling ratio (averaging
        IOSR: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// FOSR [16:25]
        /// Sinc filter oversampling ratio
        FOSR: u10 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// FORD [29:31]
        /// Sinc filter order
        FORD: u3 = 0,
    };
    /// DFSDM filter control register
    pub const DFSDM0_FCR = Register(DFSDM0_FCR_val).init(base_address + 0x114);

    /// DFSDM1_FCR
    const DFSDM1_FCR_val = packed struct {
        /// IOSR [0:7]
        /// Integrator oversampling ratio (averaging
        IOSR: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// FOSR [16:25]
        /// Sinc filter oversampling ratio
        FOSR: u10 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// FORD [29:31]
        /// Sinc filter order
        FORD: u3 = 0,
    };
    /// DFSDM filter control register
    pub const DFSDM1_FCR = Register(DFSDM1_FCR_val).init(base_address + 0x194);

    /// DFSDM2_FCR
    const DFSDM2_FCR_val = packed struct {
        /// IOSR [0:7]
        /// Integrator oversampling ratio (averaging
        IOSR: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// FOSR [16:25]
        /// Sinc filter oversampling ratio
        FOSR: u10 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// FORD [29:31]
        /// Sinc filter order
        FORD: u3 = 0,
    };
    /// DFSDM filter control register
    pub const DFSDM2_FCR = Register(DFSDM2_FCR_val).init(base_address + 0x214);

    /// DFSDM3_FCR
    const DFSDM3_FCR_val = packed struct {
        /// IOSR [0:7]
        /// Integrator oversampling ratio (averaging
        IOSR: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// FOSR [16:25]
        /// Sinc filter oversampling ratio
        FOSR: u10 = 0,
        /// unused [26:28]
        _unused26: u3 = 0,
        /// FORD [29:31]
        /// Sinc filter order
        FORD: u3 = 0,
    };
    /// DFSDM filter control register
    pub const DFSDM3_FCR = Register(DFSDM3_FCR_val).init(base_address + 0x314);

    /// DFSDM0_JDATAR
    const DFSDM0_JDATAR_val = packed struct {
        /// JDATACH [0:2]
        /// Injected channel most recently
        JDATACH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// JDATA [8:31]
        /// Injected group conversion
        JDATA: u24 = 0,
    };
    /// DFSDM data register for injected
    pub const DFSDM0_JDATAR = Register(DFSDM0_JDATAR_val).init(base_address + 0x118);

    /// DFSDM1_JDATAR
    const DFSDM1_JDATAR_val = packed struct {
        /// JDATACH [0:2]
        /// Injected channel most recently
        JDATACH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// JDATA [8:31]
        /// Injected group conversion
        JDATA: u24 = 0,
    };
    /// DFSDM data register for injected
    pub const DFSDM1_JDATAR = Register(DFSDM1_JDATAR_val).init(base_address + 0x198);

    /// DFSDM2_JDATAR
    const DFSDM2_JDATAR_val = packed struct {
        /// JDATACH [0:2]
        /// Injected channel most recently
        JDATACH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// JDATA [8:31]
        /// Injected group conversion
        JDATA: u24 = 0,
    };
    /// DFSDM data register for injected
    pub const DFSDM2_JDATAR = Register(DFSDM2_JDATAR_val).init(base_address + 0x218);

    /// DFSDM3_JDATAR
    const DFSDM3_JDATAR_val = packed struct {
        /// JDATACH [0:2]
        /// Injected channel most recently
        JDATACH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// JDATA [8:31]
        /// Injected group conversion
        JDATA: u24 = 0,
    };
    /// DFSDM data register for injected
    pub const DFSDM3_JDATAR = Register(DFSDM3_JDATAR_val).init(base_address + 0x318);

    /// DFSDM0_RDATAR
    const DFSDM0_RDATAR_val = packed struct {
        /// RDATACH [0:2]
        /// Regular channel most recently
        RDATACH: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RPEND [4:4]
        /// Regular channel pending
        RPEND: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RDATA [8:31]
        /// Regular channel conversion
        RDATA: u24 = 0,
    };
    /// DFSDM data register for the regular
    pub const DFSDM0_RDATAR = Register(DFSDM0_RDATAR_val).init(base_address + 0x11c);

    /// DFSDM1_RDATAR
    const DFSDM1_RDATAR_val = packed struct {
        /// RDATACH [0:2]
        /// Regular channel most recently
        RDATACH: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RPEND [4:4]
        /// Regular channel pending
        RPEND: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RDATA [8:31]
        /// Regular channel conversion
        RDATA: u24 = 0,
    };
    /// DFSDM data register for the regular
    pub const DFSDM1_RDATAR = Register(DFSDM1_RDATAR_val).init(base_address + 0x198);

    /// DFSDM2_RDATAR
    const DFSDM2_RDATAR_val = packed struct {
        /// RDATACH [0:2]
        /// Regular channel most recently
        RDATACH: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RPEND [4:4]
        /// Regular channel pending
        RPEND: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RDATA [8:31]
        /// Regular channel conversion
        RDATA: u24 = 0,
    };
    /// DFSDM data register for the regular
    pub const DFSDM2_RDATAR = Register(DFSDM2_RDATAR_val).init(base_address + 0x218);

    /// DFSDM3_RDATAR
    const DFSDM3_RDATAR_val = packed struct {
        /// RDATACH [0:2]
        /// Regular channel most recently
        RDATACH: u3 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// RPEND [4:4]
        /// Regular channel pending
        RPEND: u1 = 0,
        /// unused [5:7]
        _unused5: u3 = 0,
        /// RDATA [8:31]
        /// Regular channel conversion
        RDATA: u24 = 0,
    };
    /// DFSDM data register for the regular
    pub const DFSDM3_RDATAR = Register(DFSDM3_RDATAR_val).init(base_address + 0x318);

    /// DFSDM0_AWHTR
    const DFSDM0_AWHTR_val = packed struct {
        /// BKAWH [0:3]
        /// Break signal assignment to analog
        BKAWH: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWHT [8:31]
        /// Analog watchdog high
        AWHT: u24 = 0,
    };
    /// DFSDM analog watchdog high threshold
    pub const DFSDM0_AWHTR = Register(DFSDM0_AWHTR_val).init(base_address + 0x120);

    /// DFSDM1_AWHTR
    const DFSDM1_AWHTR_val = packed struct {
        /// BKAWH [0:3]
        /// Break signal assignment to analog
        BKAWH: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWHT [8:31]
        /// Analog watchdog high
        AWHT: u24 = 0,
    };
    /// DFSDM analog watchdog high threshold
    pub const DFSDM1_AWHTR = Register(DFSDM1_AWHTR_val).init(base_address + 0x1a0);

    /// DFSDM2_AWHTR
    const DFSDM2_AWHTR_val = packed struct {
        /// BKAWH [0:3]
        /// Break signal assignment to analog
        BKAWH: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWHT [8:31]
        /// Analog watchdog high
        AWHT: u24 = 0,
    };
    /// DFSDM analog watchdog high threshold
    pub const DFSDM2_AWHTR = Register(DFSDM2_AWHTR_val).init(base_address + 0x220);

    /// DFSDM3_AWHTR
    const DFSDM3_AWHTR_val = packed struct {
        /// BKAWH [0:3]
        /// Break signal assignment to analog
        BKAWH: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWHT [8:31]
        /// Analog watchdog high
        AWHT: u24 = 0,
    };
    /// DFSDM analog watchdog high threshold
    pub const DFSDM3_AWHTR = Register(DFSDM3_AWHTR_val).init(base_address + 0x2a0);

    /// DFSDM0_AWLTR
    const DFSDM0_AWLTR_val = packed struct {
        /// BKAWL [0:3]
        /// Break signal assignment to analog
        BKAWL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWLT [8:31]
        /// Analog watchdog low
        AWLT: u24 = 0,
    };
    /// DFSDM analog watchdog low threshold
    pub const DFSDM0_AWLTR = Register(DFSDM0_AWLTR_val).init(base_address + 0x124);

    /// DFSDM1_AWLTR
    const DFSDM1_AWLTR_val = packed struct {
        /// BKAWL [0:3]
        /// Break signal assignment to analog
        BKAWL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWLT [8:31]
        /// Analog watchdog low
        AWLT: u24 = 0,
    };
    /// DFSDM analog watchdog low threshold
    pub const DFSDM1_AWLTR = Register(DFSDM1_AWLTR_val).init(base_address + 0x1a4);

    /// DFSDM2_AWLTR
    const DFSDM2_AWLTR_val = packed struct {
        /// BKAWL [0:3]
        /// Break signal assignment to analog
        BKAWL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWLT [8:31]
        /// Analog watchdog low
        AWLT: u24 = 0,
    };
    /// DFSDM analog watchdog low threshold
    pub const DFSDM2_AWLTR = Register(DFSDM2_AWLTR_val).init(base_address + 0x224);

    /// DFSDM3_AWLTR
    const DFSDM3_AWLTR_val = packed struct {
        /// BKAWL [0:3]
        /// Break signal assignment to analog
        BKAWL: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// AWLT [8:31]
        /// Analog watchdog low
        AWLT: u24 = 0,
    };
    /// DFSDM analog watchdog low threshold
    pub const DFSDM3_AWLTR = Register(DFSDM3_AWLTR_val).init(base_address + 0x2a4);

    /// DFSDM0_AWSR
    const DFSDM0_AWSR_val = packed struct {
        /// AWLTF [0:7]
        /// Analog watchdog low threshold
        AWLTF: u8 = 0,
        /// AWHTF [8:15]
        /// Analog watchdog high threshold
        AWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog status
    pub const DFSDM0_AWSR = Register(DFSDM0_AWSR_val).init(base_address + 0x128);

    /// DFSDM1_AWSR
    const DFSDM1_AWSR_val = packed struct {
        /// AWLTF [0:7]
        /// Analog watchdog low threshold
        AWLTF: u8 = 0,
        /// AWHTF [8:15]
        /// Analog watchdog high threshold
        AWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog status
    pub const DFSDM1_AWSR = Register(DFSDM1_AWSR_val).init(base_address + 0x1a8);

    /// DFSDM2_AWSR
    const DFSDM2_AWSR_val = packed struct {
        /// AWLTF [0:7]
        /// Analog watchdog low threshold
        AWLTF: u8 = 0,
        /// AWHTF [8:15]
        /// Analog watchdog high threshold
        AWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog status
    pub const DFSDM2_AWSR = Register(DFSDM2_AWSR_val).init(base_address + 0x228);

    /// DFSDM3_AWSR
    const DFSDM3_AWSR_val = packed struct {
        /// AWLTF [0:7]
        /// Analog watchdog low threshold
        AWLTF: u8 = 0,
        /// AWHTF [8:15]
        /// Analog watchdog high threshold
        AWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog status
    pub const DFSDM3_AWSR = Register(DFSDM3_AWSR_val).init(base_address + 0x2a8);

    /// DFSDM0_AWCFR
    const DFSDM0_AWCFR_val = packed struct {
        /// CLRAWLTF [0:7]
        /// Clear the analog watchdog low threshold
        CLRAWLTF: u8 = 0,
        /// CLRAWHTF [8:15]
        /// Clear the analog watchdog high threshold
        CLRAWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog clear flag
    pub const DFSDM0_AWCFR = Register(DFSDM0_AWCFR_val).init(base_address + 0x12c);

    /// DFSDM1_AWCFR
    const DFSDM1_AWCFR_val = packed struct {
        /// CLRAWLTF [0:7]
        /// Clear the analog watchdog low threshold
        CLRAWLTF: u8 = 0,
        /// CLRAWHTF [8:15]
        /// Clear the analog watchdog high threshold
        CLRAWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog clear flag
    pub const DFSDM1_AWCFR = Register(DFSDM1_AWCFR_val).init(base_address + 0x1ac);

    /// DFSDM2_AWCFR
    const DFSDM2_AWCFR_val = packed struct {
        /// CLRAWLTF [0:7]
        /// Clear the analog watchdog low threshold
        CLRAWLTF: u8 = 0,
        /// CLRAWHTF [8:15]
        /// Clear the analog watchdog high threshold
        CLRAWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog clear flag
    pub const DFSDM2_AWCFR = Register(DFSDM2_AWCFR_val).init(base_address + 0x22c);

    /// DFSDM3_AWCFR
    const DFSDM3_AWCFR_val = packed struct {
        /// CLRAWLTF [0:7]
        /// Clear the analog watchdog low threshold
        CLRAWLTF: u8 = 0,
        /// CLRAWHTF [8:15]
        /// Clear the analog watchdog high threshold
        CLRAWHTF: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DFSDM analog watchdog clear flag
    pub const DFSDM3_AWCFR = Register(DFSDM3_AWCFR_val).init(base_address + 0x2ac);

    /// DFSDM0_EXMAX
    const DFSDM0_EXMAX_val = packed struct {
        /// EXMAXCH [0:2]
        /// Extremes detector maximum data
        EXMAXCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMAX [8:31]
        /// Extremes detector maximum
        EXMAX: u24 = 0,
    };
    /// DFSDM Extremes detector maximum
    pub const DFSDM0_EXMAX = Register(DFSDM0_EXMAX_val).init(base_address + 0x130);

    /// DFSDM1_EXMAX
    const DFSDM1_EXMAX_val = packed struct {
        /// EXMAXCH [0:2]
        /// Extremes detector maximum data
        EXMAXCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMAX [8:31]
        /// Extremes detector maximum
        EXMAX: u24 = 0,
    };
    /// DFSDM Extremes detector maximum
    pub const DFSDM1_EXMAX = Register(DFSDM1_EXMAX_val).init(base_address + 0x1b0);

    /// DFSDM2_EXMAX
    const DFSDM2_EXMAX_val = packed struct {
        /// EXMAXCH [0:2]
        /// Extremes detector maximum data
        EXMAXCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMAX [8:31]
        /// Extremes detector maximum
        EXMAX: u24 = 0,
    };
    /// DFSDM Extremes detector maximum
    pub const DFSDM2_EXMAX = Register(DFSDM2_EXMAX_val).init(base_address + 0x230);

    /// DFSDM3_EXMAX
    const DFSDM3_EXMAX_val = packed struct {
        /// EXMAXCH [0:2]
        /// Extremes detector maximum data
        EXMAXCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMAX [8:31]
        /// Extremes detector maximum
        EXMAX: u24 = 0,
    };
    /// DFSDM Extremes detector maximum
    pub const DFSDM3_EXMAX = Register(DFSDM3_EXMAX_val).init(base_address + 0x2b0);

    /// DFSDM0_EXMIN
    const DFSDM0_EXMIN_val = packed struct {
        /// EXMINCH [0:2]
        /// Extremes detector minimum data
        EXMINCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMIN [8:31]
        /// Extremes detector minimum
        EXMIN: u24 = 8388607,
    };
    /// DFSDM Extremes detector minimum
    pub const DFSDM0_EXMIN = Register(DFSDM0_EXMIN_val).init(base_address + 0x134);

    /// DFSDM1_EXMIN
    const DFSDM1_EXMIN_val = packed struct {
        /// EXMINCH [0:2]
        /// Extremes detector minimum data
        EXMINCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMIN [8:31]
        /// Extremes detector minimum
        EXMIN: u24 = 8388607,
    };
    /// DFSDM Extremes detector minimum
    pub const DFSDM1_EXMIN = Register(DFSDM1_EXMIN_val).init(base_address + 0x1b4);

    /// DFSDM2_EXMIN
    const DFSDM2_EXMIN_val = packed struct {
        /// EXMINCH [0:2]
        /// Extremes detector minimum data
        EXMINCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMIN [8:31]
        /// Extremes detector minimum
        EXMIN: u24 = 8388607,
    };
    /// DFSDM Extremes detector minimum
    pub const DFSDM2_EXMIN = Register(DFSDM2_EXMIN_val).init(base_address + 0x234);

    /// DFSDM3_EXMIN
    const DFSDM3_EXMIN_val = packed struct {
        /// EXMINCH [0:2]
        /// Extremes detector minimum data
        EXMINCH: u3 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// EXMIN [8:31]
        /// Extremes detector minimum
        EXMIN: u24 = 8388607,
    };
    /// DFSDM Extremes detector minimum
    pub const DFSDM3_EXMIN = Register(DFSDM3_EXMIN_val).init(base_address + 0x2b4);

    /// DFSDM0_CNVTIMR
    const DFSDM0_CNVTIMR_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// CNVCNT [4:31]
        /// 28-bit timer counting conversion
        CNVCNT: u28 = 0,
    };
    /// DFSDM conversion timer
    pub const DFSDM0_CNVTIMR = Register(DFSDM0_CNVTIMR_val).init(base_address + 0x138);

    /// DFSDM1_CNVTIMR
    const DFSDM1_CNVTIMR_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// CNVCNT [4:31]
        /// 28-bit timer counting conversion
        CNVCNT: u28 = 0,
    };
    /// DFSDM conversion timer
    pub const DFSDM1_CNVTIMR = Register(DFSDM1_CNVTIMR_val).init(base_address + 0x1b8);

    /// DFSDM2_CNVTIMR
    const DFSDM2_CNVTIMR_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// CNVCNT [4:31]
        /// 28-bit timer counting conversion
        CNVCNT: u28 = 0,
    };
    /// DFSDM conversion timer
    pub const DFSDM2_CNVTIMR = Register(DFSDM2_CNVTIMR_val).init(base_address + 0x238);

    /// DFSDM3_CNVTIMR
    const DFSDM3_CNVTIMR_val = packed struct {
        /// unused [0:3]
        _unused0: u4 = 0,
        /// CNVCNT [4:31]
        /// 28-bit timer counting conversion
        CNVCNT: u28 = 0,
    };
    /// DFSDM conversion timer
    pub const DFSDM3_CNVTIMR = Register(DFSDM3_CNVTIMR_val).init(base_address + 0x2b8);
};

/// JPEG codec
pub const JPEG = struct {
    const base_address = 0x50051000;
    /// JPEG_CONFR0
    const JPEG_CONFR0_val = packed struct {
        /// START [0:0]
        /// Start
        START: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR0 = Register(JPEG_CONFR0_val).init(base_address + 0x0);

    /// JPEG_CONFR1
    const JPEG_CONFR1_val = packed struct {
        /// NF [0:1]
        /// Number of color components
        NF: u2 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// DE [3:3]
        /// Decoding Enable
        DE: u1 = 0,
        /// COLORSPACE [4:5]
        /// Color Space
        COLORSPACE: u2 = 0,
        /// NS [6:7]
        /// Number of components for
        NS: u2 = 0,
        /// HDR [8:8]
        /// Header Processing
        HDR: u1 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// YSIZE [16:31]
        /// Y Size
        YSIZE: u16 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR1 = Register(JPEG_CONFR1_val).init(base_address + 0x4);

    /// JPEG_CONFR2
    const JPEG_CONFR2_val = packed struct {
        /// NMCU [0:25]
        /// Number of MCU
        NMCU: u26 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR2 = Register(JPEG_CONFR2_val).init(base_address + 0x8);

    /// JPEG_CONFR3
    const JPEG_CONFR3_val = packed struct {
        /// unused [0:15]
        _unused0: u8 = 0,
        _unused8: u8 = 0,
        /// XSIZE [16:31]
        /// X size
        XSIZE: u16 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR3 = Register(JPEG_CONFR3_val).init(base_address + 0xc);

    /// JPEG_CONFR4
    const JPEG_CONFR4_val = packed struct {
        /// HD [0:0]
        /// Huffman DC
        HD: u1 = 0,
        /// HA [1:1]
        /// Huffman AC
        HA: u1 = 0,
        /// QT [2:3]
        /// Quantization Table
        QT: u2 = 0,
        /// NB [4:7]
        /// Number of Block
        NB: u4 = 0,
        /// VSF [8:11]
        /// Vertical Sampling Factor
        VSF: u4 = 0,
        /// HSF [12:15]
        /// Horizontal Sampling Factor
        HSF: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR4 = Register(JPEG_CONFR4_val).init(base_address + 0x10);

    /// JPEG_CONFR5
    const JPEG_CONFR5_val = packed struct {
        /// HD [0:0]
        /// Huffman DC
        HD: u1 = 0,
        /// HA [1:1]
        /// Huffman AC
        HA: u1 = 0,
        /// QT [2:3]
        /// Quantization Table
        QT: u2 = 0,
        /// NB [4:7]
        /// Number of Block
        NB: u4 = 0,
        /// VSF [8:11]
        /// Vertical Sampling Factor
        VSF: u4 = 0,
        /// HSF [12:15]
        /// Horizontal Sampling Factor
        HSF: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR5 = Register(JPEG_CONFR5_val).init(base_address + 0x14);

    /// JPEG_CONFR6
    const JPEG_CONFR6_val = packed struct {
        /// HD [0:0]
        /// Huffman DC
        HD: u1 = 0,
        /// HA [1:1]
        /// Huffman AC
        HA: u1 = 0,
        /// QT [2:3]
        /// Quantization Table
        QT: u2 = 0,
        /// NB [4:7]
        /// Number of Block
        NB: u4 = 0,
        /// VSF [8:11]
        /// Vertical Sampling Factor
        VSF: u4 = 0,
        /// HSF [12:15]
        /// Horizontal Sampling Factor
        HSF: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR6 = Register(JPEG_CONFR6_val).init(base_address + 0x18);

    /// JPEG_CONFR7
    const JPEG_CONFR7_val = packed struct {
        /// HD [0:0]
        /// Huffman DC
        HD: u1 = 0,
        /// HA [1:1]
        /// Huffman AC
        HA: u1 = 0,
        /// QT [2:3]
        /// Quantization Table
        QT: u2 = 0,
        /// NB [4:7]
        /// Number of Block
        NB: u4 = 0,
        /// VSF [8:11]
        /// Vertical Sampling Factor
        VSF: u4 = 0,
        /// HSF [12:15]
        /// Horizontal Sampling Factor
        HSF: u4 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG codec configuration register
    pub const JPEG_CONFR7 = Register(JPEG_CONFR7_val).init(base_address + 0x1c);

    /// JPEG_CR
    const JPEG_CR_val = packed struct {
        /// JCEN [0:0]
        /// JPEG Core Enable
        JCEN: u1 = 0,
        /// IFTIE [1:1]
        /// Input FIFO Threshold Interrupt
        IFTIE: u1 = 0,
        /// IFNFIE [2:2]
        /// Input FIFO Not Full Interrupt
        IFNFIE: u1 = 0,
        /// OFTIE [3:3]
        /// Output FIFO Threshold Interrupt
        OFTIE: u1 = 0,
        /// OFNEIE [4:4]
        /// Output FIFO Not Empty Interrupt
        OFNEIE: u1 = 0,
        /// EOCIE [5:5]
        /// End of Conversion Interrupt
        EOCIE: u1 = 0,
        /// HPDIE [6:6]
        /// Header Parsing Done Interrupt
        HPDIE: u1 = 0,
        /// unused [7:10]
        _unused7: u1 = 0,
        _unused8: u3 = 0,
        /// IDMAEN [11:11]
        /// Input DMA Enable
        IDMAEN: u1 = 0,
        /// ODMAEN [12:12]
        /// Output DMA Enable
        ODMAEN: u1 = 0,
        /// IFF [13:13]
        /// Input FIFO Flush
        IFF: u1 = 0,
        /// OFF [14:14]
        /// Output FIFO Flush
        OFF: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG control register
    pub const JPEG_CR = Register(JPEG_CR_val).init(base_address + 0x30);

    /// JPEG_SR
    const JPEG_SR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// IFTF [1:1]
        /// Input FIFO Threshold Flag
        IFTF: u1 = 0,
        /// IFNFF [2:2]
        /// Input FIFO Not Full Flag
        IFNFF: u1 = 0,
        /// OFTF [3:3]
        /// Output FIFO Threshold Flag
        OFTF: u1 = 0,
        /// OFNEF [4:4]
        /// Output FIFO Not Empty Flag
        OFNEF: u1 = 0,
        /// EOCF [5:5]
        /// End of Conversion Flag
        EOCF: u1 = 0,
        /// HPDF [6:6]
        /// Header Parsing Done Flag
        HPDF: u1 = 0,
        /// COF [7:7]
        /// Codec Operation Flag
        COF: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG status register
    pub const JPEG_SR = Register(JPEG_SR_val).init(base_address + 0x34);

    /// JPEG_CFR
    const JPEG_CFR_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// CEOCF [5:5]
        /// Clear End of Conversion
        CEOCF: u1 = 0,
        /// CHPDF [6:6]
        /// Clear Header Parsing Done
        CHPDF: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// JPEG clear flag register
    pub const JPEG_CFR = Register(JPEG_CFR_val).init(base_address + 0x38);

    /// JPEG_DIR
    const JPEG_DIR_val = packed struct {
        /// DATAIN [0:31]
        /// Data Input FIFO
        DATAIN: u32 = 0,
    };
    /// JPEG data input register
    pub const JPEG_DIR = Register(JPEG_DIR_val).init(base_address + 0x40);

    /// JPEG_DOR
    const JPEG_DOR_val = packed struct {
        /// DATAOUT [0:31]
        /// Data Output FIFO
        DATAOUT: u32 = 0,
    };
    /// JPEG data output register
    pub const JPEG_DOR = Register(JPEG_DOR_val).init(base_address + 0x44);

    /// QMEM0_0
    const QMEM0_0_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_0 = Register(QMEM0_0_val).init(base_address + 0x50);

    /// QMEM0_1
    const QMEM0_1_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_1 = Register(QMEM0_1_val).init(base_address + 0x54);

    /// QMEM0_2
    const QMEM0_2_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_2 = Register(QMEM0_2_val).init(base_address + 0x58);

    /// QMEM0_3
    const QMEM0_3_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_3 = Register(QMEM0_3_val).init(base_address + 0x5c);

    /// QMEM0_4
    const QMEM0_4_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_4 = Register(QMEM0_4_val).init(base_address + 0x60);

    /// QMEM0_5
    const QMEM0_5_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_5 = Register(QMEM0_5_val).init(base_address + 0x64);

    /// QMEM0_6
    const QMEM0_6_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_6 = Register(QMEM0_6_val).init(base_address + 0x68);

    /// QMEM0_7
    const QMEM0_7_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_7 = Register(QMEM0_7_val).init(base_address + 0x6c);

    /// QMEM0_8
    const QMEM0_8_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_8 = Register(QMEM0_8_val).init(base_address + 0x70);

    /// QMEM0_9
    const QMEM0_9_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_9 = Register(QMEM0_9_val).init(base_address + 0x74);

    /// QMEM0_10
    const QMEM0_10_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_10 = Register(QMEM0_10_val).init(base_address + 0x78);

    /// QMEM0_11
    const QMEM0_11_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_11 = Register(QMEM0_11_val).init(base_address + 0x7c);

    /// QMEM0_12
    const QMEM0_12_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_12 = Register(QMEM0_12_val).init(base_address + 0x80);

    /// QMEM0_13
    const QMEM0_13_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_13 = Register(QMEM0_13_val).init(base_address + 0x84);

    /// QMEM0_14
    const QMEM0_14_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_14 = Register(QMEM0_14_val).init(base_address + 0x88);

    /// QMEM0_15
    const QMEM0_15_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM0_15 = Register(QMEM0_15_val).init(base_address + 0x8c);

    /// QMEM1_0
    const QMEM1_0_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_0 = Register(QMEM1_0_val).init(base_address + 0x90);

    /// QMEM1_1
    const QMEM1_1_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_1 = Register(QMEM1_1_val).init(base_address + 0x94);

    /// QMEM1_2
    const QMEM1_2_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_2 = Register(QMEM1_2_val).init(base_address + 0x98);

    /// QMEM1_3
    const QMEM1_3_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_3 = Register(QMEM1_3_val).init(base_address + 0x9c);

    /// QMEM1_4
    const QMEM1_4_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_4 = Register(QMEM1_4_val).init(base_address + 0xa0);

    /// QMEM1_5
    const QMEM1_5_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_5 = Register(QMEM1_5_val).init(base_address + 0xa4);

    /// QMEM1_6
    const QMEM1_6_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_6 = Register(QMEM1_6_val).init(base_address + 0xa8);

    /// QMEM1_7
    const QMEM1_7_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_7 = Register(QMEM1_7_val).init(base_address + 0xac);

    /// QMEM1_8
    const QMEM1_8_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_8 = Register(QMEM1_8_val).init(base_address + 0xb0);

    /// QMEM1_9
    const QMEM1_9_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_9 = Register(QMEM1_9_val).init(base_address + 0xb4);

    /// QMEM1_10
    const QMEM1_10_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_10 = Register(QMEM1_10_val).init(base_address + 0xb8);

    /// QMEM1_11
    const QMEM1_11_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_11 = Register(QMEM1_11_val).init(base_address + 0xbc);

    /// QMEM1_12
    const QMEM1_12_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_12 = Register(QMEM1_12_val).init(base_address + 0xc0);

    /// QMEM1_13
    const QMEM1_13_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_13 = Register(QMEM1_13_val).init(base_address + 0xc4);

    /// QMEM1_14
    const QMEM1_14_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_14 = Register(QMEM1_14_val).init(base_address + 0xc8);

    /// QMEM1_15
    const QMEM1_15_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM1_15 = Register(QMEM1_15_val).init(base_address + 0xcc);

    /// QMEM2_0
    const QMEM2_0_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_0 = Register(QMEM2_0_val).init(base_address + 0xd0);

    /// QMEM2_1
    const QMEM2_1_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_1 = Register(QMEM2_1_val).init(base_address + 0xd4);

    /// QMEM2_2
    const QMEM2_2_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_2 = Register(QMEM2_2_val).init(base_address + 0xd8);

    /// QMEM2_3
    const QMEM2_3_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_3 = Register(QMEM2_3_val).init(base_address + 0xdc);

    /// QMEM2_4
    const QMEM2_4_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_4 = Register(QMEM2_4_val).init(base_address + 0xe0);

    /// QMEM2_5
    const QMEM2_5_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_5 = Register(QMEM2_5_val).init(base_address + 0xe4);

    /// QMEM2_6
    const QMEM2_6_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_6 = Register(QMEM2_6_val).init(base_address + 0xe8);

    /// QMEM2_7
    const QMEM2_7_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_7 = Register(QMEM2_7_val).init(base_address + 0xec);

    /// QMEM2_8
    const QMEM2_8_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_8 = Register(QMEM2_8_val).init(base_address + 0xf0);

    /// QMEM2_9
    const QMEM2_9_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_9 = Register(QMEM2_9_val).init(base_address + 0xf4);

    /// QMEM2_10
    const QMEM2_10_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_10 = Register(QMEM2_10_val).init(base_address + 0xf8);

    /// QMEM2_11
    const QMEM2_11_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_11 = Register(QMEM2_11_val).init(base_address + 0xfc);

    /// QMEM2_12
    const QMEM2_12_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_12 = Register(QMEM2_12_val).init(base_address + 0x100);

    /// QMEM2_13
    const QMEM2_13_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_13 = Register(QMEM2_13_val).init(base_address + 0x104);

    /// QMEM2_14
    const QMEM2_14_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_14 = Register(QMEM2_14_val).init(base_address + 0x108);

    /// QMEM2_15
    const QMEM2_15_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM2_15 = Register(QMEM2_15_val).init(base_address + 0x10c);

    /// QMEM3_0
    const QMEM3_0_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_0 = Register(QMEM3_0_val).init(base_address + 0x110);

    /// QMEM3_1
    const QMEM3_1_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_1 = Register(QMEM3_1_val).init(base_address + 0x114);

    /// QMEM3_2
    const QMEM3_2_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_2 = Register(QMEM3_2_val).init(base_address + 0x118);

    /// QMEM3_3
    const QMEM3_3_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_3 = Register(QMEM3_3_val).init(base_address + 0x11c);

    /// QMEM3_4
    const QMEM3_4_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_4 = Register(QMEM3_4_val).init(base_address + 0x120);

    /// QMEM3_5
    const QMEM3_5_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_5 = Register(QMEM3_5_val).init(base_address + 0x124);

    /// QMEM3_6
    const QMEM3_6_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_6 = Register(QMEM3_6_val).init(base_address + 0x128);

    /// QMEM3_7
    const QMEM3_7_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_7 = Register(QMEM3_7_val).init(base_address + 0x12c);

    /// QMEM3_8
    const QMEM3_8_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_8 = Register(QMEM3_8_val).init(base_address + 0x130);

    /// QMEM3_9
    const QMEM3_9_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_9 = Register(QMEM3_9_val).init(base_address + 0x134);

    /// QMEM3_10
    const QMEM3_10_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_10 = Register(QMEM3_10_val).init(base_address + 0x138);

    /// QMEM3_11
    const QMEM3_11_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_11 = Register(QMEM3_11_val).init(base_address + 0x13c);

    /// QMEM3_12
    const QMEM3_12_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_12 = Register(QMEM3_12_val).init(base_address + 0x140);

    /// QMEM3_13
    const QMEM3_13_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_13 = Register(QMEM3_13_val).init(base_address + 0x144);

    /// QMEM3_14
    const QMEM3_14_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_14 = Register(QMEM3_14_val).init(base_address + 0x148);

    /// QMEM3_15
    const QMEM3_15_val = packed struct {
        /// QMem_RAM [0:31]
        /// QMem RAM
        QMem_RAM: u32 = 0,
    };
    /// JPEG quantization tables
    pub const QMEM3_15 = Register(QMEM3_15_val).init(base_address + 0x14c);

    /// HUFFMIN_0
    const HUFFMIN_0_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_0 = Register(HUFFMIN_0_val).init(base_address + 0x150);

    /// HUFFMIN_1
    const HUFFMIN_1_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_1 = Register(HUFFMIN_1_val).init(base_address + 0x154);

    /// HUFFMIN_2
    const HUFFMIN_2_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_2 = Register(HUFFMIN_2_val).init(base_address + 0x158);

    /// HUFFMIN_3
    const HUFFMIN_3_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_3 = Register(HUFFMIN_3_val).init(base_address + 0x15c);

    /// HUFFMIN_4
    const HUFFMIN_4_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_4 = Register(HUFFMIN_4_val).init(base_address + 0x160);

    /// HUFFMIN_5
    const HUFFMIN_5_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_5 = Register(HUFFMIN_5_val).init(base_address + 0x164);

    /// HUFFMIN_6
    const HUFFMIN_6_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_6 = Register(HUFFMIN_6_val).init(base_address + 0x168);

    /// HUFFMIN_7
    const HUFFMIN_7_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_7 = Register(HUFFMIN_7_val).init(base_address + 0x16c);

    /// HUFFMIN_8
    const HUFFMIN_8_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_8 = Register(HUFFMIN_8_val).init(base_address + 0x170);

    /// HUFFMIN_9
    const HUFFMIN_9_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_9 = Register(HUFFMIN_9_val).init(base_address + 0x174);

    /// HUFFMIN_10
    const HUFFMIN_10_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_10 = Register(HUFFMIN_10_val).init(base_address + 0x178);

    /// HUFFMIN_11
    const HUFFMIN_11_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_11 = Register(HUFFMIN_11_val).init(base_address + 0x17c);

    /// HUFFMIN_12
    const HUFFMIN_12_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_12 = Register(HUFFMIN_12_val).init(base_address + 0x180);

    /// HUFFMIN_13
    const HUFFMIN_13_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_13 = Register(HUFFMIN_13_val).init(base_address + 0x184);

    /// HUFFMIN_14
    const HUFFMIN_14_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_14 = Register(HUFFMIN_14_val).init(base_address + 0x188);

    /// HUFFMIN_15
    const HUFFMIN_15_val = packed struct {
        /// HuffMin_RAM [0:31]
        /// HuffMin RAM
        HuffMin_RAM: u32 = 0,
    };
    /// JPEG HuffMin tables
    pub const HUFFMIN_15 = Register(HUFFMIN_15_val).init(base_address + 0x18c);

    /// HUFFBASE0
    const HUFFBASE0_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE0 = Register(HUFFBASE0_val).init(base_address + 0x190);

    /// HUFFBASE1
    const HUFFBASE1_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE1 = Register(HUFFBASE1_val).init(base_address + 0x194);

    /// HUFFBASE2
    const HUFFBASE2_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE2 = Register(HUFFBASE2_val).init(base_address + 0x198);

    /// HUFFBASE3
    const HUFFBASE3_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE3 = Register(HUFFBASE3_val).init(base_address + 0x19c);

    /// HUFFBASE4
    const HUFFBASE4_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE4 = Register(HUFFBASE4_val).init(base_address + 0x1a0);

    /// HUFFBASE5
    const HUFFBASE5_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE5 = Register(HUFFBASE5_val).init(base_address + 0x1a4);

    /// HUFFBASE6
    const HUFFBASE6_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE6 = Register(HUFFBASE6_val).init(base_address + 0x1a8);

    /// HUFFBASE7
    const HUFFBASE7_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE7 = Register(HUFFBASE7_val).init(base_address + 0x1ac);

    /// HUFFBASE8
    const HUFFBASE8_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE8 = Register(HUFFBASE8_val).init(base_address + 0x1b0);

    /// HUFFBASE9
    const HUFFBASE9_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE9 = Register(HUFFBASE9_val).init(base_address + 0x1b4);

    /// HUFFBASE10
    const HUFFBASE10_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE10 = Register(HUFFBASE10_val).init(base_address + 0x1b8);

    /// HUFFBASE11
    const HUFFBASE11_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE11 = Register(HUFFBASE11_val).init(base_address + 0x1bc);

    /// HUFFBASE12
    const HUFFBASE12_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE12 = Register(HUFFBASE12_val).init(base_address + 0x1c0);

    /// HUFFBASE13
    const HUFFBASE13_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE13 = Register(HUFFBASE13_val).init(base_address + 0x1c4);

    /// HUFFBASE14
    const HUFFBASE14_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE14 = Register(HUFFBASE14_val).init(base_address + 0x1c8);

    /// HUFFBASE15
    const HUFFBASE15_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE15 = Register(HUFFBASE15_val).init(base_address + 0x1cc);

    /// HUFFBASE16
    const HUFFBASE16_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE16 = Register(HUFFBASE16_val).init(base_address + 0x1d0);

    /// HUFFBASE17
    const HUFFBASE17_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE17 = Register(HUFFBASE17_val).init(base_address + 0x1d4);

    /// HUFFBASE18
    const HUFFBASE18_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE18 = Register(HUFFBASE18_val).init(base_address + 0x1d8);

    /// HUFFBASE19
    const HUFFBASE19_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE19 = Register(HUFFBASE19_val).init(base_address + 0x1dc);

    /// HUFFBASE20
    const HUFFBASE20_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE20 = Register(HUFFBASE20_val).init(base_address + 0x1e0);

    /// HUFFBASE21
    const HUFFBASE21_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE21 = Register(HUFFBASE21_val).init(base_address + 0x1e4);

    /// HUFFBASE22
    const HUFFBASE22_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE22 = Register(HUFFBASE22_val).init(base_address + 0x1e8);

    /// HUFFBASE23
    const HUFFBASE23_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE23 = Register(HUFFBASE23_val).init(base_address + 0x1ec);

    /// HUFFBASE24
    const HUFFBASE24_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE24 = Register(HUFFBASE24_val).init(base_address + 0x1f0);

    /// HUFFBASE25
    const HUFFBASE25_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE25 = Register(HUFFBASE25_val).init(base_address + 0x1f4);

    /// HUFFBASE26
    const HUFFBASE26_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE26 = Register(HUFFBASE26_val).init(base_address + 0x1f8);

    /// HUFFBASE27
    const HUFFBASE27_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE27 = Register(HUFFBASE27_val).init(base_address + 0x1fc);

    /// HUFFBASE28
    const HUFFBASE28_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE28 = Register(HUFFBASE28_val).init(base_address + 0x200);

    /// HUFFBASE29
    const HUFFBASE29_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE29 = Register(HUFFBASE29_val).init(base_address + 0x204);

    /// HUFFBASE30
    const HUFFBASE30_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE30 = Register(HUFFBASE30_val).init(base_address + 0x208);

    /// HUFFBASE31
    const HUFFBASE31_val = packed struct {
        /// HuffBase_RAM_0 [0:8]
        /// HuffBase RAM
        HuffBase_RAM_0: u9 = 0,
        /// unused [9:15]
        _unused9: u7 = 0,
        /// HuffBase_RAM_1 [16:24]
        /// HuffBase RAM
        HuffBase_RAM_1: u9 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// JPEG HuffSymb tables
    pub const HUFFBASE31 = Register(HUFFBASE31_val).init(base_address + 0x20c);

    /// HUFFSYMB0
    const HUFFSYMB0_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB0 = Register(HUFFSYMB0_val).init(base_address + 0x210);

    /// HUFFSYMB1
    const HUFFSYMB1_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB1 = Register(HUFFSYMB1_val).init(base_address + 0x214);

    /// HUFFSYMB2
    const HUFFSYMB2_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB2 = Register(HUFFSYMB2_val).init(base_address + 0x218);

    /// HUFFSYMB3
    const HUFFSYMB3_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB3 = Register(HUFFSYMB3_val).init(base_address + 0x21c);

    /// HUFFSYMB4
    const HUFFSYMB4_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB4 = Register(HUFFSYMB4_val).init(base_address + 0x220);

    /// HUFFSYMB5
    const HUFFSYMB5_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB5 = Register(HUFFSYMB5_val).init(base_address + 0x224);

    /// HUFFSYMB6
    const HUFFSYMB6_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB6 = Register(HUFFSYMB6_val).init(base_address + 0x228);

    /// HUFFSYMB7
    const HUFFSYMB7_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB7 = Register(HUFFSYMB7_val).init(base_address + 0x22c);

    /// HUFFSYMB8
    const HUFFSYMB8_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB8 = Register(HUFFSYMB8_val).init(base_address + 0x230);

    /// HUFFSYMB9
    const HUFFSYMB9_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB9 = Register(HUFFSYMB9_val).init(base_address + 0x234);

    /// HUFFSYMB10
    const HUFFSYMB10_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB10 = Register(HUFFSYMB10_val).init(base_address + 0x238);

    /// HUFFSYMB11
    const HUFFSYMB11_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB11 = Register(HUFFSYMB11_val).init(base_address + 0x23c);

    /// HUFFSYMB12
    const HUFFSYMB12_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB12 = Register(HUFFSYMB12_val).init(base_address + 0x240);

    /// HUFFSYMB13
    const HUFFSYMB13_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB13 = Register(HUFFSYMB13_val).init(base_address + 0x244);

    /// HUFFSYMB14
    const HUFFSYMB14_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB14 = Register(HUFFSYMB14_val).init(base_address + 0x248);

    /// HUFFSYMB15
    const HUFFSYMB15_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB15 = Register(HUFFSYMB15_val).init(base_address + 0x24c);

    /// HUFFSYMB16
    const HUFFSYMB16_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB16 = Register(HUFFSYMB16_val).init(base_address + 0x250);

    /// HUFFSYMB17
    const HUFFSYMB17_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB17 = Register(HUFFSYMB17_val).init(base_address + 0x254);

    /// HUFFSYMB18
    const HUFFSYMB18_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB18 = Register(HUFFSYMB18_val).init(base_address + 0x258);

    /// HUFFSYMB19
    const HUFFSYMB19_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB19 = Register(HUFFSYMB19_val).init(base_address + 0x25c);

    /// HUFFSYMB20
    const HUFFSYMB20_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB20 = Register(HUFFSYMB20_val).init(base_address + 0x260);

    /// HUFFSYMB21
    const HUFFSYMB21_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB21 = Register(HUFFSYMB21_val).init(base_address + 0x264);

    /// HUFFSYMB22
    const HUFFSYMB22_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB22 = Register(HUFFSYMB22_val).init(base_address + 0x268);

    /// HUFFSYMB23
    const HUFFSYMB23_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB23 = Register(HUFFSYMB23_val).init(base_address + 0x26c);

    /// HUFFSYMB24
    const HUFFSYMB24_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB24 = Register(HUFFSYMB24_val).init(base_address + 0x270);

    /// HUFFSYMB25
    const HUFFSYMB25_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB25 = Register(HUFFSYMB25_val).init(base_address + 0x274);

    /// HUFFSYMB26
    const HUFFSYMB26_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB26 = Register(HUFFSYMB26_val).init(base_address + 0x278);

    /// HUFFSYMB27
    const HUFFSYMB27_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB27 = Register(HUFFSYMB27_val).init(base_address + 0x27c);

    /// HUFFSYMB28
    const HUFFSYMB28_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB28 = Register(HUFFSYMB28_val).init(base_address + 0x280);

    /// HUFFSYMB29
    const HUFFSYMB29_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB29 = Register(HUFFSYMB29_val).init(base_address + 0x284);

    /// HUFFSYMB30
    const HUFFSYMB30_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB30 = Register(HUFFSYMB30_val).init(base_address + 0x288);

    /// HUFFSYMB31
    const HUFFSYMB31_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB31 = Register(HUFFSYMB31_val).init(base_address + 0x28c);

    /// HUFFSYMB32
    const HUFFSYMB32_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB32 = Register(HUFFSYMB32_val).init(base_address + 0x290);

    /// HUFFSYMB33
    const HUFFSYMB33_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB33 = Register(HUFFSYMB33_val).init(base_address + 0x294);

    /// HUFFSYMB34
    const HUFFSYMB34_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB34 = Register(HUFFSYMB34_val).init(base_address + 0x298);

    /// HUFFSYMB35
    const HUFFSYMB35_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB35 = Register(HUFFSYMB35_val).init(base_address + 0x29c);

    /// HUFFSYMB36
    const HUFFSYMB36_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB36 = Register(HUFFSYMB36_val).init(base_address + 0x2a0);

    /// HUFFSYMB37
    const HUFFSYMB37_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB37 = Register(HUFFSYMB37_val).init(base_address + 0x2a4);

    /// HUFFSYMB38
    const HUFFSYMB38_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB38 = Register(HUFFSYMB38_val).init(base_address + 0x2a8);

    /// HUFFSYMB39
    const HUFFSYMB39_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB39 = Register(HUFFSYMB39_val).init(base_address + 0x2ac);

    /// HUFFSYMB40
    const HUFFSYMB40_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB40 = Register(HUFFSYMB40_val).init(base_address + 0x2b0);

    /// HUFFSYMB41
    const HUFFSYMB41_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB41 = Register(HUFFSYMB41_val).init(base_address + 0x2b4);

    /// HUFFSYMB42
    const HUFFSYMB42_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB42 = Register(HUFFSYMB42_val).init(base_address + 0x2b8);

    /// HUFFSYMB43
    const HUFFSYMB43_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB43 = Register(HUFFSYMB43_val).init(base_address + 0x2bc);

    /// HUFFSYMB44
    const HUFFSYMB44_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB44 = Register(HUFFSYMB44_val).init(base_address + 0x2c0);

    /// HUFFSYMB45
    const HUFFSYMB45_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB45 = Register(HUFFSYMB45_val).init(base_address + 0x2c4);

    /// HUFFSYMB46
    const HUFFSYMB46_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB46 = Register(HUFFSYMB46_val).init(base_address + 0x2c8);

    /// HUFFSYMB47
    const HUFFSYMB47_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB47 = Register(HUFFSYMB47_val).init(base_address + 0x2cc);

    /// HUFFSYMB48
    const HUFFSYMB48_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB48 = Register(HUFFSYMB48_val).init(base_address + 0x2d0);

    /// HUFFSYMB49
    const HUFFSYMB49_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB49 = Register(HUFFSYMB49_val).init(base_address + 0x2d4);

    /// HUFFSYMB50
    const HUFFSYMB50_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB50 = Register(HUFFSYMB50_val).init(base_address + 0x2d8);

    /// HUFFSYMB51
    const HUFFSYMB51_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB51 = Register(HUFFSYMB51_val).init(base_address + 0x2dc);

    /// HUFFSYMB52
    const HUFFSYMB52_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB52 = Register(HUFFSYMB52_val).init(base_address + 0x2e0);

    /// HUFFSYMB53
    const HUFFSYMB53_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB53 = Register(HUFFSYMB53_val).init(base_address + 0x2e4);

    /// HUFFSYMB54
    const HUFFSYMB54_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB54 = Register(HUFFSYMB54_val).init(base_address + 0x2e8);

    /// HUFFSYMB55
    const HUFFSYMB55_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB55 = Register(HUFFSYMB55_val).init(base_address + 0x2ec);

    /// HUFFSYMB56
    const HUFFSYMB56_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB56 = Register(HUFFSYMB56_val).init(base_address + 0x2f0);

    /// HUFFSYMB57
    const HUFFSYMB57_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB57 = Register(HUFFSYMB57_val).init(base_address + 0x2f4);

    /// HUFFSYMB58
    const HUFFSYMB58_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB58 = Register(HUFFSYMB58_val).init(base_address + 0x2f8);

    /// HUFFSYMB59
    const HUFFSYMB59_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB59 = Register(HUFFSYMB59_val).init(base_address + 0x2fc);

    /// HUFFSYMB60
    const HUFFSYMB60_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB60 = Register(HUFFSYMB60_val).init(base_address + 0x300);

    /// HUFFSYMB61
    const HUFFSYMB61_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB61 = Register(HUFFSYMB61_val).init(base_address + 0x304);

    /// HUFFSYMB62
    const HUFFSYMB62_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB62 = Register(HUFFSYMB62_val).init(base_address + 0x308);

    /// HUFFSYMB63
    const HUFFSYMB63_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB63 = Register(HUFFSYMB63_val).init(base_address + 0x30c);

    /// HUFFSYMB64
    const HUFFSYMB64_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB64 = Register(HUFFSYMB64_val).init(base_address + 0x310);

    /// HUFFSYMB65
    const HUFFSYMB65_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB65 = Register(HUFFSYMB65_val).init(base_address + 0x314);

    /// HUFFSYMB66
    const HUFFSYMB66_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB66 = Register(HUFFSYMB66_val).init(base_address + 0x318);

    /// HUFFSYMB67
    const HUFFSYMB67_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB67 = Register(HUFFSYMB67_val).init(base_address + 0x31c);

    /// HUFFSYMB68
    const HUFFSYMB68_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB68 = Register(HUFFSYMB68_val).init(base_address + 0x320);

    /// HUFFSYMB69
    const HUFFSYMB69_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB69 = Register(HUFFSYMB69_val).init(base_address + 0x324);

    /// HUFFSYMB70
    const HUFFSYMB70_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB70 = Register(HUFFSYMB70_val).init(base_address + 0x328);

    /// HUFFSYMB71
    const HUFFSYMB71_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB71 = Register(HUFFSYMB71_val).init(base_address + 0x32c);

    /// HUFFSYMB72
    const HUFFSYMB72_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB72 = Register(HUFFSYMB72_val).init(base_address + 0x330);

    /// HUFFSYMB73
    const HUFFSYMB73_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB73 = Register(HUFFSYMB73_val).init(base_address + 0x334);

    /// HUFFSYMB74
    const HUFFSYMB74_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB74 = Register(HUFFSYMB74_val).init(base_address + 0x338);

    /// HUFFSYMB75
    const HUFFSYMB75_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB75 = Register(HUFFSYMB75_val).init(base_address + 0x33c);

    /// HUFFSYMB76
    const HUFFSYMB76_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB76 = Register(HUFFSYMB76_val).init(base_address + 0x340);

    /// HUFFSYMB77
    const HUFFSYMB77_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB77 = Register(HUFFSYMB77_val).init(base_address + 0x344);

    /// HUFFSYMB78
    const HUFFSYMB78_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB78 = Register(HUFFSYMB78_val).init(base_address + 0x348);

    /// HUFFSYMB79
    const HUFFSYMB79_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB79 = Register(HUFFSYMB79_val).init(base_address + 0x34c);

    /// HUFFSYMB80
    const HUFFSYMB80_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB80 = Register(HUFFSYMB80_val).init(base_address + 0x350);

    /// HUFFSYMB81
    const HUFFSYMB81_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB81 = Register(HUFFSYMB81_val).init(base_address + 0x354);

    /// HUFFSYMB82
    const HUFFSYMB82_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB82 = Register(HUFFSYMB82_val).init(base_address + 0x358);

    /// HUFFSYMB83
    const HUFFSYMB83_val = packed struct {
        /// HuffSymb_RAM [0:31]
        /// DHTSymb RAM
        HuffSymb_RAM: u32 = 0,
    };
    /// JPEG HUFFSYMB tables
    pub const HUFFSYMB83 = Register(HUFFSYMB83_val).init(base_address + 0x35c);

    /// DHTMEM0
    const DHTMEM0_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM0 = Register(DHTMEM0_val).init(base_address + 0x360);

    /// DHTMEM2
    const DHTMEM2_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM2 = Register(DHTMEM2_val).init(base_address + 0x364);

    /// DHTMEM3
    const DHTMEM3_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM3 = Register(DHTMEM3_val).init(base_address + 0x368);

    /// DHTMEM4
    const DHTMEM4_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM4 = Register(DHTMEM4_val).init(base_address + 0x36c);

    /// DHTMEM5
    const DHTMEM5_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM5 = Register(DHTMEM5_val).init(base_address + 0x370);

    /// DHTMEM6
    const DHTMEM6_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM6 = Register(DHTMEM6_val).init(base_address + 0x374);

    /// DHTMEM7
    const DHTMEM7_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM7 = Register(DHTMEM7_val).init(base_address + 0x378);

    /// DHTMEM8
    const DHTMEM8_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM8 = Register(DHTMEM8_val).init(base_address + 0x37c);

    /// DHTMEM9
    const DHTMEM9_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM9 = Register(DHTMEM9_val).init(base_address + 0x380);

    /// DHTMEM10
    const DHTMEM10_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM10 = Register(DHTMEM10_val).init(base_address + 0x384);

    /// DHTMEM11
    const DHTMEM11_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM11 = Register(DHTMEM11_val).init(base_address + 0x388);

    /// DHTMEM12
    const DHTMEM12_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM12 = Register(DHTMEM12_val).init(base_address + 0x38c);

    /// DHTMEM13
    const DHTMEM13_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM13 = Register(DHTMEM13_val).init(base_address + 0x390);

    /// DHTMEM14
    const DHTMEM14_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM14 = Register(DHTMEM14_val).init(base_address + 0x394);

    /// DHTMEM15
    const DHTMEM15_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM15 = Register(DHTMEM15_val).init(base_address + 0x398);

    /// DHTMEM16
    const DHTMEM16_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM16 = Register(DHTMEM16_val).init(base_address + 0x39c);

    /// DHTMEM17
    const DHTMEM17_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM17 = Register(DHTMEM17_val).init(base_address + 0x3a0);

    /// DHTMEM18
    const DHTMEM18_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM18 = Register(DHTMEM18_val).init(base_address + 0x3a4);

    /// DHTMEM19
    const DHTMEM19_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM19 = Register(DHTMEM19_val).init(base_address + 0x3a8);

    /// DHTMEM20
    const DHTMEM20_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM20 = Register(DHTMEM20_val).init(base_address + 0x3ac);

    /// DHTMEM21
    const DHTMEM21_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM21 = Register(DHTMEM21_val).init(base_address + 0x3b0);

    /// DHTMEM22
    const DHTMEM22_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM22 = Register(DHTMEM22_val).init(base_address + 0x3b4);

    /// DHTMEM23
    const DHTMEM23_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM23 = Register(DHTMEM23_val).init(base_address + 0x3b8);

    /// DHTMEM24
    const DHTMEM24_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM24 = Register(DHTMEM24_val).init(base_address + 0x3bc);

    /// DHTMEM25
    const DHTMEM25_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM25 = Register(DHTMEM25_val).init(base_address + 0x3c0);

    /// DHTMEM26
    const DHTMEM26_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM26 = Register(DHTMEM26_val).init(base_address + 0x3c4);

    /// DHTMEM27
    const DHTMEM27_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM27 = Register(DHTMEM27_val).init(base_address + 0x3c8);

    /// DHTMEM28
    const DHTMEM28_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM28 = Register(DHTMEM28_val).init(base_address + 0x3cc);

    /// DHTMEM29
    const DHTMEM29_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM29 = Register(DHTMEM29_val).init(base_address + 0x3d0);

    /// DHTMEM30
    const DHTMEM30_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM30 = Register(DHTMEM30_val).init(base_address + 0x3d4);

    /// DHTMEM31
    const DHTMEM31_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM31 = Register(DHTMEM31_val).init(base_address + 0x3d8);

    /// DHTMEM32
    const DHTMEM32_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM32 = Register(DHTMEM32_val).init(base_address + 0x3dc);

    /// DHTMEM33
    const DHTMEM33_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM33 = Register(DHTMEM33_val).init(base_address + 0x3e0);

    /// DHTMEM34
    const DHTMEM34_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM34 = Register(DHTMEM34_val).init(base_address + 0x3e4);

    /// DHTMEM35
    const DHTMEM35_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM35 = Register(DHTMEM35_val).init(base_address + 0x3e8);

    /// DHTMEM36
    const DHTMEM36_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM36 = Register(DHTMEM36_val).init(base_address + 0x3ec);

    /// DHTMEM37
    const DHTMEM37_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM37 = Register(DHTMEM37_val).init(base_address + 0x3f0);

    /// DHTMEM38
    const DHTMEM38_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM38 = Register(DHTMEM38_val).init(base_address + 0x3f4);

    /// DHTMEM39
    const DHTMEM39_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM39 = Register(DHTMEM39_val).init(base_address + 0x3f8);

    /// DHTMEM40
    const DHTMEM40_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM40 = Register(DHTMEM40_val).init(base_address + 0x3fc);

    /// DHTMEM41
    const DHTMEM41_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM41 = Register(DHTMEM41_val).init(base_address + 0x400);

    /// DHTMEM42
    const DHTMEM42_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM42 = Register(DHTMEM42_val).init(base_address + 0x404);

    /// DHTMEM43
    const DHTMEM43_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM43 = Register(DHTMEM43_val).init(base_address + 0x408);

    /// DHTMEM44
    const DHTMEM44_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM44 = Register(DHTMEM44_val).init(base_address + 0x40c);

    /// DHTMEM45
    const DHTMEM45_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM45 = Register(DHTMEM45_val).init(base_address + 0x410);

    /// DHTMEM46
    const DHTMEM46_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM46 = Register(DHTMEM46_val).init(base_address + 0x414);

    /// DHTMEM47
    const DHTMEM47_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM47 = Register(DHTMEM47_val).init(base_address + 0x418);

    /// DHTMEM48
    const DHTMEM48_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM48 = Register(DHTMEM48_val).init(base_address + 0x41c);

    /// DHTMEM49
    const DHTMEM49_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM49 = Register(DHTMEM49_val).init(base_address + 0x420);

    /// DHTMEM50
    const DHTMEM50_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM50 = Register(DHTMEM50_val).init(base_address + 0x424);

    /// DHTMEM51
    const DHTMEM51_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM51 = Register(DHTMEM51_val).init(base_address + 0x428);

    /// DHTMEM52
    const DHTMEM52_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM52 = Register(DHTMEM52_val).init(base_address + 0x42c);

    /// DHTMEM53
    const DHTMEM53_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM53 = Register(DHTMEM53_val).init(base_address + 0x430);

    /// DHTMEM54
    const DHTMEM54_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM54 = Register(DHTMEM54_val).init(base_address + 0x434);

    /// DHTMEM55
    const DHTMEM55_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM55 = Register(DHTMEM55_val).init(base_address + 0x438);

    /// DHTMEM56
    const DHTMEM56_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM56 = Register(DHTMEM56_val).init(base_address + 0x43c);

    /// DHTMEM57
    const DHTMEM57_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM57 = Register(DHTMEM57_val).init(base_address + 0x440);

    /// DHTMEM58
    const DHTMEM58_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM58 = Register(DHTMEM58_val).init(base_address + 0x444);

    /// DHTMEM59
    const DHTMEM59_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM59 = Register(DHTMEM59_val).init(base_address + 0x448);

    /// DHTMEM60
    const DHTMEM60_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM60 = Register(DHTMEM60_val).init(base_address + 0x44c);

    /// DHTMEM61
    const DHTMEM61_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM61 = Register(DHTMEM61_val).init(base_address + 0x450);

    /// DHTMEM62
    const DHTMEM62_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM62 = Register(DHTMEM62_val).init(base_address + 0x454);

    /// DHTMEM63
    const DHTMEM63_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM63 = Register(DHTMEM63_val).init(base_address + 0x458);

    /// DHTMEM64
    const DHTMEM64_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM64 = Register(DHTMEM64_val).init(base_address + 0x45c);

    /// DHTMEM65
    const DHTMEM65_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM65 = Register(DHTMEM65_val).init(base_address + 0x460);

    /// DHTMEM66
    const DHTMEM66_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM66 = Register(DHTMEM66_val).init(base_address + 0x464);

    /// DHTMEM67
    const DHTMEM67_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM67 = Register(DHTMEM67_val).init(base_address + 0x468);

    /// DHTMEM68
    const DHTMEM68_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM68 = Register(DHTMEM68_val).init(base_address + 0x46c);

    /// DHTMEM69
    const DHTMEM69_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM69 = Register(DHTMEM69_val).init(base_address + 0x470);

    /// DHTMEM70
    const DHTMEM70_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM70 = Register(DHTMEM70_val).init(base_address + 0x474);

    /// DHTMEM71
    const DHTMEM71_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM71 = Register(DHTMEM71_val).init(base_address + 0x478);

    /// DHTMEM72
    const DHTMEM72_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM72 = Register(DHTMEM72_val).init(base_address + 0x47c);

    /// DHTMEM73
    const DHTMEM73_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM73 = Register(DHTMEM73_val).init(base_address + 0x480);

    /// DHTMEM74
    const DHTMEM74_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM74 = Register(DHTMEM74_val).init(base_address + 0x484);

    /// DHTMEM75
    const DHTMEM75_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM75 = Register(DHTMEM75_val).init(base_address + 0x488);

    /// DHTMEM76
    const DHTMEM76_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM76 = Register(DHTMEM76_val).init(base_address + 0x48c);

    /// DHTMEM77
    const DHTMEM77_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM77 = Register(DHTMEM77_val).init(base_address + 0x490);

    /// DHTMEM78
    const DHTMEM78_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM78 = Register(DHTMEM78_val).init(base_address + 0x494);

    /// DHTMEM79
    const DHTMEM79_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM79 = Register(DHTMEM79_val).init(base_address + 0x498);

    /// DHTMEM80
    const DHTMEM80_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM80 = Register(DHTMEM80_val).init(base_address + 0x49c);

    /// DHTMEM81
    const DHTMEM81_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM81 = Register(DHTMEM81_val).init(base_address + 0x4a0);

    /// DHTMEM82
    const DHTMEM82_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM82 = Register(DHTMEM82_val).init(base_address + 0x4a4);

    /// DHTMEM83
    const DHTMEM83_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM83 = Register(DHTMEM83_val).init(base_address + 0x4a8);

    /// DHTMEM84
    const DHTMEM84_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM84 = Register(DHTMEM84_val).init(base_address + 0x4ac);

    /// DHTMEM85
    const DHTMEM85_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM85 = Register(DHTMEM85_val).init(base_address + 0x4b0);

    /// DHTMEM86
    const DHTMEM86_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM86 = Register(DHTMEM86_val).init(base_address + 0x4b4);

    /// DHTMEM87
    const DHTMEM87_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM87 = Register(DHTMEM87_val).init(base_address + 0x4b8);

    /// DHTMEM88
    const DHTMEM88_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM88 = Register(DHTMEM88_val).init(base_address + 0x4bc);

    /// DHTMEM89
    const DHTMEM89_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM89 = Register(DHTMEM89_val).init(base_address + 0x4c0);

    /// DHTMEM90
    const DHTMEM90_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM90 = Register(DHTMEM90_val).init(base_address + 0x4c4);

    /// DHTMEM91
    const DHTMEM91_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM91 = Register(DHTMEM91_val).init(base_address + 0x4c8);

    /// DHTMEM92
    const DHTMEM92_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM92 = Register(DHTMEM92_val).init(base_address + 0x4cc);

    /// DHTMEM93
    const DHTMEM93_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM93 = Register(DHTMEM93_val).init(base_address + 0x4d0);

    /// DHTMEM94
    const DHTMEM94_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM94 = Register(DHTMEM94_val).init(base_address + 0x4d4);

    /// DHTMEM95
    const DHTMEM95_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM95 = Register(DHTMEM95_val).init(base_address + 0x4d8);

    /// DHTMEM96
    const DHTMEM96_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM96 = Register(DHTMEM96_val).init(base_address + 0x4dc);

    /// DHTMEM97
    const DHTMEM97_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM97 = Register(DHTMEM97_val).init(base_address + 0x4e0);

    /// DHTMEM98
    const DHTMEM98_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM98 = Register(DHTMEM98_val).init(base_address + 0x4e4);

    /// DHTMEM99
    const DHTMEM99_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM99 = Register(DHTMEM99_val).init(base_address + 0x4e8);

    /// DHTMEM100
    const DHTMEM100_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM100 = Register(DHTMEM100_val).init(base_address + 0x4ec);

    /// DHTMEM101
    const DHTMEM101_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM101 = Register(DHTMEM101_val).init(base_address + 0x4f0);

    /// DHTMEM102
    const DHTMEM102_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM102 = Register(DHTMEM102_val).init(base_address + 0x4f4);

    /// DHTMEM103
    const DHTMEM103_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG DHTMem tables
    pub const DHTMEM103 = Register(DHTMEM103_val).init(base_address + 0x4f8);

    /// HUFFENC_AC0_0
    const HUFFENC_AC0_0_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_0 = Register(HUFFENC_AC0_0_val).init(base_address + 0x500);

    /// HUFFENC_AC0_1
    const HUFFENC_AC0_1_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_1 = Register(HUFFENC_AC0_1_val).init(base_address + 0x504);

    /// HUFFENC_AC0_2
    const HUFFENC_AC0_2_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_2 = Register(HUFFENC_AC0_2_val).init(base_address + 0x508);

    /// HUFFENC_AC0_3
    const HUFFENC_AC0_3_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_3 = Register(HUFFENC_AC0_3_val).init(base_address + 0x50c);

    /// HUFFENC_AC0_4
    const HUFFENC_AC0_4_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_4 = Register(HUFFENC_AC0_4_val).init(base_address + 0x510);

    /// HUFFENC_AC0_5
    const HUFFENC_AC0_5_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_5 = Register(HUFFENC_AC0_5_val).init(base_address + 0x514);

    /// HUFFENC_AC0_6
    const HUFFENC_AC0_6_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_6 = Register(HUFFENC_AC0_6_val).init(base_address + 0x518);

    /// HUFFENC_AC0_7
    const HUFFENC_AC0_7_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_7 = Register(HUFFENC_AC0_7_val).init(base_address + 0x51c);

    /// HUFFENC_AC0_8
    const HUFFENC_AC0_8_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_8 = Register(HUFFENC_AC0_8_val).init(base_address + 0x520);

    /// HUFFENC_AC0_9
    const HUFFENC_AC0_9_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_9 = Register(HUFFENC_AC0_9_val).init(base_address + 0x524);

    /// HUFFENC_AC0_10
    const HUFFENC_AC0_10_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_10 = Register(HUFFENC_AC0_10_val).init(base_address + 0x528);

    /// HUFFENC_AC0_11
    const HUFFENC_AC0_11_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_11 = Register(HUFFENC_AC0_11_val).init(base_address + 0x52c);

    /// HUFFENC_AC0_12
    const HUFFENC_AC0_12_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_12 = Register(HUFFENC_AC0_12_val).init(base_address + 0x530);

    /// HUFFENC_AC0_13
    const HUFFENC_AC0_13_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_13 = Register(HUFFENC_AC0_13_val).init(base_address + 0x534);

    /// HUFFENC_AC0_14
    const HUFFENC_AC0_14_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_14 = Register(HUFFENC_AC0_14_val).init(base_address + 0x538);

    /// HUFFENC_AC0_15
    const HUFFENC_AC0_15_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_15 = Register(HUFFENC_AC0_15_val).init(base_address + 0x53c);

    /// HUFFENC_AC0_16
    const HUFFENC_AC0_16_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_16 = Register(HUFFENC_AC0_16_val).init(base_address + 0x540);

    /// HUFFENC_AC0_17
    const HUFFENC_AC0_17_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_17 = Register(HUFFENC_AC0_17_val).init(base_address + 0x544);

    /// HUFFENC_AC0_18
    const HUFFENC_AC0_18_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_18 = Register(HUFFENC_AC0_18_val).init(base_address + 0x548);

    /// HUFFENC_AC0_19
    const HUFFENC_AC0_19_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_19 = Register(HUFFENC_AC0_19_val).init(base_address + 0x54c);

    /// HUFFENC_AC0_20
    const HUFFENC_AC0_20_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_20 = Register(HUFFENC_AC0_20_val).init(base_address + 0x550);

    /// HUFFENC_AC0_21
    const HUFFENC_AC0_21_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_21 = Register(HUFFENC_AC0_21_val).init(base_address + 0x554);

    /// HUFFENC_AC0_22
    const HUFFENC_AC0_22_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_22 = Register(HUFFENC_AC0_22_val).init(base_address + 0x558);

    /// HUFFENC_AC0_23
    const HUFFENC_AC0_23_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_23 = Register(HUFFENC_AC0_23_val).init(base_address + 0x55c);

    /// HUFFENC_AC0_24
    const HUFFENC_AC0_24_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_24 = Register(HUFFENC_AC0_24_val).init(base_address + 0x560);

    /// HUFFENC_AC0_25
    const HUFFENC_AC0_25_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_25 = Register(HUFFENC_AC0_25_val).init(base_address + 0x564);

    /// HUFFENC_AC0_26
    const HUFFENC_AC0_26_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_26 = Register(HUFFENC_AC0_26_val).init(base_address + 0x568);

    /// HUFFENC_AC0_27
    const HUFFENC_AC0_27_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_27 = Register(HUFFENC_AC0_27_val).init(base_address + 0x56c);

    /// HUFFENC_AC0_28
    const HUFFENC_AC0_28_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_28 = Register(HUFFENC_AC0_28_val).init(base_address + 0x570);

    /// HUFFENC_AC0_29
    const HUFFENC_AC0_29_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_29 = Register(HUFFENC_AC0_29_val).init(base_address + 0x574);

    /// HUFFENC_AC0_30
    const HUFFENC_AC0_30_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_30 = Register(HUFFENC_AC0_30_val).init(base_address + 0x578);

    /// HUFFENC_AC0_31
    const HUFFENC_AC0_31_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_31 = Register(HUFFENC_AC0_31_val).init(base_address + 0x57c);

    /// HUFFENC_AC0_32
    const HUFFENC_AC0_32_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_32 = Register(HUFFENC_AC0_32_val).init(base_address + 0x580);

    /// HUFFENC_AC0_33
    const HUFFENC_AC0_33_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_33 = Register(HUFFENC_AC0_33_val).init(base_address + 0x584);

    /// HUFFENC_AC0_34
    const HUFFENC_AC0_34_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_34 = Register(HUFFENC_AC0_34_val).init(base_address + 0x588);

    /// HUFFENC_AC0_35
    const HUFFENC_AC0_35_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_35 = Register(HUFFENC_AC0_35_val).init(base_address + 0x58c);

    /// HUFFENC_AC0_36
    const HUFFENC_AC0_36_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_36 = Register(HUFFENC_AC0_36_val).init(base_address + 0x590);

    /// HUFFENC_AC0_37
    const HUFFENC_AC0_37_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_37 = Register(HUFFENC_AC0_37_val).init(base_address + 0x594);

    /// HUFFENC_AC0_38
    const HUFFENC_AC0_38_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_38 = Register(HUFFENC_AC0_38_val).init(base_address + 0x598);

    /// HUFFENC_AC0_39
    const HUFFENC_AC0_39_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_39 = Register(HUFFENC_AC0_39_val).init(base_address + 0x59c);

    /// HUFFENC_AC0_40
    const HUFFENC_AC0_40_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_40 = Register(HUFFENC_AC0_40_val).init(base_address + 0x5a0);

    /// HUFFENC_AC0_41
    const HUFFENC_AC0_41_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_41 = Register(HUFFENC_AC0_41_val).init(base_address + 0x5a4);

    /// HUFFENC_AC0_42
    const HUFFENC_AC0_42_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_42 = Register(HUFFENC_AC0_42_val).init(base_address + 0x5a8);

    /// HUFFENC_AC0_43
    const HUFFENC_AC0_43_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_43 = Register(HUFFENC_AC0_43_val).init(base_address + 0x5ac);

    /// HUFFENC_AC0_44
    const HUFFENC_AC0_44_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_44 = Register(HUFFENC_AC0_44_val).init(base_address + 0x5b0);

    /// HUFFENC_AC0_45
    const HUFFENC_AC0_45_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_45 = Register(HUFFENC_AC0_45_val).init(base_address + 0x5b4);

    /// HUFFENC_AC0_46
    const HUFFENC_AC0_46_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_46 = Register(HUFFENC_AC0_46_val).init(base_address + 0x5b8);

    /// HUFFENC_AC0_47
    const HUFFENC_AC0_47_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_47 = Register(HUFFENC_AC0_47_val).init(base_address + 0x5bc);

    /// HUFFENC_AC0_48
    const HUFFENC_AC0_48_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_48 = Register(HUFFENC_AC0_48_val).init(base_address + 0x5c0);

    /// HUFFENC_AC0_49
    const HUFFENC_AC0_49_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_49 = Register(HUFFENC_AC0_49_val).init(base_address + 0x5c4);

    /// HUFFENC_AC0_50
    const HUFFENC_AC0_50_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_50 = Register(HUFFENC_AC0_50_val).init(base_address + 0x5c8);

    /// HUFFENC_AC0_51
    const HUFFENC_AC0_51_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_51 = Register(HUFFENC_AC0_51_val).init(base_address + 0x5cc);

    /// HUFFENC_AC0_52
    const HUFFENC_AC0_52_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_52 = Register(HUFFENC_AC0_52_val).init(base_address + 0x5d0);

    /// HUFFENC_AC0_53
    const HUFFENC_AC0_53_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_53 = Register(HUFFENC_AC0_53_val).init(base_address + 0x5d4);

    /// HUFFENC_AC0_54
    const HUFFENC_AC0_54_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_54 = Register(HUFFENC_AC0_54_val).init(base_address + 0x5d8);

    /// HUFFENC_AC0_55
    const HUFFENC_AC0_55_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_55 = Register(HUFFENC_AC0_55_val).init(base_address + 0x5dc);

    /// HUFFENC_AC0_56
    const HUFFENC_AC0_56_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_56 = Register(HUFFENC_AC0_56_val).init(base_address + 0x5e0);

    /// HUFFENC_AC0_57
    const HUFFENC_AC0_57_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_57 = Register(HUFFENC_AC0_57_val).init(base_address + 0x5e4);

    /// HUFFENC_AC0_58
    const HUFFENC_AC0_58_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_58 = Register(HUFFENC_AC0_58_val).init(base_address + 0x5e8);

    /// HUFFENC_AC0_59
    const HUFFENC_AC0_59_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_59 = Register(HUFFENC_AC0_59_val).init(base_address + 0x5ec);

    /// HUFFENC_AC0_60
    const HUFFENC_AC0_60_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_60 = Register(HUFFENC_AC0_60_val).init(base_address + 0x5f0);

    /// HUFFENC_AC0_61
    const HUFFENC_AC0_61_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_61 = Register(HUFFENC_AC0_61_val).init(base_address + 0x5f4);

    /// HUFFENC_AC0_62
    const HUFFENC_AC0_62_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_62 = Register(HUFFENC_AC0_62_val).init(base_address + 0x5f8);

    /// HUFFENC_AC0_63
    const HUFFENC_AC0_63_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_63 = Register(HUFFENC_AC0_63_val).init(base_address + 0x5fc);

    /// HUFFENC_AC0_64
    const HUFFENC_AC0_64_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_64 = Register(HUFFENC_AC0_64_val).init(base_address + 0x600);

    /// HUFFENC_AC0_65
    const HUFFENC_AC0_65_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_65 = Register(HUFFENC_AC0_65_val).init(base_address + 0x604);

    /// HUFFENC_AC0_66
    const HUFFENC_AC0_66_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_66 = Register(HUFFENC_AC0_66_val).init(base_address + 0x608);

    /// HUFFENC_AC0_67
    const HUFFENC_AC0_67_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_67 = Register(HUFFENC_AC0_67_val).init(base_address + 0x60c);

    /// HUFFENC_AC0_68
    const HUFFENC_AC0_68_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_68 = Register(HUFFENC_AC0_68_val).init(base_address + 0x610);

    /// HUFFENC_AC0_69
    const HUFFENC_AC0_69_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_69 = Register(HUFFENC_AC0_69_val).init(base_address + 0x614);

    /// HUFFENC_AC0_70
    const HUFFENC_AC0_70_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_70 = Register(HUFFENC_AC0_70_val).init(base_address + 0x618);

    /// HUFFENC_AC0_71
    const HUFFENC_AC0_71_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_71 = Register(HUFFENC_AC0_71_val).init(base_address + 0x61c);

    /// HUFFENC_AC0_72
    const HUFFENC_AC0_72_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_72 = Register(HUFFENC_AC0_72_val).init(base_address + 0x620);

    /// HUFFENC_AC0_73
    const HUFFENC_AC0_73_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_73 = Register(HUFFENC_AC0_73_val).init(base_address + 0x624);

    /// HUFFENC_AC0_74
    const HUFFENC_AC0_74_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_74 = Register(HUFFENC_AC0_74_val).init(base_address + 0x628);

    /// HUFFENC_AC0_75
    const HUFFENC_AC0_75_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_75 = Register(HUFFENC_AC0_75_val).init(base_address + 0x62c);

    /// HUFFENC_AC0_76
    const HUFFENC_AC0_76_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_76 = Register(HUFFENC_AC0_76_val).init(base_address + 0x630);

    /// HUFFENC_AC0_77
    const HUFFENC_AC0_77_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_77 = Register(HUFFENC_AC0_77_val).init(base_address + 0x634);

    /// HUFFENC_AC0_78
    const HUFFENC_AC0_78_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_78 = Register(HUFFENC_AC0_78_val).init(base_address + 0x638);

    /// HUFFENC_AC0_79
    const HUFFENC_AC0_79_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_79 = Register(HUFFENC_AC0_79_val).init(base_address + 0x63c);

    /// HUFFENC_AC0_80
    const HUFFENC_AC0_80_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_80 = Register(HUFFENC_AC0_80_val).init(base_address + 0x640);

    /// HUFFENC_AC0_81
    const HUFFENC_AC0_81_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_81 = Register(HUFFENC_AC0_81_val).init(base_address + 0x644);

    /// HUFFENC_AC0_82
    const HUFFENC_AC0_82_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_82 = Register(HUFFENC_AC0_82_val).init(base_address + 0x648);

    /// HUFFENC_AC0_83
    const HUFFENC_AC0_83_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_83 = Register(HUFFENC_AC0_83_val).init(base_address + 0x64c);

    /// HUFFENC_AC0_84
    const HUFFENC_AC0_84_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_84 = Register(HUFFENC_AC0_84_val).init(base_address + 0x650);

    /// HUFFENC_AC0_85
    const HUFFENC_AC0_85_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_85 = Register(HUFFENC_AC0_85_val).init(base_address + 0x654);

    /// HUFFENC_AC0_86
    const HUFFENC_AC0_86_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_86 = Register(HUFFENC_AC0_86_val).init(base_address + 0x658);

    /// HUFFENC_AC0_87
    const HUFFENC_AC0_87_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC0_87 = Register(HUFFENC_AC0_87_val).init(base_address + 0x65c);

    /// HUFFENC_AC1_0
    const HUFFENC_AC1_0_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_0 = Register(HUFFENC_AC1_0_val).init(base_address + 0x660);

    /// HUFFENC_AC1_1
    const HUFFENC_AC1_1_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_1 = Register(HUFFENC_AC1_1_val).init(base_address + 0x664);

    /// HUFFENC_AC1_2
    const HUFFENC_AC1_2_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_2 = Register(HUFFENC_AC1_2_val).init(base_address + 0x668);

    /// HUFFENC_AC1_3
    const HUFFENC_AC1_3_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_3 = Register(HUFFENC_AC1_3_val).init(base_address + 0x66c);

    /// HUFFENC_AC1_4
    const HUFFENC_AC1_4_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_4 = Register(HUFFENC_AC1_4_val).init(base_address + 0x670);

    /// HUFFENC_AC1_5
    const HUFFENC_AC1_5_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_5 = Register(HUFFENC_AC1_5_val).init(base_address + 0x674);

    /// HUFFENC_AC1_6
    const HUFFENC_AC1_6_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_6 = Register(HUFFENC_AC1_6_val).init(base_address + 0x678);

    /// HUFFENC_AC1_7
    const HUFFENC_AC1_7_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_7 = Register(HUFFENC_AC1_7_val).init(base_address + 0x67c);

    /// HUFFENC_AC1_8
    const HUFFENC_AC1_8_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_8 = Register(HUFFENC_AC1_8_val).init(base_address + 0x680);

    /// HUFFENC_AC1_9
    const HUFFENC_AC1_9_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_9 = Register(HUFFENC_AC1_9_val).init(base_address + 0x684);

    /// HUFFENC_AC1_10
    const HUFFENC_AC1_10_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_10 = Register(HUFFENC_AC1_10_val).init(base_address + 0x688);

    /// HUFFENC_AC1_11
    const HUFFENC_AC1_11_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_11 = Register(HUFFENC_AC1_11_val).init(base_address + 0x68c);

    /// HUFFENC_AC1_12
    const HUFFENC_AC1_12_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_12 = Register(HUFFENC_AC1_12_val).init(base_address + 0x690);

    /// HUFFENC_AC1_13
    const HUFFENC_AC1_13_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_13 = Register(HUFFENC_AC1_13_val).init(base_address + 0x694);

    /// HUFFENC_AC1_14
    const HUFFENC_AC1_14_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_14 = Register(HUFFENC_AC1_14_val).init(base_address + 0x698);

    /// HUFFENC_AC1_15
    const HUFFENC_AC1_15_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_15 = Register(HUFFENC_AC1_15_val).init(base_address + 0x69c);

    /// HUFFENC_AC1_16
    const HUFFENC_AC1_16_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_16 = Register(HUFFENC_AC1_16_val).init(base_address + 0x6a0);

    /// HUFFENC_AC1_17
    const HUFFENC_AC1_17_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_17 = Register(HUFFENC_AC1_17_val).init(base_address + 0x6a4);

    /// HUFFENC_AC1_18
    const HUFFENC_AC1_18_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_18 = Register(HUFFENC_AC1_18_val).init(base_address + 0x6a8);

    /// HUFFENC_AC1_19
    const HUFFENC_AC1_19_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_19 = Register(HUFFENC_AC1_19_val).init(base_address + 0x6ac);

    /// HUFFENC_AC1_20
    const HUFFENC_AC1_20_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_20 = Register(HUFFENC_AC1_20_val).init(base_address + 0x6b0);

    /// HUFFENC_AC1_21
    const HUFFENC_AC1_21_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_21 = Register(HUFFENC_AC1_21_val).init(base_address + 0x6b4);

    /// HUFFENC_AC1_22
    const HUFFENC_AC1_22_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_22 = Register(HUFFENC_AC1_22_val).init(base_address + 0x6b8);

    /// HUFFENC_AC1_23
    const HUFFENC_AC1_23_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_23 = Register(HUFFENC_AC1_23_val).init(base_address + 0x6bc);

    /// HUFFENC_AC1_24
    const HUFFENC_AC1_24_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_24 = Register(HUFFENC_AC1_24_val).init(base_address + 0x6c0);

    /// HUFFENC_AC1_25
    const HUFFENC_AC1_25_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_25 = Register(HUFFENC_AC1_25_val).init(base_address + 0x6c4);

    /// HUFFENC_AC1_26
    const HUFFENC_AC1_26_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_26 = Register(HUFFENC_AC1_26_val).init(base_address + 0x6c8);

    /// HUFFENC_AC1_27
    const HUFFENC_AC1_27_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_27 = Register(HUFFENC_AC1_27_val).init(base_address + 0x6cc);

    /// HUFFENC_AC1_28
    const HUFFENC_AC1_28_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_28 = Register(HUFFENC_AC1_28_val).init(base_address + 0x6d0);

    /// HUFFENC_AC1_29
    const HUFFENC_AC1_29_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_29 = Register(HUFFENC_AC1_29_val).init(base_address + 0x6d4);

    /// HUFFENC_AC1_30
    const HUFFENC_AC1_30_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_30 = Register(HUFFENC_AC1_30_val).init(base_address + 0x6d8);

    /// HUFFENC_AC1_31
    const HUFFENC_AC1_31_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_31 = Register(HUFFENC_AC1_31_val).init(base_address + 0x6dc);

    /// HUFFENC_AC1_32
    const HUFFENC_AC1_32_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_32 = Register(HUFFENC_AC1_32_val).init(base_address + 0x6e0);

    /// HUFFENC_AC1_33
    const HUFFENC_AC1_33_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_33 = Register(HUFFENC_AC1_33_val).init(base_address + 0x6e4);

    /// HUFFENC_AC1_34
    const HUFFENC_AC1_34_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_34 = Register(HUFFENC_AC1_34_val).init(base_address + 0x6e8);

    /// HUFFENC_AC1_35
    const HUFFENC_AC1_35_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_35 = Register(HUFFENC_AC1_35_val).init(base_address + 0x6ec);

    /// HUFFENC_AC1_36
    const HUFFENC_AC1_36_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_36 = Register(HUFFENC_AC1_36_val).init(base_address + 0x6f0);

    /// HUFFENC_AC1_37
    const HUFFENC_AC1_37_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_37 = Register(HUFFENC_AC1_37_val).init(base_address + 0x6f4);

    /// HUFFENC_AC1_38
    const HUFFENC_AC1_38_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_38 = Register(HUFFENC_AC1_38_val).init(base_address + 0x6f8);

    /// HUFFENC_AC1_39
    const HUFFENC_AC1_39_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_39 = Register(HUFFENC_AC1_39_val).init(base_address + 0x6fc);

    /// HUFFENC_AC1_40
    const HUFFENC_AC1_40_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_40 = Register(HUFFENC_AC1_40_val).init(base_address + 0x700);

    /// HUFFENC_AC1_41
    const HUFFENC_AC1_41_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_41 = Register(HUFFENC_AC1_41_val).init(base_address + 0x704);

    /// HUFFENC_AC1_42
    const HUFFENC_AC1_42_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_42 = Register(HUFFENC_AC1_42_val).init(base_address + 0x708);

    /// HUFFENC_AC1_43
    const HUFFENC_AC1_43_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_43 = Register(HUFFENC_AC1_43_val).init(base_address + 0x70c);

    /// HUFFENC_AC1_44
    const HUFFENC_AC1_44_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_44 = Register(HUFFENC_AC1_44_val).init(base_address + 0x710);

    /// HUFFENC_AC1_45
    const HUFFENC_AC1_45_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_45 = Register(HUFFENC_AC1_45_val).init(base_address + 0x714);

    /// HUFFENC_AC1_46
    const HUFFENC_AC1_46_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_46 = Register(HUFFENC_AC1_46_val).init(base_address + 0x718);

    /// HUFFENC_AC1_47
    const HUFFENC_AC1_47_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_47 = Register(HUFFENC_AC1_47_val).init(base_address + 0x71c);

    /// HUFFENC_AC1_48
    const HUFFENC_AC1_48_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_48 = Register(HUFFENC_AC1_48_val).init(base_address + 0x720);

    /// HUFFENC_AC1_49
    const HUFFENC_AC1_49_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_49 = Register(HUFFENC_AC1_49_val).init(base_address + 0x724);

    /// HUFFENC_AC1_50
    const HUFFENC_AC1_50_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_50 = Register(HUFFENC_AC1_50_val).init(base_address + 0x728);

    /// HUFFENC_AC1_51
    const HUFFENC_AC1_51_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_51 = Register(HUFFENC_AC1_51_val).init(base_address + 0x72c);

    /// HUFFENC_AC1_52
    const HUFFENC_AC1_52_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_52 = Register(HUFFENC_AC1_52_val).init(base_address + 0x730);

    /// HUFFENC_AC1_53
    const HUFFENC_AC1_53_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_53 = Register(HUFFENC_AC1_53_val).init(base_address + 0x734);

    /// HUFFENC_AC1_54
    const HUFFENC_AC1_54_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_54 = Register(HUFFENC_AC1_54_val).init(base_address + 0x738);

    /// HUFFENC_AC1_55
    const HUFFENC_AC1_55_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_55 = Register(HUFFENC_AC1_55_val).init(base_address + 0x73c);

    /// HUFFENC_AC1_56
    const HUFFENC_AC1_56_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_56 = Register(HUFFENC_AC1_56_val).init(base_address + 0x740);

    /// HUFFENC_AC1_57
    const HUFFENC_AC1_57_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_57 = Register(HUFFENC_AC1_57_val).init(base_address + 0x744);

    /// HUFFENC_AC1_58
    const HUFFENC_AC1_58_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_58 = Register(HUFFENC_AC1_58_val).init(base_address + 0x748);

    /// HUFFENC_AC1_59
    const HUFFENC_AC1_59_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_59 = Register(HUFFENC_AC1_59_val).init(base_address + 0x74c);

    /// HUFFENC_AC1_60
    const HUFFENC_AC1_60_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_60 = Register(HUFFENC_AC1_60_val).init(base_address + 0x750);

    /// HUFFENC_AC1_61
    const HUFFENC_AC1_61_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_61 = Register(HUFFENC_AC1_61_val).init(base_address + 0x754);

    /// HUFFENC_AC1_62
    const HUFFENC_AC1_62_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_62 = Register(HUFFENC_AC1_62_val).init(base_address + 0x758);

    /// HUFFENC_AC1_63
    const HUFFENC_AC1_63_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_63 = Register(HUFFENC_AC1_63_val).init(base_address + 0x75c);

    /// HUFFENC_AC1_64
    const HUFFENC_AC1_64_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_64 = Register(HUFFENC_AC1_64_val).init(base_address + 0x760);

    /// HUFFENC_AC1_65
    const HUFFENC_AC1_65_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_65 = Register(HUFFENC_AC1_65_val).init(base_address + 0x764);

    /// HUFFENC_AC1_66
    const HUFFENC_AC1_66_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_66 = Register(HUFFENC_AC1_66_val).init(base_address + 0x768);

    /// HUFFENC_AC1_67
    const HUFFENC_AC1_67_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_67 = Register(HUFFENC_AC1_67_val).init(base_address + 0x76c);

    /// HUFFENC_AC1_68
    const HUFFENC_AC1_68_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_68 = Register(HUFFENC_AC1_68_val).init(base_address + 0x770);

    /// HUFFENC_AC1_69
    const HUFFENC_AC1_69_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_69 = Register(HUFFENC_AC1_69_val).init(base_address + 0x774);

    /// HUFFENC_AC1_70
    const HUFFENC_AC1_70_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_70 = Register(HUFFENC_AC1_70_val).init(base_address + 0x778);

    /// HUFFENC_AC1_71
    const HUFFENC_AC1_71_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_71 = Register(HUFFENC_AC1_71_val).init(base_address + 0x77c);

    /// HUFFENC_AC1_72
    const HUFFENC_AC1_72_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_72 = Register(HUFFENC_AC1_72_val).init(base_address + 0x780);

    /// HUFFENC_AC1_73
    const HUFFENC_AC1_73_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_73 = Register(HUFFENC_AC1_73_val).init(base_address + 0x784);

    /// HUFFENC_AC1_74
    const HUFFENC_AC1_74_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_74 = Register(HUFFENC_AC1_74_val).init(base_address + 0x788);

    /// HUFFENC_AC1_75
    const HUFFENC_AC1_75_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_75 = Register(HUFFENC_AC1_75_val).init(base_address + 0x78c);

    /// HUFFENC_AC1_76
    const HUFFENC_AC1_76_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_76 = Register(HUFFENC_AC1_76_val).init(base_address + 0x790);

    /// HUFFENC_AC1_77
    const HUFFENC_AC1_77_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_77 = Register(HUFFENC_AC1_77_val).init(base_address + 0x794);

    /// HUFFENC_AC1_78
    const HUFFENC_AC1_78_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_78 = Register(HUFFENC_AC1_78_val).init(base_address + 0x798);

    /// HUFFENC_AC1_79
    const HUFFENC_AC1_79_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_79 = Register(HUFFENC_AC1_79_val).init(base_address + 0x79c);

    /// HUFFENC_AC1_80
    const HUFFENC_AC1_80_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_80 = Register(HUFFENC_AC1_80_val).init(base_address + 0x7a0);

    /// HUFFENC_AC1_81
    const HUFFENC_AC1_81_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_81 = Register(HUFFENC_AC1_81_val).init(base_address + 0x7a4);

    /// HUFFENC_AC1_82
    const HUFFENC_AC1_82_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_82 = Register(HUFFENC_AC1_82_val).init(base_address + 0x7a8);

    /// HUFFENC_AC1_83
    const HUFFENC_AC1_83_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_83 = Register(HUFFENC_AC1_83_val).init(base_address + 0x7ac);

    /// HUFFENC_AC1_84
    const HUFFENC_AC1_84_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_84 = Register(HUFFENC_AC1_84_val).init(base_address + 0x7b0);

    /// HUFFENC_AC1_85
    const HUFFENC_AC1_85_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_85 = Register(HUFFENC_AC1_85_val).init(base_address + 0x7b4);

    /// HUFFENC_AC1_86
    const HUFFENC_AC1_86_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_86 = Register(HUFFENC_AC1_86_val).init(base_address + 0x7b8);

    /// HUFFENC_AC1_87
    const HUFFENC_AC1_87_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, AC Huffman table
    pub const HUFFENC_AC1_87 = Register(HUFFENC_AC1_87_val).init(base_address + 0x7bc);

    /// HUFFENC_DC0_0
    const HUFFENC_DC0_0_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_0 = Register(HUFFENC_DC0_0_val).init(base_address + 0x7c0);

    /// HUFFENC_DC0_1
    const HUFFENC_DC0_1_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_1 = Register(HUFFENC_DC0_1_val).init(base_address + 0x7c4);

    /// HUFFENC_DC0_2
    const HUFFENC_DC0_2_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_2 = Register(HUFFENC_DC0_2_val).init(base_address + 0x7c8);

    /// HUFFENC_DC0_3
    const HUFFENC_DC0_3_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_3 = Register(HUFFENC_DC0_3_val).init(base_address + 0x7cc);

    /// HUFFENC_DC0_4
    const HUFFENC_DC0_4_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_4 = Register(HUFFENC_DC0_4_val).init(base_address + 0x7d0);

    /// HUFFENC_DC0_5
    const HUFFENC_DC0_5_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_5 = Register(HUFFENC_DC0_5_val).init(base_address + 0x7d4);

    /// HUFFENC_DC0_6
    const HUFFENC_DC0_6_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_6 = Register(HUFFENC_DC0_6_val).init(base_address + 0x7d8);

    /// HUFFENC_DC0_7
    const HUFFENC_DC0_7_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC0_7 = Register(HUFFENC_DC0_7_val).init(base_address + 0x7dc);

    /// HUFFENC_DC1_0
    const HUFFENC_DC1_0_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_0 = Register(HUFFENC_DC1_0_val).init(base_address + 0x7e0);

    /// HUFFENC_DC1_1
    const HUFFENC_DC1_1_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_1 = Register(HUFFENC_DC1_1_val).init(base_address + 0x7e4);

    /// HUFFENC_DC1_2
    const HUFFENC_DC1_2_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_2 = Register(HUFFENC_DC1_2_val).init(base_address + 0x7e8);

    /// HUFFENC_DC1_3
    const HUFFENC_DC1_3_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_3 = Register(HUFFENC_DC1_3_val).init(base_address + 0x7ec);

    /// HUFFENC_DC1_4
    const HUFFENC_DC1_4_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_4 = Register(HUFFENC_DC1_4_val).init(base_address + 0x7f0);

    /// HUFFENC_DC1_5
    const HUFFENC_DC1_5_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_5 = Register(HUFFENC_DC1_5_val).init(base_address + 0x7f4);

    /// HUFFENC_DC1_6
    const HUFFENC_DC1_6_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_6 = Register(HUFFENC_DC1_6_val).init(base_address + 0x7f8);

    /// HUFFENC_DC1_7
    const HUFFENC_DC1_7_val = packed struct {
        /// DHTMem_RAM [0:31]
        /// DHTMem RAM
        DHTMem_RAM: u32 = 0,
    };
    /// JPEG encoder, DC Huffman table
    pub const HUFFENC_DC1_7 = Register(HUFFENC_DC1_7_val).init(base_address + 0x7fc);
};

/// Ethernet: MAC management counters
pub const Ethernet_MMC = struct {
    const base_address = 0x40028100;
    /// MMCCR
    const MMCCR_val = packed struct {
        /// CR [0:0]
        /// CR
        CR: u1 = 0,
        /// CSR [1:1]
        /// CSR
        CSR: u1 = 0,
        /// ROR [2:2]
        /// ROR
        ROR: u1 = 0,
        /// MCF [3:3]
        /// MCF
        MCF: u1 = 0,
        /// MCP [4:4]
        /// MCP
        MCP: u1 = 0,
        /// MCFHP [5:5]
        /// MCFHP
        MCFHP: u1 = 0,
        /// unused [6:31]
        _unused6: u2 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MMC control register
    pub const MMCCR = Register(MMCCR_val).init(base_address + 0x0);

    /// MMCRIR
    const MMCRIR_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// RFCES [5:5]
        /// RFCES
        RFCES: u1 = 0,
        /// RFAES [6:6]
        /// RFAES
        RFAES: u1 = 0,
        /// unused [7:16]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u1 = 0,
        /// RGUFS [17:17]
        /// RGUFS
        RGUFS: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MMC receive interrupt
    pub const MMCRIR = Register(MMCRIR_val).init(base_address + 0x4);

    /// MMCTIR
    const MMCTIR_val = packed struct {
        /// unused [0:13]
        _unused0: u8 = 0,
        _unused8: u6 = 0,
        /// TGFSCS [14:14]
        /// TGFSCS
        TGFSCS: u1 = 0,
        /// TGFMSCS [15:15]
        /// TGFMSCS
        TGFMSCS: u1 = 0,
        /// unused [16:20]
        _unused16: u5 = 0,
        /// TGFS [21:21]
        /// TGFS
        TGFS: u1 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MMC transmit interrupt
    pub const MMCTIR = Register(MMCTIR_val).init(base_address + 0x8);

    /// MMCRIMR
    const MMCRIMR_val = packed struct {
        /// unused [0:4]
        _unused0: u5 = 0,
        /// RFCEM [5:5]
        /// RFCEM
        RFCEM: u1 = 0,
        /// RFAEM [6:6]
        /// RFAEM
        RFAEM: u1 = 0,
        /// unused [7:16]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u1 = 0,
        /// RGUFM [17:17]
        /// RGUFM
        RGUFM: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MMC receive interrupt mask
    pub const MMCRIMR = Register(MMCRIMR_val).init(base_address + 0xc);

    /// MMCTIMR
    const MMCTIMR_val = packed struct {
        /// unused [0:13]
        _unused0: u8 = 0,
        _unused8: u6 = 0,
        /// TGFSCM [14:14]
        /// TGFSCM
        TGFSCM: u1 = 0,
        /// TGFMSCM [15:15]
        /// TGFMSCM
        TGFMSCM: u1 = 0,
        /// TGFM [16:16]
        /// TGFM
        TGFM: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet MMC transmit interrupt mask
    pub const MMCTIMR = Register(MMCTIMR_val).init(base_address + 0x10);

    /// MMCTGFSCCR
    const MMCTGFSCCR_val = packed struct {
        /// TGFSCC [0:31]
        /// TGFSCC
        TGFSCC: u32 = 0,
    };
    /// Ethernet MMC transmitted good frames after a
    pub const MMCTGFSCCR = Register(MMCTGFSCCR_val).init(base_address + 0x4c);

    /// MMCTGFMSCCR
    const MMCTGFMSCCR_val = packed struct {
        /// TGFMSCC [0:31]
        /// TGFMSCC
        TGFMSCC: u32 = 0,
    };
    /// Ethernet MMC transmitted good frames after
    pub const MMCTGFMSCCR = Register(MMCTGFMSCCR_val).init(base_address + 0x50);

    /// MMCTGFCR
    const MMCTGFCR_val = packed struct {
        /// TGFC [0:31]
        /// HTL
        TGFC: u32 = 0,
    };
    /// Ethernet MMC transmitted good frames counter
    pub const MMCTGFCR = Register(MMCTGFCR_val).init(base_address + 0x68);

    /// MMCRFCECR
    const MMCRFCECR_val = packed struct {
        /// RFCFC [0:31]
        /// RFCFC
        RFCFC: u32 = 0,
    };
    /// Ethernet MMC received frames with CRC error
    pub const MMCRFCECR = Register(MMCRFCECR_val).init(base_address + 0x94);

    /// MMCRFAECR
    const MMCRFAECR_val = packed struct {
        /// RFAEC [0:31]
        /// RFAEC
        RFAEC: u32 = 0,
    };
    /// Ethernet MMC received frames with alignment
    pub const MMCRFAECR = Register(MMCRFAECR_val).init(base_address + 0x98);

    /// MMCRGUFCR
    const MMCRGUFCR_val = packed struct {
        /// RGUFC [0:31]
        /// RGUFC
        RGUFC: u32 = 0,
    };
    /// MMC received good unicast frames counter
    pub const MMCRGUFCR = Register(MMCRGUFCR_val).init(base_address + 0xc4);
};

/// Ethernet: Precision time protocol
pub const Ethernet_PTP = struct {
    const base_address = 0x40028700;
    /// PTPTSCR
    const PTPTSCR_val = packed struct {
        /// TSE [0:0]
        /// TSE
        TSE: u1 = 0,
        /// TSFCU [1:1]
        /// TSFCU
        TSFCU: u1 = 0,
        /// TSSTI [2:2]
        /// TSSTI
        TSSTI: u1 = 0,
        /// TSSTU [3:3]
        /// TSSTU
        TSSTU: u1 = 0,
        /// TSITE [4:4]
        /// TSITE
        TSITE: u1 = 0,
        /// TTSARU [5:5]
        /// TTSARU
        TTSARU: u1 = 0,
        /// unused [6:7]
        _unused6: u2 = 0,
        /// TSSARFE [8:8]
        /// TSSARFE
        TSSARFE: u1 = 0,
        /// TSSSR [9:9]
        /// TSSSR
        TSSSR: u1 = 0,
        /// TSPTPPSV2E [10:10]
        /// TSPTPPSV2E
        TSPTPPSV2E: u1 = 0,
        /// TSSPTPOEFE [11:11]
        /// TSSPTPOEFE
        TSSPTPOEFE: u1 = 0,
        /// TSSIPV6FE [12:12]
        /// TSSIPV6FE
        TSSIPV6FE: u1 = 0,
        /// TSSIPV4FE [13:13]
        /// TSSIPV4FE
        TSSIPV4FE: u1 = 1,
        /// TSSEME [14:14]
        /// TSSEME
        TSSEME: u1 = 0,
        /// TSSMRME [15:15]
        /// TSSMRME
        TSSMRME: u1 = 0,
        /// TSCNT [16:17]
        /// TSCNT
        TSCNT: u2 = 0,
        /// TSPFFMAE [18:18]
        /// TSPFFMAE
        TSPFFMAE: u1 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet PTP time stamp control
    pub const PTPTSCR = Register(PTPTSCR_val).init(base_address + 0x0);

    /// PTPSSIR
    const PTPSSIR_val = packed struct {
        /// STSSI [0:7]
        /// STSSI
        STSSI: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet PTP subsecond increment
    pub const PTPSSIR = Register(PTPSSIR_val).init(base_address + 0x4);

    /// PTPTSHR
    const PTPTSHR_val = packed struct {
        /// STS [0:31]
        /// STS
        STS: u32 = 0,
    };
    /// Ethernet PTP time stamp high
    pub const PTPTSHR = Register(PTPTSHR_val).init(base_address + 0x8);

    /// PTPTSLR
    const PTPTSLR_val = packed struct {
        /// STSS [0:30]
        /// STSS
        STSS: u31 = 0,
        /// STPNS [31:31]
        /// STPNS
        STPNS: u1 = 0,
    };
    /// Ethernet PTP time stamp low
    pub const PTPTSLR = Register(PTPTSLR_val).init(base_address + 0xc);

    /// PTPTSHUR
    const PTPTSHUR_val = packed struct {
        /// TSUS [0:31]
        /// TSUS
        TSUS: u32 = 0,
    };
    /// Ethernet PTP time stamp high update
    pub const PTPTSHUR = Register(PTPTSHUR_val).init(base_address + 0x10);

    /// PTPTSLUR
    const PTPTSLUR_val = packed struct {
        /// TSUSS [0:30]
        /// TSUSS
        TSUSS: u31 = 0,
        /// TSUPNS [31:31]
        /// TSUPNS
        TSUPNS: u1 = 0,
    };
    /// Ethernet PTP time stamp low update
    pub const PTPTSLUR = Register(PTPTSLUR_val).init(base_address + 0x14);

    /// PTPTSAR
    const PTPTSAR_val = packed struct {
        /// TSA [0:31]
        /// TSA
        TSA: u32 = 0,
    };
    /// Ethernet PTP time stamp addend
    pub const PTPTSAR = Register(PTPTSAR_val).init(base_address + 0x18);

    /// PTPTTHR
    const PTPTTHR_val = packed struct {
        /// TTSH [0:31]
        /// 0
        TTSH: u32 = 0,
    };
    /// Ethernet PTP target time high
    pub const PTPTTHR = Register(PTPTTHR_val).init(base_address + 0x1c);

    /// PTPTTLR
    const PTPTTLR_val = packed struct {
        /// TTSL [0:31]
        /// TTSL
        TTSL: u32 = 0,
    };
    /// Ethernet PTP target time low
    pub const PTPTTLR = Register(PTPTTLR_val).init(base_address + 0x20);

    /// PTPTSSR
    const PTPTSSR_val = packed struct {
        /// TSSO [0:0]
        /// TSSO
        TSSO: u1 = 0,
        /// TSTTR [1:1]
        /// TSTTR
        TSTTR: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet PTP time stamp status
    pub const PTPTSSR = Register(PTPTSSR_val).init(base_address + 0x28);

    /// PTPPPSCR
    const PTPPPSCR_val = packed struct {
        /// TSSO [0:0]
        /// TSSO
        TSSO: u1 = 0,
        /// TSTTR [1:1]
        /// TSTTR
        TSTTR: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet PTP PPS control
    pub const PTPPPSCR = Register(PTPPPSCR_val).init(base_address + 0x2c);
};

/// Ethernet: DMA controller operation
pub const Ethernet_DMA = struct {
    const base_address = 0x40029000;
    /// DMABMR
    const DMABMR_val = packed struct {
        /// SR [0:0]
        /// SR
        SR: u1 = 1,
        /// DA [1:1]
        /// DA
        DA: u1 = 0,
        /// DSL [2:6]
        /// DSL
        DSL: u5 = 0,
        /// EDFE [7:7]
        /// EDFE
        EDFE: u1 = 0,
        /// PBL [8:13]
        /// PBL
        PBL: u6 = 33,
        /// RTPR [14:15]
        /// RTPR
        RTPR: u2 = 0,
        /// FB [16:16]
        /// FB
        FB: u1 = 0,
        /// RDP [17:22]
        /// RDP
        RDP: u6 = 0,
        /// USP [23:23]
        /// USP
        USP: u1 = 0,
        /// FPM [24:24]
        /// FPM
        FPM: u1 = 0,
        /// AAB [25:25]
        /// AAB
        AAB: u1 = 0,
        /// MB [26:26]
        /// MB
        MB: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Ethernet DMA bus mode register
    pub const DMABMR = Register(DMABMR_val).init(base_address + 0x0);

    /// DMATPDR
    const DMATPDR_val = packed struct {
        /// TPD [0:31]
        /// TPD
        TPD: u32 = 0,
    };
    /// Ethernet DMA transmit poll demand
    pub const DMATPDR = Register(DMATPDR_val).init(base_address + 0x4);

    /// DMARPDR
    const DMARPDR_val = packed struct {
        /// RPD [0:31]
        /// RPD
        RPD: u32 = 0,
    };
    /// EHERNET DMA receive poll demand
    pub const DMARPDR = Register(DMARPDR_val).init(base_address + 0x8);

    /// DMARDLAR
    const DMARDLAR_val = packed struct {
        /// SRL [0:31]
        /// SRL
        SRL: u32 = 0,
    };
    /// Ethernet DMA receive descriptor list address
    pub const DMARDLAR = Register(DMARDLAR_val).init(base_address + 0xc);

    /// DMATDLAR
    const DMATDLAR_val = packed struct {
        /// STL [0:31]
        /// STL
        STL: u32 = 0,
    };
    /// Ethernet DMA transmit descriptor list
    pub const DMATDLAR = Register(DMATDLAR_val).init(base_address + 0x10);

    /// DMASR
    const DMASR_val = packed struct {
        /// TS [0:0]
        /// TS
        TS: u1 = 0,
        /// TPSS [1:1]
        /// TPSS
        TPSS: u1 = 0,
        /// TBUS [2:2]
        /// TBUS
        TBUS: u1 = 0,
        /// TJTS [3:3]
        /// TJTS
        TJTS: u1 = 0,
        /// ROS [4:4]
        /// ROS
        ROS: u1 = 0,
        /// TUS [5:5]
        /// TUS
        TUS: u1 = 0,
        /// RS [6:6]
        /// RS
        RS: u1 = 0,
        /// RBUS [7:7]
        /// RBUS
        RBUS: u1 = 0,
        /// RPSS [8:8]
        /// RPSS
        RPSS: u1 = 0,
        /// PWTS [9:9]
        /// PWTS
        PWTS: u1 = 0,
        /// ETS [10:10]
        /// ETS
        ETS: u1 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// FBES [13:13]
        /// FBES
        FBES: u1 = 0,
        /// ERS [14:14]
        /// ERS
        ERS: u1 = 0,
        /// AIS [15:15]
        /// AIS
        AIS: u1 = 0,
        /// NIS [16:16]
        /// NIS
        NIS: u1 = 0,
        /// RPS [17:19]
        /// RPS
        RPS: u3 = 0,
        /// TPS [20:22]
        /// TPS
        TPS: u3 = 0,
        /// EBS [23:25]
        /// EBS
        EBS: u3 = 0,
        /// unused [26:26]
        _unused26: u1 = 0,
        /// MMCS [27:27]
        /// MMCS
        MMCS: u1 = 0,
        /// PMTS [28:28]
        /// PMTS
        PMTS: u1 = 0,
        /// TSTS [29:29]
        /// TSTS
        TSTS: u1 = 0,
        /// unused [30:31]
        _unused30: u2 = 0,
    };
    /// Ethernet DMA status register
    pub const DMASR = Register(DMASR_val).init(base_address + 0x14);

    /// DMAOMR
    const DMAOMR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// SR [1:1]
        /// SR
        SR: u1 = 0,
        /// OSF [2:2]
        /// OSF
        OSF: u1 = 0,
        /// RTC [3:4]
        /// RTC
        RTC: u2 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// FUGF [6:6]
        /// FUGF
        FUGF: u1 = 0,
        /// FEF [7:7]
        /// FEF
        FEF: u1 = 0,
        /// unused [8:12]
        _unused8: u5 = 0,
        /// ST [13:13]
        /// ST
        ST: u1 = 0,
        /// TTC [14:16]
        /// TTC
        TTC: u3 = 0,
        /// unused [17:19]
        _unused17: u3 = 0,
        /// FTF [20:20]
        /// FTF
        FTF: u1 = 0,
        /// TSF [21:21]
        /// TSF
        TSF: u1 = 0,
        /// unused [22:23]
        _unused22: u2 = 0,
        /// DFRF [24:24]
        /// DFRF
        DFRF: u1 = 0,
        /// RSF [25:25]
        /// RSF
        RSF: u1 = 0,
        /// DTCEFD [26:26]
        /// DTCEFD
        DTCEFD: u1 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// Ethernet DMA operation mode
    pub const DMAOMR = Register(DMAOMR_val).init(base_address + 0x18);

    /// DMAIER
    const DMAIER_val = packed struct {
        /// TIE [0:0]
        /// TIE
        TIE: u1 = 0,
        /// TPSIE [1:1]
        /// TPSIE
        TPSIE: u1 = 0,
        /// TBUIE [2:2]
        /// TBUIE
        TBUIE: u1 = 0,
        /// TJTIE [3:3]
        /// TJTIE
        TJTIE: u1 = 0,
        /// ROIE [4:4]
        /// ROIE
        ROIE: u1 = 0,
        /// TUIE [5:5]
        /// TUIE
        TUIE: u1 = 0,
        /// RIE [6:6]
        /// RIE
        RIE: u1 = 0,
        /// RBUIE [7:7]
        /// RBUIE
        RBUIE: u1 = 0,
        /// RPSIE [8:8]
        /// RPSIE
        RPSIE: u1 = 0,
        /// RWTIE [9:9]
        /// RWTIE
        RWTIE: u1 = 0,
        /// ETIE [10:10]
        /// ETIE
        ETIE: u1 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// FBEIE [13:13]
        /// FBEIE
        FBEIE: u1 = 0,
        /// ERIE [14:14]
        /// ERIE
        ERIE: u1 = 0,
        /// AISE [15:15]
        /// AISE
        AISE: u1 = 0,
        /// NISE [16:16]
        /// NISE
        NISE: u1 = 0,
        /// unused [17:31]
        _unused17: u7 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet DMA interrupt enable
    pub const DMAIER = Register(DMAIER_val).init(base_address + 0x1c);

    /// DMAMFBOCR
    const DMAMFBOCR_val = packed struct {
        /// MFC [0:15]
        /// MFC
        MFC: u16 = 0,
        /// OMFC [16:16]
        /// OMFC
        OMFC: u1 = 0,
        /// MFA [17:27]
        /// MFA
        MFA: u11 = 0,
        /// OFOC [28:28]
        /// OFOC
        OFOC: u1 = 0,
        /// unused [29:31]
        _unused29: u3 = 0,
    };
    /// Ethernet DMA missed frame and buffer
    pub const DMAMFBOCR = Register(DMAMFBOCR_val).init(base_address + 0x20);

    /// DMARSWTR
    const DMARSWTR_val = packed struct {
        /// RSWTC [0:7]
        /// RSWTC
        RSWTC: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Ethernet DMA receive status watchdog timer
    pub const DMARSWTR = Register(DMARSWTR_val).init(base_address + 0x24);

    /// DMACHTDR
    const DMACHTDR_val = packed struct {
        /// HTDAP [0:31]
        /// HTDAP
        HTDAP: u32 = 0,
    };
    /// Ethernet DMA current host transmit
    pub const DMACHTDR = Register(DMACHTDR_val).init(base_address + 0x48);

    /// DMACHRDR
    const DMACHRDR_val = packed struct {
        /// HRDAP [0:31]
        /// HRDAP
        HRDAP: u32 = 0,
    };
    /// Ethernet DMA current host receive descriptor
    pub const DMACHRDR = Register(DMACHRDR_val).init(base_address + 0x4c);

    /// DMACHTBAR
    const DMACHTBAR_val = packed struct {
        /// HTBAP [0:31]
        /// HTBAP
        HTBAP: u32 = 0,
    };
    /// Ethernet DMA current host transmit buffer
    pub const DMACHTBAR = Register(DMACHTBAR_val).init(base_address + 0x50);

    /// DMACHRBAR
    const DMACHRBAR_val = packed struct {
        /// HRBAP [0:31]
        /// HRBAP
        HRBAP: u32 = 0,
    };
    /// Ethernet DMA current host receive buffer
    pub const DMACHRBAR = Register(DMACHRBAR_val).init(base_address + 0x54);
};

/// USB on the go full speed
pub const OTG_FS_HOST = struct {
    const base_address = 0x50000400;
    /// OTG_FS_HCFG
    const OTG_FS_HCFG_val = packed struct {
        /// FSLSPCS [0:1]
        /// FS/LS PHY clock select
        FSLSPCS: u2 = 0,
        /// FSLSS [2:2]
        /// FS- and LS-only support
        FSLSS: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host configuration register
    pub const OTG_FS_HCFG = Register(OTG_FS_HCFG_val).init(base_address + 0x0);

    /// OTG_FS_HFIR
    const OTG_FS_HFIR_val = packed struct {
        /// FRIVL [0:15]
        /// Frame interval
        FRIVL: u16 = 60000,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS Host frame interval
    pub const OTG_FS_HFIR = Register(OTG_FS_HFIR_val).init(base_address + 0x4);

    /// OTG_FS_HFNUM
    const OTG_FS_HFNUM_val = packed struct {
        /// FRNUM [0:15]
        /// Frame number
        FRNUM: u16 = 16383,
        /// FTREM [16:31]
        /// Frame time remaining
        FTREM: u16 = 0,
    };
    /// OTG_FS host frame number/frame time
    pub const OTG_FS_HFNUM = Register(OTG_FS_HFNUM_val).init(base_address + 0x8);

    /// OTG_FS_HPTXSTS
    const OTG_FS_HPTXSTS_val = packed struct {
        /// PTXFSAVL [0:15]
        /// Periodic transmit data FIFO space
        PTXFSAVL: u16 = 256,
        /// PTXQSAV [16:23]
        /// Periodic transmit request queue space
        PTXQSAV: u8 = 8,
        /// PTXQTOP [24:31]
        /// Top of the periodic transmit request
        PTXQTOP: u8 = 0,
    };
    /// OTG_FS_Host periodic transmit FIFO/queue
    pub const OTG_FS_HPTXSTS = Register(OTG_FS_HPTXSTS_val).init(base_address + 0x10);

    /// OTG_FS_HAINT
    const OTG_FS_HAINT_val = packed struct {
        /// HAINT [0:15]
        /// Channel interrupts
        HAINT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS Host all channels interrupt
    pub const OTG_FS_HAINT = Register(OTG_FS_HAINT_val).init(base_address + 0x14);

    /// OTG_FS_HAINTMSK
    const OTG_FS_HAINTMSK_val = packed struct {
        /// HAINTM [0:15]
        /// Channel interrupt mask
        HAINTM: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host all channels interrupt mask
    pub const OTG_FS_HAINTMSK = Register(OTG_FS_HAINTMSK_val).init(base_address + 0x18);

    /// OTG_FS_HPRT
    const OTG_FS_HPRT_val = packed struct {
        /// PCSTS [0:0]
        /// Port connect status
        PCSTS: u1 = 0,
        /// PCDET [1:1]
        /// Port connect detected
        PCDET: u1 = 0,
        /// PENA [2:2]
        /// Port enable
        PENA: u1 = 0,
        /// PENCHNG [3:3]
        /// Port enable/disable change
        PENCHNG: u1 = 0,
        /// POCA [4:4]
        /// Port overcurrent active
        POCA: u1 = 0,
        /// POCCHNG [5:5]
        /// Port overcurrent change
        POCCHNG: u1 = 0,
        /// PRES [6:6]
        /// Port resume
        PRES: u1 = 0,
        /// PSUSP [7:7]
        /// Port suspend
        PSUSP: u1 = 0,
        /// PRST [8:8]
        /// Port reset
        PRST: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// PLSTS [10:11]
        /// Port line status
        PLSTS: u2 = 0,
        /// PPWR [12:12]
        /// Port power
        PPWR: u1 = 0,
        /// PTCTL [13:16]
        /// Port test control
        PTCTL: u4 = 0,
        /// PSPD [17:18]
        /// Port speed
        PSPD: u2 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host port control and status register
    pub const OTG_FS_HPRT = Register(OTG_FS_HPRT_val).init(base_address + 0x40);

    /// OTG_FS_HCCHAR0
    const OTG_FS_HCCHAR0_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-0 characteristics
    pub const OTG_FS_HCCHAR0 = Register(OTG_FS_HCCHAR0_val).init(base_address + 0x100);

    /// OTG_FS_HCCHAR1
    const OTG_FS_HCCHAR1_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-1 characteristics
    pub const OTG_FS_HCCHAR1 = Register(OTG_FS_HCCHAR1_val).init(base_address + 0x120);

    /// OTG_FS_HCCHAR2
    const OTG_FS_HCCHAR2_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-2 characteristics
    pub const OTG_FS_HCCHAR2 = Register(OTG_FS_HCCHAR2_val).init(base_address + 0x140);

    /// OTG_FS_HCCHAR3
    const OTG_FS_HCCHAR3_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-3 characteristics
    pub const OTG_FS_HCCHAR3 = Register(OTG_FS_HCCHAR3_val).init(base_address + 0x160);

    /// OTG_FS_HCCHAR4
    const OTG_FS_HCCHAR4_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-4 characteristics
    pub const OTG_FS_HCCHAR4 = Register(OTG_FS_HCCHAR4_val).init(base_address + 0x180);

    /// OTG_FS_HCCHAR5
    const OTG_FS_HCCHAR5_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-5 characteristics
    pub const OTG_FS_HCCHAR5 = Register(OTG_FS_HCCHAR5_val).init(base_address + 0x1a0);

    /// OTG_FS_HCCHAR6
    const OTG_FS_HCCHAR6_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-6 characteristics
    pub const OTG_FS_HCCHAR6 = Register(OTG_FS_HCCHAR6_val).init(base_address + 0x1c0);

    /// OTG_FS_HCCHAR7
    const OTG_FS_HCCHAR7_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-7 characteristics
    pub const OTG_FS_HCCHAR7 = Register(OTG_FS_HCCHAR7_val).init(base_address + 0x1e0);

    /// OTG_FS_HCINT0
    const OTG_FS_HCINT0_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-0 interrupt register
    pub const OTG_FS_HCINT0 = Register(OTG_FS_HCINT0_val).init(base_address + 0x108);

    /// OTG_FS_HCINT1
    const OTG_FS_HCINT1_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-1 interrupt register
    pub const OTG_FS_HCINT1 = Register(OTG_FS_HCINT1_val).init(base_address + 0x128);

    /// OTG_FS_HCINT2
    const OTG_FS_HCINT2_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-2 interrupt register
    pub const OTG_FS_HCINT2 = Register(OTG_FS_HCINT2_val).init(base_address + 0x148);

    /// OTG_FS_HCINT3
    const OTG_FS_HCINT3_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-3 interrupt register
    pub const OTG_FS_HCINT3 = Register(OTG_FS_HCINT3_val).init(base_address + 0x168);

    /// OTG_FS_HCINT4
    const OTG_FS_HCINT4_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-4 interrupt register
    pub const OTG_FS_HCINT4 = Register(OTG_FS_HCINT4_val).init(base_address + 0x188);

    /// OTG_FS_HCINT5
    const OTG_FS_HCINT5_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-5 interrupt register
    pub const OTG_FS_HCINT5 = Register(OTG_FS_HCINT5_val).init(base_address + 0x1a8);

    /// OTG_FS_HCINT6
    const OTG_FS_HCINT6_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-6 interrupt register
    pub const OTG_FS_HCINT6 = Register(OTG_FS_HCINT6_val).init(base_address + 0x1c8);

    /// OTG_FS_HCINT7
    const OTG_FS_HCINT7_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-7 interrupt register
    pub const OTG_FS_HCINT7 = Register(OTG_FS_HCINT7_val).init(base_address + 0x1e8);

    /// OTG_FS_HCINTMSK0
    const OTG_FS_HCINTMSK0_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-0 mask register
    pub const OTG_FS_HCINTMSK0 = Register(OTG_FS_HCINTMSK0_val).init(base_address + 0x10c);

    /// OTG_FS_HCINTMSK1
    const OTG_FS_HCINTMSK1_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-1 mask register
    pub const OTG_FS_HCINTMSK1 = Register(OTG_FS_HCINTMSK1_val).init(base_address + 0x12c);

    /// OTG_FS_HCINTMSK2
    const OTG_FS_HCINTMSK2_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-2 mask register
    pub const OTG_FS_HCINTMSK2 = Register(OTG_FS_HCINTMSK2_val).init(base_address + 0x14c);

    /// OTG_FS_HCINTMSK3
    const OTG_FS_HCINTMSK3_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-3 mask register
    pub const OTG_FS_HCINTMSK3 = Register(OTG_FS_HCINTMSK3_val).init(base_address + 0x16c);

    /// OTG_FS_HCINTMSK4
    const OTG_FS_HCINTMSK4_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-4 mask register
    pub const OTG_FS_HCINTMSK4 = Register(OTG_FS_HCINTMSK4_val).init(base_address + 0x18c);

    /// OTG_FS_HCINTMSK5
    const OTG_FS_HCINTMSK5_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-5 mask register
    pub const OTG_FS_HCINTMSK5 = Register(OTG_FS_HCINTMSK5_val).init(base_address + 0x1ac);

    /// OTG_FS_HCINTMSK6
    const OTG_FS_HCINTMSK6_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-6 mask register
    pub const OTG_FS_HCINTMSK6 = Register(OTG_FS_HCINTMSK6_val).init(base_address + 0x1cc);

    /// OTG_FS_HCINTMSK7
    const OTG_FS_HCINTMSK7_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-7 mask register
    pub const OTG_FS_HCINTMSK7 = Register(OTG_FS_HCINTMSK7_val).init(base_address + 0x1ec);

    /// OTG_FS_HCTSIZ0
    const OTG_FS_HCTSIZ0_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-0 transfer size
    pub const OTG_FS_HCTSIZ0 = Register(OTG_FS_HCTSIZ0_val).init(base_address + 0x110);

    /// OTG_FS_HCTSIZ1
    const OTG_FS_HCTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-1 transfer size
    pub const OTG_FS_HCTSIZ1 = Register(OTG_FS_HCTSIZ1_val).init(base_address + 0x130);

    /// OTG_FS_HCTSIZ2
    const OTG_FS_HCTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-2 transfer size
    pub const OTG_FS_HCTSIZ2 = Register(OTG_FS_HCTSIZ2_val).init(base_address + 0x150);

    /// OTG_FS_HCTSIZ3
    const OTG_FS_HCTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-3 transfer size
    pub const OTG_FS_HCTSIZ3 = Register(OTG_FS_HCTSIZ3_val).init(base_address + 0x170);

    /// OTG_FS_HCTSIZ4
    const OTG_FS_HCTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-x transfer size
    pub const OTG_FS_HCTSIZ4 = Register(OTG_FS_HCTSIZ4_val).init(base_address + 0x190);

    /// OTG_FS_HCTSIZ5
    const OTG_FS_HCTSIZ5_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-5 transfer size
    pub const OTG_FS_HCTSIZ5 = Register(OTG_FS_HCTSIZ5_val).init(base_address + 0x1b0);

    /// OTG_FS_HCTSIZ6
    const OTG_FS_HCTSIZ6_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-6 transfer size
    pub const OTG_FS_HCTSIZ6 = Register(OTG_FS_HCTSIZ6_val).init(base_address + 0x1d0);

    /// OTG_FS_HCTSIZ7
    const OTG_FS_HCTSIZ7_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-7 transfer size
    pub const OTG_FS_HCTSIZ7 = Register(OTG_FS_HCTSIZ7_val).init(base_address + 0x1f0);

    /// OTG_FS_HCCHAR8
    const OTG_FS_HCCHAR8_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-8 characteristics
    pub const OTG_FS_HCCHAR8 = Register(OTG_FS_HCCHAR8_val).init(base_address + 0x1f4);

    /// OTG_FS_HCINT8
    const OTG_FS_HCINT8_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-8 interrupt
    pub const OTG_FS_HCINT8 = Register(OTG_FS_HCINT8_val).init(base_address + 0x1f8);

    /// OTG_FS_HCINTMSK8
    const OTG_FS_HCINTMSK8_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-8 mask
    pub const OTG_FS_HCINTMSK8 = Register(OTG_FS_HCINTMSK8_val).init(base_address + 0x1fc);

    /// OTG_FS_HCTSIZ8
    const OTG_FS_HCTSIZ8_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-8 transfer size
    pub const OTG_FS_HCTSIZ8 = Register(OTG_FS_HCTSIZ8_val).init(base_address + 0x200);

    /// OTG_FS_HCCHAR9
    const OTG_FS_HCCHAR9_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-9 characteristics
    pub const OTG_FS_HCCHAR9 = Register(OTG_FS_HCCHAR9_val).init(base_address + 0x204);

    /// OTG_FS_HCINT9
    const OTG_FS_HCINT9_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-9 interrupt
    pub const OTG_FS_HCINT9 = Register(OTG_FS_HCINT9_val).init(base_address + 0x208);

    /// OTG_FS_HCINTMSK9
    const OTG_FS_HCINTMSK9_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-9 mask
    pub const OTG_FS_HCINTMSK9 = Register(OTG_FS_HCINTMSK9_val).init(base_address + 0x20c);

    /// OTG_FS_HCTSIZ9
    const OTG_FS_HCTSIZ9_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-9 transfer size
    pub const OTG_FS_HCTSIZ9 = Register(OTG_FS_HCTSIZ9_val).init(base_address + 0x210);

    /// OTG_FS_HCCHAR10
    const OTG_FS_HCCHAR10_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-10 characteristics
    pub const OTG_FS_HCCHAR10 = Register(OTG_FS_HCCHAR10_val).init(base_address + 0x214);

    /// OTG_FS_HCINT10
    const OTG_FS_HCINT10_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-10 interrupt
    pub const OTG_FS_HCINT10 = Register(OTG_FS_HCINT10_val).init(base_address + 0x218);

    /// OTG_FS_HCINTMSK10
    const OTG_FS_HCINTMSK10_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-10 mask
    pub const OTG_FS_HCINTMSK10 = Register(OTG_FS_HCINTMSK10_val).init(base_address + 0x21c);

    /// OTG_FS_HCTSIZ10
    const OTG_FS_HCTSIZ10_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-10 transfer size
    pub const OTG_FS_HCTSIZ10 = Register(OTG_FS_HCTSIZ10_val).init(base_address + 0x220);

    /// OTG_FS_HCCHAR11
    const OTG_FS_HCCHAR11_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MCNT [20:21]
        /// Multicount
        MCNT: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_FS host channel-11 characteristics
    pub const OTG_FS_HCCHAR11 = Register(OTG_FS_HCCHAR11_val).init(base_address + 0x224);

    /// OTG_FS_HCINT11
    const OTG_FS_HCINT11_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// unused [6:6]
        _unused6: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-11 interrupt
    pub const OTG_FS_HCINT11 = Register(OTG_FS_HCINT11_val).init(base_address + 0x228);

    /// OTG_FS_HCINTMSK11
    const OTG_FS_HCINTMSK11_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS host channel-11 mask
    pub const OTG_FS_HCINTMSK11 = Register(OTG_FS_HCINTMSK11_val).init(base_address + 0x22c);

    /// OTG_FS_HCTSIZ11
    const OTG_FS_HCTSIZ11_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_FS host channel-11 transfer size
    pub const OTG_FS_HCTSIZ11 = Register(OTG_FS_HCTSIZ11_val).init(base_address + 0x230);
};

/// USB on the go full speed
pub const OTG_FS_DEVICE = struct {
    const base_address = 0x50000800;
    /// OTG_FS_DCFG
    const OTG_FS_DCFG_val = packed struct {
        /// DSPD [0:1]
        /// Device speed
        DSPD: u2 = 0,
        /// NZLSOHSK [2:2]
        /// Non-zero-length status OUT
        NZLSOHSK: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// DAD [4:10]
        /// Device address
        DAD: u7 = 0,
        /// PFIVL [11:12]
        /// Periodic frame interval
        PFIVL: u2 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 32,
        _unused24: u8 = 2,
    };
    /// OTG_FS device configuration register
    pub const OTG_FS_DCFG = Register(OTG_FS_DCFG_val).init(base_address + 0x0);

    /// OTG_FS_DCTL
    const OTG_FS_DCTL_val = packed struct {
        /// RWUSIG [0:0]
        /// Remote wakeup signaling
        RWUSIG: u1 = 0,
        /// SDIS [1:1]
        /// Soft disconnect
        SDIS: u1 = 0,
        /// GINSTS [2:2]
        /// Global IN NAK status
        GINSTS: u1 = 0,
        /// GONSTS [3:3]
        /// Global OUT NAK status
        GONSTS: u1 = 0,
        /// TCTL [4:6]
        /// Test control
        TCTL: u3 = 0,
        /// SGINAK [7:7]
        /// Set global IN NAK
        SGINAK: u1 = 0,
        /// CGINAK [8:8]
        /// Clear global IN NAK
        CGINAK: u1 = 0,
        /// SGONAK [9:9]
        /// Set global OUT NAK
        SGONAK: u1 = 0,
        /// CGONAK [10:10]
        /// Clear global OUT NAK
        CGONAK: u1 = 0,
        /// POPRGDNE [11:11]
        /// Power-on programming done
        POPRGDNE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device control register
    pub const OTG_FS_DCTL = Register(OTG_FS_DCTL_val).init(base_address + 0x4);

    /// OTG_FS_DSTS
    const OTG_FS_DSTS_val = packed struct {
        /// SUSPSTS [0:0]
        /// Suspend status
        SUSPSTS: u1 = 0,
        /// ENUMSPD [1:2]
        /// Enumerated speed
        ENUMSPD: u2 = 0,
        /// EERR [3:3]
        /// Erratic error
        EERR: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 1,
        /// FNSOF [8:21]
        /// Frame number of the received
        FNSOF: u14 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device status register
    pub const OTG_FS_DSTS = Register(OTG_FS_DSTS_val).init(base_address + 0x8);

    /// OTG_FS_DIEPMSK
    const OTG_FS_DIEPMSK_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed interrupt
        XFRCM: u1 = 0,
        /// EPDM [1:1]
        /// Endpoint disabled interrupt
        EPDM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOM [3:3]
        /// Timeout condition mask (Non-isochronous
        TOM: u1 = 0,
        /// ITTXFEMSK [4:4]
        /// IN token received when TxFIFO empty
        ITTXFEMSK: u1 = 0,
        /// INEPNMM [5:5]
        /// IN token received with EP mismatch
        INEPNMM: u1 = 0,
        /// INEPNEM [6:6]
        /// IN endpoint NAK effective
        INEPNEM: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        /// TXFURM [8:8]
        TXFURM: u1 = 0,
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint common interrupt
    pub const OTG_FS_DIEPMSK = Register(OTG_FS_DIEPMSK_val).init(base_address + 0x10);

    /// OTG_FS_DOEPMSK
    const OTG_FS_DOEPMSK_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed interrupt
        XFRCM: u1 = 0,
        /// EPDM [1:1]
        /// Endpoint disabled interrupt
        EPDM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUPM [3:3]
        /// SETUP phase done mask
        STUPM: u1 = 0,
        /// OTEPDM [4:4]
        /// OUT token received when endpoint
        OTEPDM: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device OUT endpoint common interrupt
    pub const OTG_FS_DOEPMSK = Register(OTG_FS_DOEPMSK_val).init(base_address + 0x14);

    /// OTG_FS_DAINT
    const OTG_FS_DAINT_val = packed struct {
        /// IEPINT [0:15]
        /// IN endpoint interrupt bits
        IEPINT: u16 = 0,
        /// OEPINT [16:31]
        /// OUT endpoint interrupt
        OEPINT: u16 = 0,
    };
    /// OTG_FS device all endpoints interrupt
    pub const OTG_FS_DAINT = Register(OTG_FS_DAINT_val).init(base_address + 0x18);

    /// OTG_FS_DAINTMSK
    const OTG_FS_DAINTMSK_val = packed struct {
        /// IEPM [0:15]
        /// IN EP interrupt mask bits
        IEPM: u16 = 0,
        /// OEPINT [16:31]
        /// OUT endpoint interrupt
        OEPINT: u16 = 0,
    };
    /// OTG_FS all endpoints interrupt mask register
    pub const OTG_FS_DAINTMSK = Register(OTG_FS_DAINTMSK_val).init(base_address + 0x1c);

    /// OTG_FS_DVBUSDIS
    const OTG_FS_DVBUSDIS_val = packed struct {
        /// VBUSDT [0:15]
        /// Device VBUS discharge time
        VBUSDT: u16 = 6103,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device VBUS discharge time
    pub const OTG_FS_DVBUSDIS = Register(OTG_FS_DVBUSDIS_val).init(base_address + 0x28);

    /// OTG_FS_DVBUSPULSE
    const OTG_FS_DVBUSPULSE_val = packed struct {
        /// DVBUSP [0:11]
        /// Device VBUS pulsing time
        DVBUSP: u12 = 1464,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device VBUS pulsing time
    pub const OTG_FS_DVBUSPULSE = Register(OTG_FS_DVBUSPULSE_val).init(base_address + 0x2c);

    /// OTG_FS_DIEPEMPMSK
    const OTG_FS_DIEPEMPMSK_val = packed struct {
        /// INEPTXFEM [0:15]
        /// IN EP Tx FIFO empty interrupt mask
        INEPTXFEM: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint FIFO empty
    pub const OTG_FS_DIEPEMPMSK = Register(OTG_FS_DIEPEMPMSK_val).init(base_address + 0x34);

    /// OTG_FS_DIEPCTL0
    const OTG_FS_DIEPCTL0_val = packed struct {
        /// MPSIZ [0:1]
        /// Maximum packet size
        MPSIZ: u2 = 0,
        /// unused [2:14]
        _unused2: u6 = 0,
        _unused8: u7 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// STALL [21:21]
        /// STALL handshake
        STALL: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// unused [28:29]
        _unused28: u2 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG_FS device control IN endpoint 0 control
    pub const OTG_FS_DIEPCTL0 = Register(OTG_FS_DIEPCTL0_val).init(base_address + 0x100);

    /// OTG_FS_DIEPCTL1
    const OTG_FS_DIEPCTL1_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TXFNUM
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM_SD1PID [29:29]
        /// SODDFRM/SD1PID
        SODDFRM_SD1PID: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-1 control
    pub const OTG_FS_DIEPCTL1 = Register(OTG_FS_DIEPCTL1_val).init(base_address + 0x120);

    /// OTG_FS_DIEPCTL2
    const OTG_FS_DIEPCTL2_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TXFNUM
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-2 control
    pub const OTG_FS_DIEPCTL2 = Register(OTG_FS_DIEPCTL2_val).init(base_address + 0x140);

    /// OTG_FS_DIEPCTL3
    const OTG_FS_DIEPCTL3_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TXFNUM
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-3 control
    pub const OTG_FS_DIEPCTL3 = Register(OTG_FS_DIEPCTL3_val).init(base_address + 0x160);

    /// OTG_FS_DOEPCTL0
    const OTG_FS_DOEPCTL0_val = packed struct {
        /// MPSIZ [0:1]
        /// MPSIZ
        MPSIZ: u2 = 0,
        /// unused [2:14]
        _unused2: u6 = 0,
        _unused8: u7 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 1,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// unused [28:29]
        _unused28: u2 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-0 control
    pub const OTG_FS_DOEPCTL0 = Register(OTG_FS_DOEPCTL0_val).init(base_address + 0x300);

    /// OTG_FS_DOEPCTL1
    const OTG_FS_DOEPCTL1_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-1 control
    pub const OTG_FS_DOEPCTL1 = Register(OTG_FS_DOEPCTL1_val).init(base_address + 0x320);

    /// OTG_FS_DOEPCTL2
    const OTG_FS_DOEPCTL2_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-2 control
    pub const OTG_FS_DOEPCTL2 = Register(OTG_FS_DOEPCTL2_val).init(base_address + 0x340);

    /// OTG_FS_DOEPCTL3
    const OTG_FS_DOEPCTL3_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-3 control
    pub const OTG_FS_DOEPCTL3 = Register(OTG_FS_DOEPCTL3_val).init(base_address + 0x360);

    /// OTG_FS_DIEPINT0
    const OTG_FS_DIEPINT0_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-x interrupt
    pub const OTG_FS_DIEPINT0 = Register(OTG_FS_DIEPINT0_val).init(base_address + 0x108);

    /// OTG_FS_DIEPINT1
    const OTG_FS_DIEPINT1_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-1 interrupt
    pub const OTG_FS_DIEPINT1 = Register(OTG_FS_DIEPINT1_val).init(base_address + 0x128);

    /// OTG_FS_DIEPINT2
    const OTG_FS_DIEPINT2_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-2 interrupt
    pub const OTG_FS_DIEPINT2 = Register(OTG_FS_DIEPINT2_val).init(base_address + 0x148);

    /// OTG_FS_DIEPINT3
    const OTG_FS_DIEPINT3_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 1,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-3 interrupt
    pub const OTG_FS_DIEPINT3 = Register(OTG_FS_DIEPINT3_val).init(base_address + 0x168);

    /// OTG_FS_DOEPINT0
    const OTG_FS_DOEPINT0_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 1,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-0 interrupt
    pub const OTG_FS_DOEPINT0 = Register(OTG_FS_DOEPINT0_val).init(base_address + 0x308);

    /// OTG_FS_DOEPINT1
    const OTG_FS_DOEPINT1_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 1,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-1 interrupt
    pub const OTG_FS_DOEPINT1 = Register(OTG_FS_DOEPINT1_val).init(base_address + 0x328);

    /// OTG_FS_DOEPINT2
    const OTG_FS_DOEPINT2_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 1,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-2 interrupt
    pub const OTG_FS_DOEPINT2 = Register(OTG_FS_DOEPINT2_val).init(base_address + 0x348);

    /// OTG_FS_DOEPINT3
    const OTG_FS_DOEPINT3_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 1,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-3 interrupt
    pub const OTG_FS_DOEPINT3 = Register(OTG_FS_DOEPINT3_val).init(base_address + 0x368);

    /// OTG_FS_DIEPTSIZ0
    const OTG_FS_DIEPTSIZ0_val = packed struct {
        /// XFRSIZ [0:6]
        /// Transfer size
        XFRSIZ: u7 = 0,
        /// unused [7:18]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u3 = 0,
        /// PKTCNT [19:20]
        /// Packet count
        PKTCNT: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-0 transfer size
    pub const OTG_FS_DIEPTSIZ0 = Register(OTG_FS_DIEPTSIZ0_val).init(base_address + 0x110);

    /// OTG_FS_DOEPTSIZ0
    const OTG_FS_DOEPTSIZ0_val = packed struct {
        /// XFRSIZ [0:6]
        /// Transfer size
        XFRSIZ: u7 = 0,
        /// unused [7:18]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u3 = 0,
        /// PKTCNT [19:19]
        /// Packet count
        PKTCNT: u1 = 0,
        /// unused [20:28]
        _unused20: u4 = 0,
        _unused24: u5 = 0,
        /// STUPCNT [29:30]
        /// SETUP packet count
        STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-0 transfer size
    pub const OTG_FS_DOEPTSIZ0 = Register(OTG_FS_DOEPTSIZ0_val).init(base_address + 0x310);

    /// OTG_FS_DIEPTSIZ1
    const OTG_FS_DIEPTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device endpoint-1 transfer size
    pub const OTG_FS_DIEPTSIZ1 = Register(OTG_FS_DIEPTSIZ1_val).init(base_address + 0x130);

    /// OTG_FS_DIEPTSIZ2
    const OTG_FS_DIEPTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device endpoint-2 transfer size
    pub const OTG_FS_DIEPTSIZ2 = Register(OTG_FS_DIEPTSIZ2_val).init(base_address + 0x150);

    /// OTG_FS_DIEPTSIZ3
    const OTG_FS_DIEPTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device endpoint-3 transfer size
    pub const OTG_FS_DIEPTSIZ3 = Register(OTG_FS_DIEPTSIZ3_val).init(base_address + 0x170);

    /// OTG_FS_DTXFSTS0
    const OTG_FS_DTXFSTS0_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS0 = Register(OTG_FS_DTXFSTS0_val).init(base_address + 0x118);

    /// OTG_FS_DTXFSTS1
    const OTG_FS_DTXFSTS1_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS1 = Register(OTG_FS_DTXFSTS1_val).init(base_address + 0x138);

    /// OTG_FS_DTXFSTS2
    const OTG_FS_DTXFSTS2_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS2 = Register(OTG_FS_DTXFSTS2_val).init(base_address + 0x158);

    /// OTG_FS_DTXFSTS3
    const OTG_FS_DTXFSTS3_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS3 = Register(OTG_FS_DTXFSTS3_val).init(base_address + 0x178);

    /// OTG_FS_DOEPTSIZ1
    const OTG_FS_DOEPTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-1 transfer size
    pub const OTG_FS_DOEPTSIZ1 = Register(OTG_FS_DOEPTSIZ1_val).init(base_address + 0x330);

    /// OTG_FS_DOEPTSIZ2
    const OTG_FS_DOEPTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-2 transfer size
    pub const OTG_FS_DOEPTSIZ2 = Register(OTG_FS_DOEPTSIZ2_val).init(base_address + 0x350);

    /// OTG_FS_DOEPTSIZ3
    const OTG_FS_DOEPTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-3 transfer size
    pub const OTG_FS_DOEPTSIZ3 = Register(OTG_FS_DOEPTSIZ3_val).init(base_address + 0x370);

    /// OTG_FS_DIEPCTL4
    const OTG_FS_DIEPCTL4_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TXFNUM
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-4 control
    pub const OTG_FS_DIEPCTL4 = Register(OTG_FS_DIEPCTL4_val).init(base_address + 0x180);

    /// OTG_FS_DIEPINT4
    const OTG_FS_DIEPINT4_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-4 interrupt
    pub const OTG_FS_DIEPINT4 = Register(OTG_FS_DIEPINT4_val).init(base_address + 0x188);

    /// OTG_FS_DIEPTSIZ4
    const OTG_FS_DIEPTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device endpoint-4 transfer size
    pub const OTG_FS_DIEPTSIZ4 = Register(OTG_FS_DIEPTSIZ4_val).init(base_address + 0x194);

    /// OTG_FS_DTXFSTS4
    const OTG_FS_DTXFSTS4_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS4 = Register(OTG_FS_DTXFSTS4_val).init(base_address + 0x19c);

    /// OTG_FS_DIEPCTL5
    const OTG_FS_DIEPCTL5_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TXFNUM
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-5 control
    pub const OTG_FS_DIEPCTL5 = Register(OTG_FS_DIEPCTL5_val).init(base_address + 0x1a0);

    /// OTG_FS_DIEPINT5
    const OTG_FS_DIEPINT5_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// TOC
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// ITTXFE
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// INEPNE
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// TXFE
        TXFE: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-5 interrupt
    pub const OTG_FS_DIEPINT5 = Register(OTG_FS_DIEPINT5_val).init(base_address + 0x1a8);

    /// OTG_FS_DIEPTSIZ55
    const OTG_FS_DIEPTSIZ55_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device endpoint-5 transfer size
    pub const OTG_FS_DIEPTSIZ55 = Register(OTG_FS_DIEPTSIZ55_val).init(base_address + 0x1b0);

    /// OTG_FS_DTXFSTS55
    const OTG_FS_DTXFSTS55_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS device IN endpoint transmit FIFO
    pub const OTG_FS_DTXFSTS55 = Register(OTG_FS_DTXFSTS55_val).init(base_address + 0x1b8);

    /// OTG_FS_DOEPCTL4
    const OTG_FS_DOEPCTL4_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-4 control
    pub const OTG_FS_DOEPCTL4 = Register(OTG_FS_DOEPCTL4_val).init(base_address + 0x378);

    /// OTG_FS_DOEPINT4
    const OTG_FS_DOEPINT4_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-4 interrupt
    pub const OTG_FS_DOEPINT4 = Register(OTG_FS_DOEPINT4_val).init(base_address + 0x380);

    /// OTG_FS_DOEPTSIZ4
    const OTG_FS_DOEPTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-4 transfer size
    pub const OTG_FS_DOEPTSIZ4 = Register(OTG_FS_DOEPTSIZ4_val).init(base_address + 0x388);

    /// OTG_FS_DOEPCTL5
    const OTG_FS_DOEPCTL5_val = packed struct {
        /// MPSIZ [0:10]
        /// MPSIZ
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USBAEP
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// EONUM/DPID
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAKSTS
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// EPTYP
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// SNPM
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// Stall
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// CNAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// SNAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// SD0PID/SEVNFRM
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// SODDFRM
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// EPDIS
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// EPENA
        EPENA: u1 = 0,
    };
    /// device endpoint-5 control
    pub const OTG_FS_DOEPCTL5 = Register(OTG_FS_DOEPCTL5_val).init(base_address + 0x390);

    /// OTG_FS_DOEPINT5
    const OTG_FS_DOEPINT5_val = packed struct {
        /// XFRC [0:0]
        /// XFRC
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// EPDISD
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// STUP
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OTEPDIS
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// B2BSTUP
        B2BSTUP: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// device endpoint-5 interrupt
    pub const OTG_FS_DOEPINT5 = Register(OTG_FS_DOEPINT5_val).init(base_address + 0x398);

    /// OTG_FS_DOEPTSIZ5
    const OTG_FS_DOEPTSIZ5_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// device OUT endpoint-5 transfer size
    pub const OTG_FS_DOEPTSIZ5 = Register(OTG_FS_DOEPTSIZ5_val).init(base_address + 0x3a0);
};

/// USB on the go full speed
pub const OTG_FS_PWRCLK = struct {
    const base_address = 0x50000e00;
    /// OTG_FS_PCGCCTL
    const OTG_FS_PCGCCTL_val = packed struct {
        /// STPPCLK [0:0]
        /// Stop PHY clock
        STPPCLK: u1 = 0,
        /// GATEHCLK [1:1]
        /// Gate HCLK
        GATEHCLK: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// PHYSUSP [4:4]
        /// PHY Suspended
        PHYSUSP: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_FS power and clock gating control
    pub const OTG_FS_PCGCCTL = Register(OTG_FS_PCGCCTL_val).init(base_address + 0x0);
};

/// USB on the go high speed
pub const OTG_HS_HOST = struct {
    const base_address = 0x40040400;
    /// OTG_HS_HCFG
    const OTG_HS_HCFG_val = packed struct {
        /// FSLSPCS [0:1]
        /// FS/LS PHY clock select
        FSLSPCS: u2 = 0,
        /// FSLSS [2:2]
        /// FS- and LS-only support
        FSLSS: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host configuration
    pub const OTG_HS_HCFG = Register(OTG_HS_HCFG_val).init(base_address + 0x0);

    /// OTG_HS_HFIR
    const OTG_HS_HFIR_val = packed struct {
        /// FRIVL [0:15]
        /// Frame interval
        FRIVL: u16 = 60000,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS Host frame interval
    pub const OTG_HS_HFIR = Register(OTG_HS_HFIR_val).init(base_address + 0x4);

    /// OTG_HS_HFNUM
    const OTG_HS_HFNUM_val = packed struct {
        /// FRNUM [0:15]
        /// Frame number
        FRNUM: u16 = 16383,
        /// FTREM [16:31]
        /// Frame time remaining
        FTREM: u16 = 0,
    };
    /// OTG_HS host frame number/frame time
    pub const OTG_HS_HFNUM = Register(OTG_HS_HFNUM_val).init(base_address + 0x8);

    /// OTG_HS_HPTXSTS
    const OTG_HS_HPTXSTS_val = packed struct {
        /// PTXFSAVL [0:15]
        /// Periodic transmit data FIFO space
        PTXFSAVL: u16 = 256,
        /// PTXQSAV [16:23]
        /// Periodic transmit request queue space
        PTXQSAV: u8 = 8,
        /// PTXQTOP [24:31]
        /// Top of the periodic transmit request
        PTXQTOP: u8 = 0,
    };
    /// OTG_HS_Host periodic transmit FIFO/queue
    pub const OTG_HS_HPTXSTS = Register(OTG_HS_HPTXSTS_val).init(base_address + 0x10);

    /// OTG_HS_HAINT
    const OTG_HS_HAINT_val = packed struct {
        /// HAINT [0:15]
        /// Channel interrupts
        HAINT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS Host all channels interrupt
    pub const OTG_HS_HAINT = Register(OTG_HS_HAINT_val).init(base_address + 0x14);

    /// OTG_HS_HAINTMSK
    const OTG_HS_HAINTMSK_val = packed struct {
        /// HAINTM [0:15]
        /// Channel interrupt mask
        HAINTM: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host all channels interrupt mask
    pub const OTG_HS_HAINTMSK = Register(OTG_HS_HAINTMSK_val).init(base_address + 0x18);

    /// OTG_HS_HPRT
    const OTG_HS_HPRT_val = packed struct {
        /// PCSTS [0:0]
        /// Port connect status
        PCSTS: u1 = 0,
        /// PCDET [1:1]
        /// Port connect detected
        PCDET: u1 = 0,
        /// PENA [2:2]
        /// Port enable
        PENA: u1 = 0,
        /// PENCHNG [3:3]
        /// Port enable/disable change
        PENCHNG: u1 = 0,
        /// POCA [4:4]
        /// Port overcurrent active
        POCA: u1 = 0,
        /// POCCHNG [5:5]
        /// Port overcurrent change
        POCCHNG: u1 = 0,
        /// PRES [6:6]
        /// Port resume
        PRES: u1 = 0,
        /// PSUSP [7:7]
        /// Port suspend
        PSUSP: u1 = 0,
        /// PRST [8:8]
        /// Port reset
        PRST: u1 = 0,
        /// unused [9:9]
        _unused9: u1 = 0,
        /// PLSTS [10:11]
        /// Port line status
        PLSTS: u2 = 0,
        /// PPWR [12:12]
        /// Port power
        PPWR: u1 = 0,
        /// PTCTL [13:16]
        /// Port test control
        PTCTL: u4 = 0,
        /// PSPD [17:18]
        /// Port speed
        PSPD: u2 = 0,
        /// unused [19:31]
        _unused19: u5 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host port control and status
    pub const OTG_HS_HPRT = Register(OTG_HS_HPRT_val).init(base_address + 0x40);

    /// OTG_HS_HCCHAR0
    const OTG_HS_HCCHAR0_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-0 characteristics
    pub const OTG_HS_HCCHAR0 = Register(OTG_HS_HCCHAR0_val).init(base_address + 0x100);

    /// OTG_HS_HCCHAR1
    const OTG_HS_HCCHAR1_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-1 characteristics
    pub const OTG_HS_HCCHAR1 = Register(OTG_HS_HCCHAR1_val).init(base_address + 0x120);

    /// OTG_HS_HCCHAR2
    const OTG_HS_HCCHAR2_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-2 characteristics
    pub const OTG_HS_HCCHAR2 = Register(OTG_HS_HCCHAR2_val).init(base_address + 0x140);

    /// OTG_HS_HCCHAR3
    const OTG_HS_HCCHAR3_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-3 characteristics
    pub const OTG_HS_HCCHAR3 = Register(OTG_HS_HCCHAR3_val).init(base_address + 0x160);

    /// OTG_HS_HCCHAR4
    const OTG_HS_HCCHAR4_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-4 characteristics
    pub const OTG_HS_HCCHAR4 = Register(OTG_HS_HCCHAR4_val).init(base_address + 0x180);

    /// OTG_HS_HCCHAR5
    const OTG_HS_HCCHAR5_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-5 characteristics
    pub const OTG_HS_HCCHAR5 = Register(OTG_HS_HCCHAR5_val).init(base_address + 0x1a0);

    /// OTG_HS_HCCHAR6
    const OTG_HS_HCCHAR6_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-6 characteristics
    pub const OTG_HS_HCCHAR6 = Register(OTG_HS_HCCHAR6_val).init(base_address + 0x1c0);

    /// OTG_HS_HCCHAR7
    const OTG_HS_HCCHAR7_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-7 characteristics
    pub const OTG_HS_HCCHAR7 = Register(OTG_HS_HCCHAR7_val).init(base_address + 0x1e0);

    /// OTG_HS_HCCHAR8
    const OTG_HS_HCCHAR8_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-8 characteristics
    pub const OTG_HS_HCCHAR8 = Register(OTG_HS_HCCHAR8_val).init(base_address + 0x200);

    /// OTG_HS_HCCHAR9
    const OTG_HS_HCCHAR9_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-9 characteristics
    pub const OTG_HS_HCCHAR9 = Register(OTG_HS_HCCHAR9_val).init(base_address + 0x220);

    /// OTG_HS_HCCHAR10
    const OTG_HS_HCCHAR10_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-10 characteristics
    pub const OTG_HS_HCCHAR10 = Register(OTG_HS_HCCHAR10_val).init(base_address + 0x240);

    /// OTG_HS_HCCHAR11
    const OTG_HS_HCCHAR11_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-11 characteristics
    pub const OTG_HS_HCCHAR11 = Register(OTG_HS_HCCHAR11_val).init(base_address + 0x260);

    /// OTG_HS_HCSPLT0
    const OTG_HS_HCSPLT0_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-0 split control
    pub const OTG_HS_HCSPLT0 = Register(OTG_HS_HCSPLT0_val).init(base_address + 0x104);

    /// OTG_HS_HCSPLT1
    const OTG_HS_HCSPLT1_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-1 split control
    pub const OTG_HS_HCSPLT1 = Register(OTG_HS_HCSPLT1_val).init(base_address + 0x124);

    /// OTG_HS_HCSPLT2
    const OTG_HS_HCSPLT2_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-2 split control
    pub const OTG_HS_HCSPLT2 = Register(OTG_HS_HCSPLT2_val).init(base_address + 0x144);

    /// OTG_HS_HCSPLT3
    const OTG_HS_HCSPLT3_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-3 split control
    pub const OTG_HS_HCSPLT3 = Register(OTG_HS_HCSPLT3_val).init(base_address + 0x164);

    /// OTG_HS_HCSPLT4
    const OTG_HS_HCSPLT4_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-4 split control
    pub const OTG_HS_HCSPLT4 = Register(OTG_HS_HCSPLT4_val).init(base_address + 0x184);

    /// OTG_HS_HCSPLT5
    const OTG_HS_HCSPLT5_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-5 split control
    pub const OTG_HS_HCSPLT5 = Register(OTG_HS_HCSPLT5_val).init(base_address + 0x1a4);

    /// OTG_HS_HCSPLT6
    const OTG_HS_HCSPLT6_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-6 split control
    pub const OTG_HS_HCSPLT6 = Register(OTG_HS_HCSPLT6_val).init(base_address + 0x1c4);

    /// OTG_HS_HCSPLT7
    const OTG_HS_HCSPLT7_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-7 split control
    pub const OTG_HS_HCSPLT7 = Register(OTG_HS_HCSPLT7_val).init(base_address + 0x1e4);

    /// OTG_HS_HCSPLT8
    const OTG_HS_HCSPLT8_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-8 split control
    pub const OTG_HS_HCSPLT8 = Register(OTG_HS_HCSPLT8_val).init(base_address + 0x204);

    /// OTG_HS_HCSPLT9
    const OTG_HS_HCSPLT9_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-9 split control
    pub const OTG_HS_HCSPLT9 = Register(OTG_HS_HCSPLT9_val).init(base_address + 0x224);

    /// OTG_HS_HCSPLT10
    const OTG_HS_HCSPLT10_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-10 split control
    pub const OTG_HS_HCSPLT10 = Register(OTG_HS_HCSPLT10_val).init(base_address + 0x244);

    /// OTG_HS_HCSPLT11
    const OTG_HS_HCSPLT11_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-11 split control
    pub const OTG_HS_HCSPLT11 = Register(OTG_HS_HCSPLT11_val).init(base_address + 0x264);

    /// OTG_HS_HCINT0
    const OTG_HS_HCINT0_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-11 interrupt
    pub const OTG_HS_HCINT0 = Register(OTG_HS_HCINT0_val).init(base_address + 0x108);

    /// OTG_HS_HCINT1
    const OTG_HS_HCINT1_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-1 interrupt
    pub const OTG_HS_HCINT1 = Register(OTG_HS_HCINT1_val).init(base_address + 0x128);

    /// OTG_HS_HCINT2
    const OTG_HS_HCINT2_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-2 interrupt
    pub const OTG_HS_HCINT2 = Register(OTG_HS_HCINT2_val).init(base_address + 0x148);

    /// OTG_HS_HCINT3
    const OTG_HS_HCINT3_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-3 interrupt
    pub const OTG_HS_HCINT3 = Register(OTG_HS_HCINT3_val).init(base_address + 0x168);

    /// OTG_HS_HCINT4
    const OTG_HS_HCINT4_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-4 interrupt
    pub const OTG_HS_HCINT4 = Register(OTG_HS_HCINT4_val).init(base_address + 0x188);

    /// OTG_HS_HCINT5
    const OTG_HS_HCINT5_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-5 interrupt
    pub const OTG_HS_HCINT5 = Register(OTG_HS_HCINT5_val).init(base_address + 0x1a8);

    /// OTG_HS_HCINT6
    const OTG_HS_HCINT6_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-6 interrupt
    pub const OTG_HS_HCINT6 = Register(OTG_HS_HCINT6_val).init(base_address + 0x1c8);

    /// OTG_HS_HCINT7
    const OTG_HS_HCINT7_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-7 interrupt
    pub const OTG_HS_HCINT7 = Register(OTG_HS_HCINT7_val).init(base_address + 0x1e8);

    /// OTG_HS_HCINT8
    const OTG_HS_HCINT8_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-8 interrupt
    pub const OTG_HS_HCINT8 = Register(OTG_HS_HCINT8_val).init(base_address + 0x208);

    /// OTG_HS_HCINT9
    const OTG_HS_HCINT9_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-9 interrupt
    pub const OTG_HS_HCINT9 = Register(OTG_HS_HCINT9_val).init(base_address + 0x228);

    /// OTG_HS_HCINT10
    const OTG_HS_HCINT10_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-10 interrupt
    pub const OTG_HS_HCINT10 = Register(OTG_HS_HCINT10_val).init(base_address + 0x248);

    /// OTG_HS_HCINT11
    const OTG_HS_HCINT11_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-11 interrupt
    pub const OTG_HS_HCINT11 = Register(OTG_HS_HCINT11_val).init(base_address + 0x268);

    /// OTG_HS_HCINTMSK0
    const OTG_HS_HCINTMSK0_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-11 interrupt mask
    pub const OTG_HS_HCINTMSK0 = Register(OTG_HS_HCINTMSK0_val).init(base_address + 0x10c);

    /// OTG_HS_HCINTMSK1
    const OTG_HS_HCINTMSK1_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-1 interrupt mask
    pub const OTG_HS_HCINTMSK1 = Register(OTG_HS_HCINTMSK1_val).init(base_address + 0x12c);

    /// OTG_HS_HCINTMSK2
    const OTG_HS_HCINTMSK2_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-2 interrupt mask
    pub const OTG_HS_HCINTMSK2 = Register(OTG_HS_HCINTMSK2_val).init(base_address + 0x14c);

    /// OTG_HS_HCINTMSK3
    const OTG_HS_HCINTMSK3_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-3 interrupt mask
    pub const OTG_HS_HCINTMSK3 = Register(OTG_HS_HCINTMSK3_val).init(base_address + 0x16c);

    /// OTG_HS_HCINTMSK4
    const OTG_HS_HCINTMSK4_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-4 interrupt mask
    pub const OTG_HS_HCINTMSK4 = Register(OTG_HS_HCINTMSK4_val).init(base_address + 0x18c);

    /// OTG_HS_HCINTMSK5
    const OTG_HS_HCINTMSK5_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-5 interrupt mask
    pub const OTG_HS_HCINTMSK5 = Register(OTG_HS_HCINTMSK5_val).init(base_address + 0x1ac);

    /// OTG_HS_HCINTMSK6
    const OTG_HS_HCINTMSK6_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-6 interrupt mask
    pub const OTG_HS_HCINTMSK6 = Register(OTG_HS_HCINTMSK6_val).init(base_address + 0x1cc);

    /// OTG_HS_HCINTMSK7
    const OTG_HS_HCINTMSK7_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-7 interrupt mask
    pub const OTG_HS_HCINTMSK7 = Register(OTG_HS_HCINTMSK7_val).init(base_address + 0x1ec);

    /// OTG_HS_HCINTMSK8
    const OTG_HS_HCINTMSK8_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-8 interrupt mask
    pub const OTG_HS_HCINTMSK8 = Register(OTG_HS_HCINTMSK8_val).init(base_address + 0x20c);

    /// OTG_HS_HCINTMSK9
    const OTG_HS_HCINTMSK9_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-9 interrupt mask
    pub const OTG_HS_HCINTMSK9 = Register(OTG_HS_HCINTMSK9_val).init(base_address + 0x22c);

    /// OTG_HS_HCINTMSK10
    const OTG_HS_HCINTMSK10_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-10 interrupt mask
    pub const OTG_HS_HCINTMSK10 = Register(OTG_HS_HCINTMSK10_val).init(base_address + 0x24c);

    /// OTG_HS_HCINTMSK11
    const OTG_HS_HCINTMSK11_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// response received interrupt
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error mask
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error mask
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-11 interrupt mask
    pub const OTG_HS_HCINTMSK11 = Register(OTG_HS_HCINTMSK11_val).init(base_address + 0x26c);

    /// OTG_HS_HCTSIZ0
    const OTG_HS_HCTSIZ0_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-11 transfer size
    pub const OTG_HS_HCTSIZ0 = Register(OTG_HS_HCTSIZ0_val).init(base_address + 0x110);

    /// OTG_HS_HCTSIZ1
    const OTG_HS_HCTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-1 transfer size
    pub const OTG_HS_HCTSIZ1 = Register(OTG_HS_HCTSIZ1_val).init(base_address + 0x130);

    /// OTG_HS_HCTSIZ2
    const OTG_HS_HCTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-2 transfer size
    pub const OTG_HS_HCTSIZ2 = Register(OTG_HS_HCTSIZ2_val).init(base_address + 0x150);

    /// OTG_HS_HCTSIZ3
    const OTG_HS_HCTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-3 transfer size
    pub const OTG_HS_HCTSIZ3 = Register(OTG_HS_HCTSIZ3_val).init(base_address + 0x170);

    /// OTG_HS_HCTSIZ4
    const OTG_HS_HCTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-4 transfer size
    pub const OTG_HS_HCTSIZ4 = Register(OTG_HS_HCTSIZ4_val).init(base_address + 0x190);

    /// OTG_HS_HCTSIZ5
    const OTG_HS_HCTSIZ5_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-5 transfer size
    pub const OTG_HS_HCTSIZ5 = Register(OTG_HS_HCTSIZ5_val).init(base_address + 0x1b0);

    /// OTG_HS_HCTSIZ6
    const OTG_HS_HCTSIZ6_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-6 transfer size
    pub const OTG_HS_HCTSIZ6 = Register(OTG_HS_HCTSIZ6_val).init(base_address + 0x1d0);

    /// OTG_HS_HCTSIZ7
    const OTG_HS_HCTSIZ7_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-7 transfer size
    pub const OTG_HS_HCTSIZ7 = Register(OTG_HS_HCTSIZ7_val).init(base_address + 0x1f0);

    /// OTG_HS_HCTSIZ8
    const OTG_HS_HCTSIZ8_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-8 transfer size
    pub const OTG_HS_HCTSIZ8 = Register(OTG_HS_HCTSIZ8_val).init(base_address + 0x210);

    /// OTG_HS_HCTSIZ9
    const OTG_HS_HCTSIZ9_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-9 transfer size
    pub const OTG_HS_HCTSIZ9 = Register(OTG_HS_HCTSIZ9_val).init(base_address + 0x230);

    /// OTG_HS_HCTSIZ10
    const OTG_HS_HCTSIZ10_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-10 transfer size
    pub const OTG_HS_HCTSIZ10 = Register(OTG_HS_HCTSIZ10_val).init(base_address + 0x250);

    /// OTG_HS_HCTSIZ11
    const OTG_HS_HCTSIZ11_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-11 transfer size
    pub const OTG_HS_HCTSIZ11 = Register(OTG_HS_HCTSIZ11_val).init(base_address + 0x270);

    /// OTG_HS_HCDMA0
    const OTG_HS_HCDMA0_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-0 DMA address
    pub const OTG_HS_HCDMA0 = Register(OTG_HS_HCDMA0_val).init(base_address + 0x114);

    /// OTG_HS_HCDMA1
    const OTG_HS_HCDMA1_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-1 DMA address
    pub const OTG_HS_HCDMA1 = Register(OTG_HS_HCDMA1_val).init(base_address + 0x134);

    /// OTG_HS_HCDMA2
    const OTG_HS_HCDMA2_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-2 DMA address
    pub const OTG_HS_HCDMA2 = Register(OTG_HS_HCDMA2_val).init(base_address + 0x154);

    /// OTG_HS_HCDMA3
    const OTG_HS_HCDMA3_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-3 DMA address
    pub const OTG_HS_HCDMA3 = Register(OTG_HS_HCDMA3_val).init(base_address + 0x174);

    /// OTG_HS_HCDMA4
    const OTG_HS_HCDMA4_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-4 DMA address
    pub const OTG_HS_HCDMA4 = Register(OTG_HS_HCDMA4_val).init(base_address + 0x194);

    /// OTG_HS_HCDMA5
    const OTG_HS_HCDMA5_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-5 DMA address
    pub const OTG_HS_HCDMA5 = Register(OTG_HS_HCDMA5_val).init(base_address + 0x1b4);

    /// OTG_HS_HCDMA6
    const OTG_HS_HCDMA6_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-6 DMA address
    pub const OTG_HS_HCDMA6 = Register(OTG_HS_HCDMA6_val).init(base_address + 0x1d4);

    /// OTG_HS_HCDMA7
    const OTG_HS_HCDMA7_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-7 DMA address
    pub const OTG_HS_HCDMA7 = Register(OTG_HS_HCDMA7_val).init(base_address + 0x1f4);

    /// OTG_HS_HCDMA8
    const OTG_HS_HCDMA8_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-8 DMA address
    pub const OTG_HS_HCDMA8 = Register(OTG_HS_HCDMA8_val).init(base_address + 0x214);

    /// OTG_HS_HCDMA9
    const OTG_HS_HCDMA9_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-9 DMA address
    pub const OTG_HS_HCDMA9 = Register(OTG_HS_HCDMA9_val).init(base_address + 0x234);

    /// OTG_HS_HCDMA10
    const OTG_HS_HCDMA10_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-10 DMA address
    pub const OTG_HS_HCDMA10 = Register(OTG_HS_HCDMA10_val).init(base_address + 0x254);

    /// OTG_HS_HCDMA11
    const OTG_HS_HCDMA11_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-11 DMA address
    pub const OTG_HS_HCDMA11 = Register(OTG_HS_HCDMA11_val).init(base_address + 0x274);

    /// OTG_HS_HCCHAR12
    const OTG_HS_HCCHAR12_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-12 characteristics
    pub const OTG_HS_HCCHAR12 = Register(OTG_HS_HCCHAR12_val).init(base_address + 0x278);

    /// OTG_HS_HCSPLT12
    const OTG_HS_HCSPLT12_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-12 split control
    pub const OTG_HS_HCSPLT12 = Register(OTG_HS_HCSPLT12_val).init(base_address + 0x27c);

    /// OTG_HS_HCINT12
    const OTG_HS_HCINT12_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-12 interrupt
    pub const OTG_HS_HCINT12 = Register(OTG_HS_HCINT12_val).init(base_address + 0x280);

    /// OTG_HS_HCINTMSK12
    const OTG_HS_HCINTMSK12_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-12 interrupt mask
    pub const OTG_HS_HCINTMSK12 = Register(OTG_HS_HCINTMSK12_val).init(base_address + 0x284);

    /// OTG_HS_HCTSIZ12
    const OTG_HS_HCTSIZ12_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-12 transfer size
    pub const OTG_HS_HCTSIZ12 = Register(OTG_HS_HCTSIZ12_val).init(base_address + 0x288);

    /// OTG_HS_HCDMA12
    const OTG_HS_HCDMA12_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-12 DMA address
    pub const OTG_HS_HCDMA12 = Register(OTG_HS_HCDMA12_val).init(base_address + 0x28c);

    /// OTG_HS_HCCHAR13
    const OTG_HS_HCCHAR13_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-13 characteristics
    pub const OTG_HS_HCCHAR13 = Register(OTG_HS_HCCHAR13_val).init(base_address + 0x290);

    /// OTG_HS_HCSPLT13
    const OTG_HS_HCSPLT13_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-13 split control
    pub const OTG_HS_HCSPLT13 = Register(OTG_HS_HCSPLT13_val).init(base_address + 0x294);

    /// OTG_HS_HCINT13
    const OTG_HS_HCINT13_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-13 interrupt
    pub const OTG_HS_HCINT13 = Register(OTG_HS_HCINT13_val).init(base_address + 0x298);

    /// OTG_HS_HCINTMSK13
    const OTG_HS_HCINTMSK13_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALLM response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-13 interrupt mask
    pub const OTG_HS_HCINTMSK13 = Register(OTG_HS_HCINTMSK13_val).init(base_address + 0x29c);

    /// OTG_HS_HCTSIZ13
    const OTG_HS_HCTSIZ13_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-13 transfer size
    pub const OTG_HS_HCTSIZ13 = Register(OTG_HS_HCTSIZ13_val).init(base_address + 0x2a0);

    /// OTG_HS_HCDMA13
    const OTG_HS_HCDMA13_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-13 DMA address
    pub const OTG_HS_HCDMA13 = Register(OTG_HS_HCDMA13_val).init(base_address + 0x2a4);

    /// OTG_HS_HCCHAR14
    const OTG_HS_HCCHAR14_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-14 characteristics
    pub const OTG_HS_HCCHAR14 = Register(OTG_HS_HCCHAR14_val).init(base_address + 0x2a8);

    /// OTG_HS_HCSPLT14
    const OTG_HS_HCSPLT14_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-14 split control
    pub const OTG_HS_HCSPLT14 = Register(OTG_HS_HCSPLT14_val).init(base_address + 0x2ac);

    /// OTG_HS_HCINT14
    const OTG_HS_HCINT14_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-14 interrupt
    pub const OTG_HS_HCINT14 = Register(OTG_HS_HCINT14_val).init(base_address + 0x2b0);

    /// OTG_HS_HCINTMSK14
    const OTG_HS_HCINTMSK14_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALLM [3:3]
        /// STALL response received interrupt
        STALLM: u1 = 0,
        /// NAKM [4:4]
        /// NAKM response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACKM response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-14 interrupt mask
    pub const OTG_HS_HCINTMSK14 = Register(OTG_HS_HCINTMSK14_val).init(base_address + 0x2b4);

    /// OTG_HS_HCTSIZ14
    const OTG_HS_HCTSIZ14_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-14 transfer size
    pub const OTG_HS_HCTSIZ14 = Register(OTG_HS_HCTSIZ14_val).init(base_address + 0x2b8);

    /// OTG_HS_HCDMA14
    const OTG_HS_HCDMA14_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-14 DMA address
    pub const OTG_HS_HCDMA14 = Register(OTG_HS_HCDMA14_val).init(base_address + 0x2bc);

    /// OTG_HS_HCCHAR15
    const OTG_HS_HCCHAR15_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// EPNUM [11:14]
        /// Endpoint number
        EPNUM: u4 = 0,
        /// EPDIR [15:15]
        /// Endpoint direction
        EPDIR: u1 = 0,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// LSDEV [17:17]
        /// Low-speed device
        LSDEV: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// MC [20:21]
        /// Multi Count (MC) / Error Count
        MC: u2 = 0,
        /// DAD [22:28]
        /// Device address
        DAD: u7 = 0,
        /// ODDFRM [29:29]
        /// Odd frame
        ODDFRM: u1 = 0,
        /// CHDIS [30:30]
        /// Channel disable
        CHDIS: u1 = 0,
        /// CHENA [31:31]
        /// Channel enable
        CHENA: u1 = 0,
    };
    /// OTG_HS host channel-15 characteristics
    pub const OTG_HS_HCCHAR15 = Register(OTG_HS_HCCHAR15_val).init(base_address + 0x2c0);

    /// OTG_HS_HCSPLT15
    const OTG_HS_HCSPLT15_val = packed struct {
        /// PRTADDR [0:6]
        /// Port address
        PRTADDR: u7 = 0,
        /// HUBADDR [7:13]
        /// Hub address
        HUBADDR: u7 = 0,
        /// XACTPOS [14:15]
        /// XACTPOS
        XACTPOS: u2 = 0,
        /// COMPLSPLT [16:16]
        /// Do complete split
        COMPLSPLT: u1 = 0,
        /// unused [17:30]
        _unused17: u7 = 0,
        _unused24: u7 = 0,
        /// SPLITEN [31:31]
        /// Split enable
        SPLITEN: u1 = 0,
    };
    /// OTG_HS host channel-15 split control
    pub const OTG_HS_HCSPLT15 = Register(OTG_HS_HCSPLT15_val).init(base_address + 0x2c4);

    /// OTG_HS_HCINT15
    const OTG_HS_HCINT15_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// CHH [1:1]
        /// Channel halted
        CHH: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received
        STALL: u1 = 0,
        /// NAK [4:4]
        /// NAK response received
        NAK: u1 = 0,
        /// ACK [5:5]
        /// ACK response received/transmitted
        ACK: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERR [7:7]
        /// Transaction error
        TXERR: u1 = 0,
        /// BBERR [8:8]
        /// Babble error
        BBERR: u1 = 0,
        /// FRMOR [9:9]
        /// Frame overrun
        FRMOR: u1 = 0,
        /// DTERR [10:10]
        /// Data toggle error
        DTERR: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-15 interrupt
    pub const OTG_HS_HCINT15 = Register(OTG_HS_HCINT15_val).init(base_address + 0x2c8);

    /// OTG_HS_HCINTMSK15
    const OTG_HS_HCINTMSK15_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed mask
        XFRCM: u1 = 0,
        /// CHHM [1:1]
        /// Channel halted mask
        CHHM: u1 = 0,
        /// AHBERR [2:2]
        /// AHB error
        AHBERR: u1 = 0,
        /// STALL [3:3]
        /// STALL response received interrupt
        STALL: u1 = 0,
        /// NAKM [4:4]
        /// NAK response received interrupt
        NAKM: u1 = 0,
        /// ACKM [5:5]
        /// ACK response received/transmitted
        ACKM: u1 = 0,
        /// NYET [6:6]
        /// Response received
        NYET: u1 = 0,
        /// TXERRM [7:7]
        /// Transaction error
        TXERRM: u1 = 0,
        /// BBERRM [8:8]
        /// Babble error
        BBERRM: u1 = 0,
        /// FRMORM [9:9]
        /// Frame overrun mask
        FRMORM: u1 = 0,
        /// DTERRM [10:10]
        /// Data toggle error mask
        DTERRM: u1 = 0,
        /// unused [11:31]
        _unused11: u5 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS host channel-15 interrupt mask
    pub const OTG_HS_HCINTMSK15 = Register(OTG_HS_HCINTMSK15_val).init(base_address + 0x2cc);

    /// OTG_HS_HCTSIZ15
    const OTG_HS_HCTSIZ15_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// DPID [29:30]
        /// Data PID
        DPID: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS host channel-15 transfer size
    pub const OTG_HS_HCTSIZ15 = Register(OTG_HS_HCTSIZ15_val).init(base_address + 0x2d0);

    /// OTG_HS_HCDMA15
    const OTG_HS_HCDMA15_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS host channel-15 DMA address
    pub const OTG_HS_HCDMA15 = Register(OTG_HS_HCDMA15_val).init(base_address + 0x2d4);
};

/// USB on the go high speed
pub const OTG_HS_DEVICE = struct {
    const base_address = 0x40040800;
    /// OTG_HS_DCFG
    const OTG_HS_DCFG_val = packed struct {
        /// DSPD [0:1]
        /// Device speed
        DSPD: u2 = 0,
        /// NZLSOHSK [2:2]
        /// Nonzero-length status OUT
        NZLSOHSK: u1 = 0,
        /// unused [3:3]
        _unused3: u1 = 0,
        /// DAD [4:10]
        /// Device address
        DAD: u7 = 0,
        /// PFIVL [11:12]
        /// Periodic (micro)frame
        PFIVL: u2 = 0,
        /// unused [13:23]
        _unused13: u3 = 0,
        _unused16: u8 = 32,
        /// PERSCHIVL [24:25]
        /// Periodic scheduling
        PERSCHIVL: u2 = 2,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// OTG_HS device configuration
    pub const OTG_HS_DCFG = Register(OTG_HS_DCFG_val).init(base_address + 0x0);

    /// OTG_HS_DCTL
    const OTG_HS_DCTL_val = packed struct {
        /// RWUSIG [0:0]
        /// Remote wakeup signaling
        RWUSIG: u1 = 0,
        /// SDIS [1:1]
        /// Soft disconnect
        SDIS: u1 = 0,
        /// GINSTS [2:2]
        /// Global IN NAK status
        GINSTS: u1 = 0,
        /// GONSTS [3:3]
        /// Global OUT NAK status
        GONSTS: u1 = 0,
        /// TCTL [4:6]
        /// Test control
        TCTL: u3 = 0,
        /// SGINAK [7:7]
        /// Set global IN NAK
        SGINAK: u1 = 0,
        /// CGINAK [8:8]
        /// Clear global IN NAK
        CGINAK: u1 = 0,
        /// SGONAK [9:9]
        /// Set global OUT NAK
        SGONAK: u1 = 0,
        /// CGONAK [10:10]
        /// Clear global OUT NAK
        CGONAK: u1 = 0,
        /// POPRGDNE [11:11]
        /// Power-on programming done
        POPRGDNE: u1 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device control register
    pub const OTG_HS_DCTL = Register(OTG_HS_DCTL_val).init(base_address + 0x4);

    /// OTG_HS_DSTS
    const OTG_HS_DSTS_val = packed struct {
        /// SUSPSTS [0:0]
        /// Suspend status
        SUSPSTS: u1 = 0,
        /// ENUMSPD [1:2]
        /// Enumerated speed
        ENUMSPD: u2 = 0,
        /// EERR [3:3]
        /// Erratic error
        EERR: u1 = 0,
        /// unused [4:7]
        _unused4: u4 = 1,
        /// FNSOF [8:21]
        /// Frame number of the received
        FNSOF: u14 = 0,
        /// unused [22:31]
        _unused22: u2 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device status register
    pub const OTG_HS_DSTS = Register(OTG_HS_DSTS_val).init(base_address + 0x8);

    /// OTG_HS_DIEPMSK
    const OTG_HS_DIEPMSK_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed interrupt
        XFRCM: u1 = 0,
        /// EPDM [1:1]
        /// Endpoint disabled interrupt
        EPDM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOM [3:3]
        /// Timeout condition mask (nonisochronous
        TOM: u1 = 0,
        /// ITTXFEMSK [4:4]
        /// IN token received when TxFIFO empty
        ITTXFEMSK: u1 = 0,
        /// INEPNMM [5:5]
        /// IN token received with EP mismatch
        INEPNMM: u1 = 0,
        /// INEPNEM [6:6]
        /// IN endpoint NAK effective
        INEPNEM: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// TXFURM [8:8]
        /// FIFO underrun mask
        TXFURM: u1 = 0,
        /// BIM [9:9]
        /// BNA interrupt mask
        BIM: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint common interrupt
    pub const OTG_HS_DIEPMSK = Register(OTG_HS_DIEPMSK_val).init(base_address + 0x10);

    /// OTG_HS_DOEPMSK
    const OTG_HS_DOEPMSK_val = packed struct {
        /// XFRCM [0:0]
        /// Transfer completed interrupt
        XFRCM: u1 = 0,
        /// EPDM [1:1]
        /// Endpoint disabled interrupt
        EPDM: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUPM [3:3]
        /// SETUP phase done mask
        STUPM: u1 = 0,
        /// OTEPDM [4:4]
        /// OUT token received when endpoint
        OTEPDM: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets received
        B2BSTUP: u1 = 0,
        /// unused [7:7]
        _unused7: u1 = 0,
        /// OPEM [8:8]
        /// OUT packet error mask
        OPEM: u1 = 0,
        /// BOIM [9:9]
        /// BNA interrupt mask
        BOIM: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device OUT endpoint common interrupt
    pub const OTG_HS_DOEPMSK = Register(OTG_HS_DOEPMSK_val).init(base_address + 0x14);

    /// OTG_HS_DAINT
    const OTG_HS_DAINT_val = packed struct {
        /// IEPINT [0:15]
        /// IN endpoint interrupt bits
        IEPINT: u16 = 0,
        /// OEPINT [16:31]
        /// OUT endpoint interrupt
        OEPINT: u16 = 0,
    };
    /// OTG_HS device all endpoints interrupt
    pub const OTG_HS_DAINT = Register(OTG_HS_DAINT_val).init(base_address + 0x18);

    /// OTG_HS_DAINTMSK
    const OTG_HS_DAINTMSK_val = packed struct {
        /// IEPM [0:15]
        /// IN EP interrupt mask bits
        IEPM: u16 = 0,
        /// OEPM [16:31]
        /// OUT EP interrupt mask bits
        OEPM: u16 = 0,
    };
    /// OTG_HS all endpoints interrupt mask
    pub const OTG_HS_DAINTMSK = Register(OTG_HS_DAINTMSK_val).init(base_address + 0x1c);

    /// OTG_HS_DVBUSDIS
    const OTG_HS_DVBUSDIS_val = packed struct {
        /// VBUSDT [0:15]
        /// Device VBUS discharge time
        VBUSDT: u16 = 6103,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device VBUS discharge time
    pub const OTG_HS_DVBUSDIS = Register(OTG_HS_DVBUSDIS_val).init(base_address + 0x28);

    /// OTG_HS_DVBUSPULSE
    const OTG_HS_DVBUSPULSE_val = packed struct {
        /// DVBUSP [0:11]
        /// Device VBUS pulsing time
        DVBUSP: u12 = 1464,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device VBUS pulsing time
    pub const OTG_HS_DVBUSPULSE = Register(OTG_HS_DVBUSPULSE_val).init(base_address + 0x2c);

    /// OTG_HS_DTHRCTL
    const OTG_HS_DTHRCTL_val = packed struct {
        /// NONISOTHREN [0:0]
        /// Nonisochronous IN endpoints threshold
        NONISOTHREN: u1 = 0,
        /// ISOTHREN [1:1]
        /// ISO IN endpoint threshold
        ISOTHREN: u1 = 0,
        /// TXTHRLEN [2:10]
        /// Transmit threshold length
        TXTHRLEN: u9 = 0,
        /// unused [11:15]
        _unused11: u5 = 0,
        /// RXTHREN [16:16]
        /// Receive threshold enable
        RXTHREN: u1 = 0,
        /// RXTHRLEN [17:25]
        /// Receive threshold length
        RXTHRLEN: u9 = 0,
        /// unused [26:26]
        _unused26: u1 = 0,
        /// ARPEN [27:27]
        /// Arbiter parking enable
        ARPEN: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// OTG_HS Device threshold control
    pub const OTG_HS_DTHRCTL = Register(OTG_HS_DTHRCTL_val).init(base_address + 0x30);

    /// OTG_HS_DIEPEMPMSK
    const OTG_HS_DIEPEMPMSK_val = packed struct {
        /// INEPTXFEM [0:15]
        /// IN EP Tx FIFO empty interrupt mask
        INEPTXFEM: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint FIFO empty
    pub const OTG_HS_DIEPEMPMSK = Register(OTG_HS_DIEPEMPMSK_val).init(base_address + 0x34);

    /// OTG_HS_DEACHINT
    const OTG_HS_DEACHINT_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// IEP1INT [1:1]
        /// IN endpoint 1interrupt bit
        IEP1INT: u1 = 0,
        /// unused [2:16]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u1 = 0,
        /// OEP1INT [17:17]
        /// OUT endpoint 1 interrupt
        OEP1INT: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device each endpoint interrupt
    pub const OTG_HS_DEACHINT = Register(OTG_HS_DEACHINT_val).init(base_address + 0x38);

    /// OTG_HS_DEACHINTMSK
    const OTG_HS_DEACHINTMSK_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// IEP1INTM [1:1]
        /// IN Endpoint 1 interrupt mask
        IEP1INTM: u1 = 0,
        /// unused [2:16]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u1 = 0,
        /// OEP1INTM [17:17]
        /// OUT Endpoint 1 interrupt mask
        OEP1INTM: u1 = 0,
        /// unused [18:31]
        _unused18: u6 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device each endpoint interrupt
    pub const OTG_HS_DEACHINTMSK = Register(OTG_HS_DEACHINTMSK_val).init(base_address + 0x3c);

    /// OTG_HS_DIEPCTL0
    const OTG_HS_DIEPCTL0_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-0 control
    pub const OTG_HS_DIEPCTL0 = Register(OTG_HS_DIEPCTL0_val).init(base_address + 0x100);

    /// OTG_HS_DIEPCTL1
    const OTG_HS_DIEPCTL1_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-1 control
    pub const OTG_HS_DIEPCTL1 = Register(OTG_HS_DIEPCTL1_val).init(base_address + 0x120);

    /// OTG_HS_DIEPCTL2
    const OTG_HS_DIEPCTL2_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-2 control
    pub const OTG_HS_DIEPCTL2 = Register(OTG_HS_DIEPCTL2_val).init(base_address + 0x140);

    /// OTG_HS_DIEPCTL3
    const OTG_HS_DIEPCTL3_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-3 control
    pub const OTG_HS_DIEPCTL3 = Register(OTG_HS_DIEPCTL3_val).init(base_address + 0x160);

    /// OTG_HS_DIEPCTL4
    const OTG_HS_DIEPCTL4_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-4 control
    pub const OTG_HS_DIEPCTL4 = Register(OTG_HS_DIEPCTL4_val).init(base_address + 0x180);

    /// OTG_HS_DIEPCTL5
    const OTG_HS_DIEPCTL5_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-5 control
    pub const OTG_HS_DIEPCTL5 = Register(OTG_HS_DIEPCTL5_val).init(base_address + 0x1a0);

    /// OTG_HS_DIEPCTL6
    const OTG_HS_DIEPCTL6_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-6 control
    pub const OTG_HS_DIEPCTL6 = Register(OTG_HS_DIEPCTL6_val).init(base_address + 0x1c0);

    /// OTG_HS_DIEPCTL7
    const OTG_HS_DIEPCTL7_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even/odd frame
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// unused [20:20]
        _unused20: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// TXFNUM [22:25]
        /// TxFIFO number
        TXFNUM: u4 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-7 control
    pub const OTG_HS_DIEPCTL7 = Register(OTG_HS_DIEPCTL7_val).init(base_address + 0x1e0);

    /// OTG_HS_DIEPINT0
    const OTG_HS_DIEPINT0_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 1,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-0 interrupt
    pub const OTG_HS_DIEPINT0 = Register(OTG_HS_DIEPINT0_val).init(base_address + 0x108);

    /// OTG_HS_DIEPINT1
    const OTG_HS_DIEPINT1_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-1 interrupt
    pub const OTG_HS_DIEPINT1 = Register(OTG_HS_DIEPINT1_val).init(base_address + 0x128);

    /// OTG_HS_DIEPINT2
    const OTG_HS_DIEPINT2_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-2 interrupt
    pub const OTG_HS_DIEPINT2 = Register(OTG_HS_DIEPINT2_val).init(base_address + 0x148);

    /// OTG_HS_DIEPINT3
    const OTG_HS_DIEPINT3_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-3 interrupt
    pub const OTG_HS_DIEPINT3 = Register(OTG_HS_DIEPINT3_val).init(base_address + 0x168);

    /// OTG_HS_DIEPINT4
    const OTG_HS_DIEPINT4_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-4 interrupt
    pub const OTG_HS_DIEPINT4 = Register(OTG_HS_DIEPINT4_val).init(base_address + 0x188);

    /// OTG_HS_DIEPINT5
    const OTG_HS_DIEPINT5_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-5 interrupt
    pub const OTG_HS_DIEPINT5 = Register(OTG_HS_DIEPINT5_val).init(base_address + 0x1a8);

    /// OTG_HS_DIEPINT6
    const OTG_HS_DIEPINT6_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-6 interrupt
    pub const OTG_HS_DIEPINT6 = Register(OTG_HS_DIEPINT6_val).init(base_address + 0x1c8);

    /// OTG_HS_DIEPINT7
    const OTG_HS_DIEPINT7_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// TOC [3:3]
        /// Timeout condition
        TOC: u1 = 0,
        /// ITTXFE [4:4]
        /// IN token received when TxFIFO is
        ITTXFE: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// INEPNE [6:6]
        /// IN endpoint NAK effective
        INEPNE: u1 = 0,
        /// TXFE [7:7]
        /// Transmit FIFO empty
        TXFE: u1 = 0,
        /// TXFIFOUDRN [8:8]
        /// Transmit Fifo Underrun
        TXFIFOUDRN: u1 = 0,
        /// BNA [9:9]
        /// Buffer not available
        BNA: u1 = 0,
        /// unused [10:10]
        _unused10: u1 = 0,
        /// PKTDRPSTS [11:11]
        /// Packet dropped status
        PKTDRPSTS: u1 = 0,
        /// BERR [12:12]
        /// Babble error interrupt
        BERR: u1 = 0,
        /// NAK [13:13]
        /// NAK interrupt
        NAK: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG device endpoint-7 interrupt
    pub const OTG_HS_DIEPINT7 = Register(OTG_HS_DIEPINT7_val).init(base_address + 0x1e8);

    /// OTG_HS_DIEPTSIZ0
    const OTG_HS_DIEPTSIZ0_val = packed struct {
        /// XFRSIZ [0:6]
        /// Transfer size
        XFRSIZ: u7 = 0,
        /// unused [7:18]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u3 = 0,
        /// PKTCNT [19:20]
        /// Packet count
        PKTCNT: u2 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint 0 transfer size
    pub const OTG_HS_DIEPTSIZ0 = Register(OTG_HS_DIEPTSIZ0_val).init(base_address + 0x110);

    /// OTG_HS_DIEPDMA1
    const OTG_HS_DIEPDMA1_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS device endpoint-1 DMA address
    pub const OTG_HS_DIEPDMA1 = Register(OTG_HS_DIEPDMA1_val).init(base_address + 0x114);

    /// OTG_HS_DIEPDMA2
    const OTG_HS_DIEPDMA2_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS device endpoint-2 DMA address
    pub const OTG_HS_DIEPDMA2 = Register(OTG_HS_DIEPDMA2_val).init(base_address + 0x134);

    /// OTG_HS_DIEPDMA3
    const OTG_HS_DIEPDMA3_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS device endpoint-3 DMA address
    pub const OTG_HS_DIEPDMA3 = Register(OTG_HS_DIEPDMA3_val).init(base_address + 0x154);

    /// OTG_HS_DIEPDMA4
    const OTG_HS_DIEPDMA4_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS device endpoint-4 DMA address
    pub const OTG_HS_DIEPDMA4 = Register(OTG_HS_DIEPDMA4_val).init(base_address + 0x174);

    /// OTG_HS_DIEPDMA5
    const OTG_HS_DIEPDMA5_val = packed struct {
        /// DMAADDR [0:31]
        /// DMA address
        DMAADDR: u32 = 0,
    };
    /// OTG_HS device endpoint-5 DMA address
    pub const OTG_HS_DIEPDMA5 = Register(OTG_HS_DIEPDMA5_val).init(base_address + 0x194);

    /// OTG_HS_DTXFSTS0
    const OTG_HS_DTXFSTS0_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS0 = Register(OTG_HS_DTXFSTS0_val).init(base_address + 0x118);

    /// OTG_HS_DTXFSTS1
    const OTG_HS_DTXFSTS1_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS1 = Register(OTG_HS_DTXFSTS1_val).init(base_address + 0x138);

    /// OTG_HS_DTXFSTS2
    const OTG_HS_DTXFSTS2_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS2 = Register(OTG_HS_DTXFSTS2_val).init(base_address + 0x158);

    /// OTG_HS_DTXFSTS3
    const OTG_HS_DTXFSTS3_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS3 = Register(OTG_HS_DTXFSTS3_val).init(base_address + 0x178);

    /// OTG_HS_DTXFSTS4
    const OTG_HS_DTXFSTS4_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS4 = Register(OTG_HS_DTXFSTS4_val).init(base_address + 0x198);

    /// OTG_HS_DTXFSTS5
    const OTG_HS_DTXFSTS5_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS5 = Register(OTG_HS_DTXFSTS5_val).init(base_address + 0x1b8);

    /// OTG_HS_DIEPTSIZ1
    const OTG_HS_DIEPTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ1 = Register(OTG_HS_DIEPTSIZ1_val).init(base_address + 0x130);

    /// OTG_HS_DIEPTSIZ2
    const OTG_HS_DIEPTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ2 = Register(OTG_HS_DIEPTSIZ2_val).init(base_address + 0x150);

    /// OTG_HS_DIEPTSIZ3
    const OTG_HS_DIEPTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ3 = Register(OTG_HS_DIEPTSIZ3_val).init(base_address + 0x170);

    /// OTG_HS_DIEPTSIZ4
    const OTG_HS_DIEPTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ4 = Register(OTG_HS_DIEPTSIZ4_val).init(base_address + 0x190);

    /// OTG_HS_DIEPTSIZ5
    const OTG_HS_DIEPTSIZ5_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ5 = Register(OTG_HS_DIEPTSIZ5_val).init(base_address + 0x1b0);

    /// OTG_HS_DOEPCTL0
    const OTG_HS_DOEPCTL0_val = packed struct {
        /// MPSIZ [0:1]
        /// Maximum packet size
        MPSIZ: u2 = 0,
        /// unused [2:14]
        _unused2: u6 = 0,
        _unused8: u7 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 1,
        /// unused [16:16]
        _unused16: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// unused [28:29]
        _unused28: u2 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG_HS device control OUT endpoint 0 control
    pub const OTG_HS_DOEPCTL0 = Register(OTG_HS_DOEPCTL0_val).init(base_address + 0x300);

    /// OTG_HS_DOEPCTL1
    const OTG_HS_DOEPCTL1_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-1 control
    pub const OTG_HS_DOEPCTL1 = Register(OTG_HS_DOEPCTL1_val).init(base_address + 0x320);

    /// OTG_HS_DOEPCTL2
    const OTG_HS_DOEPCTL2_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-2 control
    pub const OTG_HS_DOEPCTL2 = Register(OTG_HS_DOEPCTL2_val).init(base_address + 0x340);

    /// OTG_HS_DOEPCTL3
    const OTG_HS_DOEPCTL3_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-3 control
    pub const OTG_HS_DOEPCTL3 = Register(OTG_HS_DOEPCTL3_val).init(base_address + 0x360);

    /// OTG_HS_DOEPINT0
    const OTG_HS_DOEPINT0_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 1,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-0 interrupt
    pub const OTG_HS_DOEPINT0 = Register(OTG_HS_DOEPINT0_val).init(base_address + 0x308);

    /// OTG_HS_DOEPINT1
    const OTG_HS_DOEPINT1_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-1 interrupt
    pub const OTG_HS_DOEPINT1 = Register(OTG_HS_DOEPINT1_val).init(base_address + 0x328);

    /// OTG_HS_DOEPINT2
    const OTG_HS_DOEPINT2_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-2 interrupt
    pub const OTG_HS_DOEPINT2 = Register(OTG_HS_DOEPINT2_val).init(base_address + 0x348);

    /// OTG_HS_DOEPINT3
    const OTG_HS_DOEPINT3_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-3 interrupt
    pub const OTG_HS_DOEPINT3 = Register(OTG_HS_DOEPINT3_val).init(base_address + 0x368);

    /// OTG_HS_DOEPINT4
    const OTG_HS_DOEPINT4_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-4 interrupt
    pub const OTG_HS_DOEPINT4 = Register(OTG_HS_DOEPINT4_val).init(base_address + 0x388);

    /// OTG_HS_DOEPINT5
    const OTG_HS_DOEPINT5_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-5 interrupt
    pub const OTG_HS_DOEPINT5 = Register(OTG_HS_DOEPINT5_val).init(base_address + 0x3a8);

    /// OTG_HS_DOEPINT6
    const OTG_HS_DOEPINT6_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-6 interrupt
    pub const OTG_HS_DOEPINT6 = Register(OTG_HS_DOEPINT6_val).init(base_address + 0x3c8);

    /// OTG_HS_DOEPINT7
    const OTG_HS_DOEPINT7_val = packed struct {
        /// XFRC [0:0]
        /// Transfer completed
        XFRC: u1 = 0,
        /// EPDISD [1:1]
        /// Endpoint disabled
        EPDISD: u1 = 0,
        /// unused [2:2]
        _unused2: u1 = 0,
        /// STUP [3:3]
        /// SETUP phase done
        STUP: u1 = 0,
        /// OTEPDIS [4:4]
        /// OUT token received when endpoint
        OTEPDIS: u1 = 0,
        /// unused [5:5]
        _unused5: u1 = 0,
        /// B2BSTUP [6:6]
        /// Back-to-back SETUP packets
        B2BSTUP: u1 = 0,
        /// unused [7:13]
        _unused7: u1 = 0,
        _unused8: u6 = 0,
        /// NYET [14:14]
        /// NYET interrupt
        NYET: u1 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device endpoint-7 interrupt
    pub const OTG_HS_DOEPINT7 = Register(OTG_HS_DOEPINT7_val).init(base_address + 0x3e8);

    /// OTG_HS_DOEPTSIZ0
    const OTG_HS_DOEPTSIZ0_val = packed struct {
        /// XFRSIZ [0:6]
        /// Transfer size
        XFRSIZ: u7 = 0,
        /// unused [7:18]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u3 = 0,
        /// PKTCNT [19:19]
        /// Packet count
        PKTCNT: u1 = 0,
        /// unused [20:28]
        _unused20: u4 = 0,
        _unused24: u5 = 0,
        /// STUPCNT [29:30]
        /// SETUP packet count
        STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-0 transfer size
    pub const OTG_HS_DOEPTSIZ0 = Register(OTG_HS_DOEPTSIZ0_val).init(base_address + 0x310);

    /// OTG_HS_DOEPTSIZ1
    const OTG_HS_DOEPTSIZ1_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-1 transfer size
    pub const OTG_HS_DOEPTSIZ1 = Register(OTG_HS_DOEPTSIZ1_val).init(base_address + 0x330);

    /// OTG_HS_DOEPTSIZ2
    const OTG_HS_DOEPTSIZ2_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-2 transfer size
    pub const OTG_HS_DOEPTSIZ2 = Register(OTG_HS_DOEPTSIZ2_val).init(base_address + 0x350);

    /// OTG_HS_DOEPTSIZ3
    const OTG_HS_DOEPTSIZ3_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-3 transfer size
    pub const OTG_HS_DOEPTSIZ3 = Register(OTG_HS_DOEPTSIZ3_val).init(base_address + 0x370);

    /// OTG_HS_DOEPTSIZ4
    const OTG_HS_DOEPTSIZ4_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-4 transfer size
    pub const OTG_HS_DOEPTSIZ4 = Register(OTG_HS_DOEPTSIZ4_val).init(base_address + 0x390);

    /// OTG_HS_DIEPTSIZ6
    const OTG_HS_DIEPTSIZ6_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ6 = Register(OTG_HS_DIEPTSIZ6_val).init(base_address + 0x1a0);

    /// OTG_HS_DTXFSTS6
    const OTG_HS_DTXFSTS6_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS6 = Register(OTG_HS_DTXFSTS6_val).init(base_address + 0x1a4);

    /// OTG_HS_DIEPTSIZ7
    const OTG_HS_DIEPTSIZ7_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// MCNT [29:30]
        /// Multi count
        MCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint transfer size
    pub const OTG_HS_DIEPTSIZ7 = Register(OTG_HS_DIEPTSIZ7_val).init(base_address + 0x1a8);

    /// OTG_HS_DTXFSTS7
    const OTG_HS_DTXFSTS7_val = packed struct {
        /// INEPTFSAV [0:15]
        /// IN endpoint TxFIFO space
        INEPTFSAV: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// OTG_HS device IN endpoint transmit FIFO
    pub const OTG_HS_DTXFSTS7 = Register(OTG_HS_DTXFSTS7_val).init(base_address + 0x1ac);

    /// OTG_HS_DOEPCTL4
    const OTG_HS_DOEPCTL4_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-4 control
    pub const OTG_HS_DOEPCTL4 = Register(OTG_HS_DOEPCTL4_val).init(base_address + 0x380);

    /// OTG_HS_DOEPCTL5
    const OTG_HS_DOEPCTL5_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-5 control
    pub const OTG_HS_DOEPCTL5 = Register(OTG_HS_DOEPCTL5_val).init(base_address + 0x3a0);

    /// OTG_HS_DOEPCTL6
    const OTG_HS_DOEPCTL6_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-6 control
    pub const OTG_HS_DOEPCTL6 = Register(OTG_HS_DOEPCTL6_val).init(base_address + 0x3c0);

    /// OTG_HS_DOEPCTL7
    const OTG_HS_DOEPCTL7_val = packed struct {
        /// MPSIZ [0:10]
        /// Maximum packet size
        MPSIZ: u11 = 0,
        /// unused [11:14]
        _unused11: u4 = 0,
        /// USBAEP [15:15]
        /// USB active endpoint
        USBAEP: u1 = 0,
        /// EONUM_DPID [16:16]
        /// Even odd frame/Endpoint data
        EONUM_DPID: u1 = 0,
        /// NAKSTS [17:17]
        /// NAK status
        NAKSTS: u1 = 0,
        /// EPTYP [18:19]
        /// Endpoint type
        EPTYP: u2 = 0,
        /// SNPM [20:20]
        /// Snoop mode
        SNPM: u1 = 0,
        /// Stall [21:21]
        /// STALL handshake
        Stall: u1 = 0,
        /// unused [22:25]
        _unused22: u2 = 0,
        _unused24: u2 = 0,
        /// CNAK [26:26]
        /// Clear NAK
        CNAK: u1 = 0,
        /// SNAK [27:27]
        /// Set NAK
        SNAK: u1 = 0,
        /// SD0PID_SEVNFRM [28:28]
        /// Set DATA0 PID/Set even
        SD0PID_SEVNFRM: u1 = 0,
        /// SODDFRM [29:29]
        /// Set odd frame
        SODDFRM: u1 = 0,
        /// EPDIS [30:30]
        /// Endpoint disable
        EPDIS: u1 = 0,
        /// EPENA [31:31]
        /// Endpoint enable
        EPENA: u1 = 0,
    };
    /// OTG device endpoint-7 control
    pub const OTG_HS_DOEPCTL7 = Register(OTG_HS_DOEPCTL7_val).init(base_address + 0x3e0);

    /// OTG_HS_DOEPTSIZ5
    const OTG_HS_DOEPTSIZ5_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-5 transfer size
    pub const OTG_HS_DOEPTSIZ5 = Register(OTG_HS_DOEPTSIZ5_val).init(base_address + 0x3b0);

    /// OTG_HS_DOEPTSIZ6
    const OTG_HS_DOEPTSIZ6_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-6 transfer size
    pub const OTG_HS_DOEPTSIZ6 = Register(OTG_HS_DOEPTSIZ6_val).init(base_address + 0x3d0);

    /// OTG_HS_DOEPTSIZ7
    const OTG_HS_DOEPTSIZ7_val = packed struct {
        /// XFRSIZ [0:18]
        /// Transfer size
        XFRSIZ: u19 = 0,
        /// PKTCNT [19:28]
        /// Packet count
        PKTCNT: u10 = 0,
        /// RXDPID_STUPCNT [29:30]
        /// Received data PID/SETUP packet
        RXDPID_STUPCNT: u2 = 0,
        /// unused [31:31]
        _unused31: u1 = 0,
    };
    /// OTG_HS device endpoint-7 transfer size
    pub const OTG_HS_DOEPTSIZ7 = Register(OTG_HS_DOEPTSIZ7_val).init(base_address + 0x3f0);
};

/// USB on the go high speed
pub const OTG_HS_PWRCLK = struct {
    const base_address = 0x40040e00;
    /// OTG_HS_PCGCR
    const OTG_HS_PCGCR_val = packed struct {
        /// STPPCLK [0:0]
        /// Stop PHY clock
        STPPCLK: u1 = 0,
        /// GATEHCLK [1:1]
        /// Gate HCLK
        GATEHCLK: u1 = 0,
        /// unused [2:3]
        _unused2: u2 = 0,
        /// PHYSUSP [4:4]
        /// PHY suspended
        PHYSUSP: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// Power and clock gating control
    pub const OTG_HS_PCGCR = Register(OTG_HS_PCGCR_val).init(base_address + 0x0);
};

/// DSI Host
pub const DSI = struct {
    const base_address = 0x40016c00;
    /// DSI_VR
    const DSI_VR_val = packed struct {
        /// VERSION [0:31]
        /// Version of the DSI Host
        VERSION: u32 = 825438250,
    };
    /// DSI Host Version Register
    pub const DSI_VR = Register(DSI_VR_val).init(base_address + 0x0);

    /// DSI_CR
    const DSI_CR_val = packed struct {
        /// EN [0:0]
        /// Enable
        EN: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Control Register
    pub const DSI_CR = Register(DSI_CR_val).init(base_address + 0x4);

    /// DSI_CCR
    const DSI_CCR_val = packed struct {
        /// TXECKDIV [0:7]
        /// TX Escape Clock Division
        TXECKDIV: u8 = 0,
        /// TOCKDIV [8:15]
        /// Timeout Clock Division
        TOCKDIV: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI HOST Clock Control
    pub const DSI_CCR = Register(DSI_CCR_val).init(base_address + 0x8);

    /// DSI_LVCIDR
    const DSI_LVCIDR_val = packed struct {
        /// VCID [0:1]
        /// Virtual Channel ID
        VCID: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC VCID Register
    pub const DSI_LVCIDR = Register(DSI_LVCIDR_val).init(base_address + 0xc);

    /// DSI_LCOLCR
    const DSI_LCOLCR_val = packed struct {
        /// COLC [0:3]
        /// Color Coding
        COLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// LPE [8:8]
        /// Loosely Packet Enable
        LPE: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC Color Coding
    pub const DSI_LCOLCR = Register(DSI_LCOLCR_val).init(base_address + 0x10);

    /// DSI_LPCR
    const DSI_LPCR_val = packed struct {
        /// DEP [0:0]
        /// Data Enable Polarity
        DEP: u1 = 0,
        /// VSP [1:1]
        /// VSYNC Polarity
        VSP: u1 = 0,
        /// HSP [2:2]
        /// HSYNC Polarity
        HSP: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC Polarity Configuration
    pub const DSI_LPCR = Register(DSI_LPCR_val).init(base_address + 0x14);

    /// DSI_LPMCR
    const DSI_LPMCR_val = packed struct {
        /// VLPSIZE [0:7]
        /// VACT Largest Packet Size
        VLPSIZE: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// LPSIZE [16:23]
        /// Largest Packet Size
        LPSIZE: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DSI Host Low-Power mode Configuration
    pub const DSI_LPMCR = Register(DSI_LPMCR_val).init(base_address + 0x18);

    /// DSI_PCR
    const DSI_PCR_val = packed struct {
        /// ETTXE [0:0]
        /// EoTp Transmission Enable
        ETTXE: u1 = 0,
        /// ETRXE [1:1]
        /// EoTp Reception Enable
        ETRXE: u1 = 0,
        /// BTAE [2:2]
        /// Bus Turn Around Enable
        BTAE: u1 = 0,
        /// ECCRXE [3:3]
        /// ECC Reception Enable
        ECCRXE: u1 = 0,
        /// CRCRXE [4:4]
        /// CRC Reception Enable
        CRCRXE: u1 = 0,
        /// unused [5:31]
        _unused5: u3 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Protocol Configuration
    pub const DSI_PCR = Register(DSI_PCR_val).init(base_address + 0x2c);

    /// DSI_GVCIDR
    const DSI_GVCIDR_val = packed struct {
        /// VCID [0:1]
        /// Virtual Channel ID
        VCID: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Generic VCID Register
    pub const DSI_GVCIDR = Register(DSI_GVCIDR_val).init(base_address + 0x30);

    /// DSI_MCR
    const DSI_MCR_val = packed struct {
        /// CMDM [0:0]
        /// Command mode
        CMDM: u1 = 0,
        /// unused [1:31]
        _unused1: u7 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host mode Configuration
    pub const DSI_MCR = Register(DSI_MCR_val).init(base_address + 0x34);

    /// DSI_VMCR
    const DSI_VMCR_val = packed struct {
        /// VMT [0:1]
        /// Video mode Type
        VMT: u2 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// LPVSAE [8:8]
        /// Low-Power Vertical Sync Active
        LPVSAE: u1 = 0,
        /// LPVBPE [9:9]
        /// Low-power Vertical Back-Porch
        LPVBPE: u1 = 0,
        /// LPVFPE [10:10]
        /// Low-power Vertical Front-porch
        LPVFPE: u1 = 0,
        /// LPVAE [11:11]
        /// Low-Power Vertical Active
        LPVAE: u1 = 0,
        /// LPHBPE [12:12]
        /// Low-Power Horizontal Back-Porch
        LPHBPE: u1 = 0,
        /// LPHFPE [13:13]
        /// Low-Power Horizontal Front-Porch
        LPHFPE: u1 = 0,
        /// FBTAAE [14:14]
        /// Frame Bus-Turn-Around Acknowledge
        FBTAAE: u1 = 0,
        /// LPCE [15:15]
        /// Low-Power Command Enable
        LPCE: u1 = 0,
        /// PGE [16:16]
        /// Pattern Generator Enable
        PGE: u1 = 0,
        /// unused [17:19]
        _unused17: u3 = 0,
        /// PGM [20:20]
        /// Pattern Generator mode
        PGM: u1 = 0,
        /// unused [21:23]
        _unused21: u3 = 0,
        /// PGO [24:24]
        /// Pattern Generator
        PGO: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// DSI Host Video mode Configuration
    pub const DSI_VMCR = Register(DSI_VMCR_val).init(base_address + 0x38);

    /// DSI_VPCR
    const DSI_VPCR_val = packed struct {
        /// VPSIZE [0:13]
        /// Video Packet Size
        VPSIZE: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Packet Configuration
    pub const DSI_VPCR = Register(DSI_VPCR_val).init(base_address + 0x3c);

    /// DSI_VCCR
    const DSI_VCCR_val = packed struct {
        /// NUMC [0:12]
        /// Number of Chunks
        NUMC: u13 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Chunks Configuration
    pub const DSI_VCCR = Register(DSI_VCCR_val).init(base_address + 0x40);

    /// DSI_VNPCR
    const DSI_VNPCR_val = packed struct {
        /// NPSIZE [0:12]
        /// Null Packet Size
        NPSIZE: u13 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Null Packet Configuration
    pub const DSI_VNPCR = Register(DSI_VNPCR_val).init(base_address + 0x44);

    /// DSI_VHSACR
    const DSI_VHSACR_val = packed struct {
        /// HSA [0:11]
        /// Horizontal Synchronism Active
        HSA: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video HSA Configuration
    pub const DSI_VHSACR = Register(DSI_VHSACR_val).init(base_address + 0x48);

    /// DSI_VHBPCR
    const DSI_VHBPCR_val = packed struct {
        /// HBP [0:11]
        /// Horizontal Back-Porch
        HBP: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video HBP Configuration
    pub const DSI_VHBPCR = Register(DSI_VHBPCR_val).init(base_address + 0x4c);

    /// DSI_VLCR
    const DSI_VLCR_val = packed struct {
        /// HLINE [0:14]
        /// Horizontal Line duration
        HLINE: u15 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Line Configuration
    pub const DSI_VLCR = Register(DSI_VLCR_val).init(base_address + 0x50);

    /// DSI_VVSACR
    const DSI_VVSACR_val = packed struct {
        /// VSA [0:9]
        /// Vertical Synchronism Active
        VSA: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VSA Configuration
    pub const DSI_VVSACR = Register(DSI_VVSACR_val).init(base_address + 0x54);

    /// DSI_VVBPCR
    const DSI_VVBPCR_val = packed struct {
        /// VBP [0:9]
        /// Vertical Back-Porch
        VBP: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VBP Configuration
    pub const DSI_VVBPCR = Register(DSI_VVBPCR_val).init(base_address + 0x58);

    /// DSI_VVFPCR
    const DSI_VVFPCR_val = packed struct {
        /// VFP [0:9]
        /// Vertical Front-Porch
        VFP: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VFP Configuration
    pub const DSI_VVFPCR = Register(DSI_VVFPCR_val).init(base_address + 0x5c);

    /// DSI_VVACR
    const DSI_VVACR_val = packed struct {
        /// VA [0:13]
        /// Vertical Active duration
        VA: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VA Configuration
    pub const DSI_VVACR = Register(DSI_VVACR_val).init(base_address + 0x60);

    /// DSI_LCCR
    const DSI_LCCR_val = packed struct {
        /// CMDSIZE [0:15]
        /// Command Size
        CMDSIZE: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC Command Configuration
    pub const DSI_LCCR = Register(DSI_LCCR_val).init(base_address + 0x64);

    /// DSI_CMCR
    const DSI_CMCR_val = packed struct {
        /// TEARE [0:0]
        /// Tearing Effect Acknowledge Request
        TEARE: u1 = 0,
        /// ARE [1:1]
        /// Acknowledge Request Enable
        ARE: u1 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// GSW0TX [8:8]
        /// Generic Short Write Zero parameters
        GSW0TX: u1 = 0,
        /// GSW1TX [9:9]
        /// Generic Short Write One parameters
        GSW1TX: u1 = 0,
        /// GSW2TX [10:10]
        /// Generic Short Write Two parameters
        GSW2TX: u1 = 0,
        /// GSR0TX [11:11]
        /// Generic Short Read Zero parameters
        GSR0TX: u1 = 0,
        /// GSR1TX [12:12]
        /// Generic Short Read One parameters
        GSR1TX: u1 = 0,
        /// GSR2TX [13:13]
        /// Generic Short Read Two parameters
        GSR2TX: u1 = 0,
        /// GLWTX [14:14]
        /// Generic Long Write
        GLWTX: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// DSW0TX [16:16]
        /// DCS Short Write Zero parameter
        DSW0TX: u1 = 0,
        /// DSW1TX [17:17]
        /// DCS Short Read One parameter
        DSW1TX: u1 = 0,
        /// DSR0TX [18:18]
        /// DCS Short Read Zero parameter
        DSR0TX: u1 = 0,
        /// DLWTX [19:19]
        /// DCS Long Write
        DLWTX: u1 = 0,
        /// unused [20:23]
        _unused20: u4 = 0,
        /// MRDPS [24:24]
        /// Maximum Read Packet Size
        MRDPS: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// DSI Host Command mode Configuration
    pub const DSI_CMCR = Register(DSI_CMCR_val).init(base_address + 0x68);

    /// DSI_GHCR
    const DSI_GHCR_val = packed struct {
        /// DT [0:5]
        /// Type
        DT: u6 = 0,
        /// VCID [6:7]
        /// Channel
        VCID: u2 = 0,
        /// WCLSB [8:15]
        /// WordCount LSB
        WCLSB: u8 = 0,
        /// WCMSB [16:23]
        /// WordCount MSB
        WCMSB: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DSI Host Generic Header Configuration
    pub const DSI_GHCR = Register(DSI_GHCR_val).init(base_address + 0x6c);

    /// DSI_GPDR
    const DSI_GPDR_val = packed struct {
        /// DATA1 [0:7]
        /// Payload Byte 1
        DATA1: u8 = 0,
        /// DATA2 [8:15]
        /// Payload Byte 2
        DATA2: u8 = 0,
        /// DATA3 [16:23]
        /// Payload Byte 3
        DATA3: u8 = 0,
        /// DATA4 [24:31]
        /// Payload Byte 4
        DATA4: u8 = 0,
    };
    /// DSI Host Generic Payload Data
    pub const DSI_GPDR = Register(DSI_GPDR_val).init(base_address + 0x70);

    /// DSI_GPSR
    const DSI_GPSR_val = packed struct {
        /// CMDFE [0:0]
        /// Command FIFO Empty
        CMDFE: u1 = 0,
        /// CMDFF [1:1]
        /// Command FIFO Full
        CMDFF: u1 = 0,
        /// PWRFE [2:2]
        /// Payload Write FIFO Empty
        PWRFE: u1 = 0,
        /// PWRFF [3:3]
        /// Payload Write FIFO Full
        PWRFF: u1 = 0,
        /// PRDFE [4:4]
        /// Payload Read FIFO Empty
        PRDFE: u1 = 0,
        /// PRDFF [5:5]
        /// Payload Read FIFO Full
        PRDFF: u1 = 0,
        /// RCB [6:6]
        /// Read Command Busy
        RCB: u1 = 0,
        /// unused [7:31]
        _unused7: u1 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Generic Packet Status
    pub const DSI_GPSR = Register(DSI_GPSR_val).init(base_address + 0x74);

    /// DSI_TCCR0
    const DSI_TCCR0_val = packed struct {
        /// LPRX_TOCNT [0:15]
        /// Low-power Reception Timeout
        LPRX_TOCNT: u16 = 0,
        /// HSTX_TOCNT [16:31]
        /// High-Speed Transmission Timeout
        HSTX_TOCNT: u16 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR0 = Register(DSI_TCCR0_val).init(base_address + 0x78);

    /// DSI_TCCR1
    const DSI_TCCR1_val = packed struct {
        /// HSRD_TOCNT [0:15]
        /// High-Speed Read Timeout
        HSRD_TOCNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR1 = Register(DSI_TCCR1_val).init(base_address + 0x7c);

    /// DSI_TCCR2
    const DSI_TCCR2_val = packed struct {
        /// LPRD_TOCNT [0:15]
        /// Low-Power Read Timeout
        LPRD_TOCNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR2 = Register(DSI_TCCR2_val).init(base_address + 0x80);

    /// DSI_TCCR3
    const DSI_TCCR3_val = packed struct {
        /// HSWR_TOCNT [0:15]
        /// High-Speed Write Timeout
        HSWR_TOCNT: u16 = 0,
        /// unused [16:23]
        _unused16: u8 = 0,
        /// PM [24:24]
        /// Presp mode
        PM: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR3 = Register(DSI_TCCR3_val).init(base_address + 0x84);

    /// DSI_TCCR4
    const DSI_TCCR4_val = packed struct {
        /// LSWR_TOCNT [0:15]
        /// Low-Power Write Timeout
        LSWR_TOCNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR4 = Register(DSI_TCCR4_val).init(base_address + 0x88);

    /// DSI_TCCR5
    const DSI_TCCR5_val = packed struct {
        /// BTA_TOCNT [0:15]
        /// Bus-Turn-Around Timeout
        BTA_TOCNT: u16 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Timeout Counter Configuration
    pub const DSI_TCCR5 = Register(DSI_TCCR5_val).init(base_address + 0x8c);

    /// DSI_CLCR
    const DSI_CLCR_val = packed struct {
        /// DPCC [0:0]
        /// D-PHY Clock Control
        DPCC: u1 = 0,
        /// ACR [1:1]
        /// Automatic Clock lane
        ACR: u1 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Clock Lane Configuration
    pub const DSI_CLCR = Register(DSI_CLCR_val).init(base_address + 0x94);

    /// DSI_CLTCR
    const DSI_CLTCR_val = packed struct {
        /// LP2HS_TIME [0:9]
        /// Low-Power to High-Speed
        LP2HS_TIME: u10 = 0,
        /// unused [10:15]
        _unused10: u6 = 0,
        /// HS2LP_TIME [16:25]
        /// High-Speed to Low-Power
        HS2LP_TIME: u10 = 0,
        /// unused [26:31]
        _unused26: u6 = 0,
    };
    /// DSI Host Clock Lane Timer Configuration
    pub const DSI_CLTCR = Register(DSI_CLTCR_val).init(base_address + 0x98);

    /// DSI_DLTCR
    const DSI_DLTCR_val = packed struct {
        /// MRD_TIME [0:14]
        /// Maximum Read Time
        MRD_TIME: u15 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// LP2HS_TIME [16:23]
        /// Low-Power To High-Speed
        LP2HS_TIME: u8 = 0,
        /// HS2LP_TIME [24:31]
        /// High-Speed To Low-Power
        HS2LP_TIME: u8 = 0,
    };
    /// DSI Host Data Lane Timer Configuration
    pub const DSI_DLTCR = Register(DSI_DLTCR_val).init(base_address + 0x9c);

    /// DSI_PCTLR
    const DSI_PCTLR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// DEN [1:1]
        /// Digital Enable
        DEN: u1 = 0,
        /// CKE [2:2]
        /// Clock Enable
        CKE: u1 = 0,
        /// unused [3:31]
        _unused3: u5 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host PHY Control Register
    pub const DSI_PCTLR = Register(DSI_PCTLR_val).init(base_address + 0xa0);

    /// DSI_PCONFR
    const DSI_PCONFR_val = packed struct {
        /// NL [0:1]
        /// Number of Lanes
        NL: u2 = 0,
        /// unused [2:7]
        _unused2: u6 = 0,
        /// SW_TIME [8:15]
        /// Stop Wait Time
        SW_TIME: u8 = 0,
        /// unused [16:31]
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host PHY Configuration
    pub const DSI_PCONFR = Register(DSI_PCONFR_val).init(base_address + 0xa4);

    /// DSI_PUCR
    const DSI_PUCR_val = packed struct {
        /// URCL [0:0]
        /// ULPS Request on Clock Lane
        URCL: u1 = 0,
        /// UECL [1:1]
        /// ULPS Exit on Clock Lane
        UECL: u1 = 0,
        /// URDL [2:2]
        /// ULPS Request on Data Lane
        URDL: u1 = 0,
        /// UEDL [3:3]
        /// ULPS Exit on Data Lane
        UEDL: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host PHY ULPS Control
    pub const DSI_PUCR = Register(DSI_PUCR_val).init(base_address + 0xa8);

    /// DSI_PTTCR
    const DSI_PTTCR_val = packed struct {
        /// TX_TRIG [0:3]
        /// Transmission Trigger
        TX_TRIG: u4 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host PHY TX Triggers Configuration
    pub const DSI_PTTCR = Register(DSI_PTTCR_val).init(base_address + 0xac);

    /// DSI_PSR
    const DSI_PSR_val = packed struct {
        /// unused [0:0]
        _unused0: u1 = 0,
        /// PD [1:1]
        /// PHY Direction
        PD: u1 = 0,
        /// PSSC [2:2]
        /// PHY Stop State Clock lane
        PSSC: u1 = 0,
        /// UANC [3:3]
        /// ULPS Active Not Clock lane
        UANC: u1 = 0,
        /// PSS0 [4:4]
        /// PHY Stop State lane 0
        PSS0: u1 = 0,
        /// UAN0 [5:5]
        /// ULPS Active Not lane 1
        UAN0: u1 = 0,
        /// RUE0 [6:6]
        /// RX ULPS Escape lane 0
        RUE0: u1 = 0,
        /// PSS1 [7:7]
        /// PHY Stop State lane 1
        PSS1: u1 = 0,
        /// UAN1 [8:8]
        /// ULPS Active Not lane 1
        UAN1: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host PHY Status Register
    pub const DSI_PSR = Register(DSI_PSR_val).init(base_address + 0xb0);

    /// DSI_ISR0
    const DSI_ISR0_val = packed struct {
        /// AE0 [0:0]
        /// Acknowledge Error 0
        AE0: u1 = 0,
        /// AE1 [1:1]
        /// Acknowledge Error 1
        AE1: u1 = 0,
        /// AE2 [2:2]
        /// Acknowledge Error 2
        AE2: u1 = 0,
        /// AE3 [3:3]
        /// Acknowledge Error 3
        AE3: u1 = 0,
        /// AE4 [4:4]
        /// Acknowledge Error 4
        AE4: u1 = 0,
        /// AE5 [5:5]
        /// Acknowledge Error 5
        AE5: u1 = 0,
        /// AE6 [6:6]
        /// Acknowledge Error 6
        AE6: u1 = 0,
        /// AE7 [7:7]
        /// Acknowledge Error 7
        AE7: u1 = 0,
        /// AE8 [8:8]
        /// Acknowledge Error 8
        AE8: u1 = 0,
        /// AE9 [9:9]
        /// Acknowledge Error 9
        AE9: u1 = 0,
        /// AE10 [10:10]
        /// Acknowledge Error 10
        AE10: u1 = 0,
        /// AE11 [11:11]
        /// Acknowledge Error 11
        AE11: u1 = 0,
        /// AE12 [12:12]
        /// Acknowledge Error 12
        AE12: u1 = 0,
        /// AE13 [13:13]
        /// Acknowledge Error 13
        AE13: u1 = 0,
        /// AE14 [14:14]
        /// Acknowledge Error 14
        AE14: u1 = 0,
        /// AE15 [15:15]
        /// Acknowledge Error 15
        AE15: u1 = 0,
        /// PE0 [16:16]
        /// PHY Error 0
        PE0: u1 = 0,
        /// PE1 [17:17]
        /// PHY Error 1
        PE1: u1 = 0,
        /// PE2 [18:18]
        /// PHY Error 2
        PE2: u1 = 0,
        /// PE3 [19:19]
        /// PHY Error 3
        PE3: u1 = 0,
        /// PE4 [20:20]
        /// PHY Error 4
        PE4: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Interrupt &amp; Status Register
    pub const DSI_ISR0 = Register(DSI_ISR0_val).init(base_address + 0xbc);

    /// DSI_ISR1
    const DSI_ISR1_val = packed struct {
        /// TOHSTX [0:0]
        /// Timeout High-Speed
        TOHSTX: u1 = 0,
        /// TOLPRX [1:1]
        /// Timeout Low-Power
        TOLPRX: u1 = 0,
        /// ECCSE [2:2]
        /// ECC Single-bit Error
        ECCSE: u1 = 0,
        /// ECCME [3:3]
        /// ECC Multi-bit Error
        ECCME: u1 = 0,
        /// CRCE [4:4]
        /// CRC Error
        CRCE: u1 = 0,
        /// PSE [5:5]
        /// Packet Size Error
        PSE: u1 = 0,
        /// EOTPE [6:6]
        /// EoTp Error
        EOTPE: u1 = 0,
        /// LPWRE [7:7]
        /// LTDC Payload Write Error
        LPWRE: u1 = 0,
        /// GCWRE [8:8]
        /// Generic Command Write
        GCWRE: u1 = 0,
        /// GPWRE [9:9]
        /// Generic Payload Write
        GPWRE: u1 = 0,
        /// GPTXE [10:10]
        /// Generic Payload Transmit
        GPTXE: u1 = 0,
        /// GPRDE [11:11]
        /// Generic Payload Read Error
        GPRDE: u1 = 0,
        /// GPRXE [12:12]
        /// Generic Payload Receive
        GPRXE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Interrupt &amp; Status Register
    pub const DSI_ISR1 = Register(DSI_ISR1_val).init(base_address + 0xc0);

    /// DSI_IER0
    const DSI_IER0_val = packed struct {
        /// AE0IE [0:0]
        /// Acknowledge Error 0 Interrupt
        AE0IE: u1 = 0,
        /// AE1IE [1:1]
        /// Acknowledge Error 1 Interrupt
        AE1IE: u1 = 0,
        /// AE2IE [2:2]
        /// Acknowledge Error 2 Interrupt
        AE2IE: u1 = 0,
        /// AE3IE [3:3]
        /// Acknowledge Error 3 Interrupt
        AE3IE: u1 = 0,
        /// AE4IE [4:4]
        /// Acknowledge Error 4 Interrupt
        AE4IE: u1 = 0,
        /// AE5IE [5:5]
        /// Acknowledge Error 5 Interrupt
        AE5IE: u1 = 0,
        /// AE6IE [6:6]
        /// Acknowledge Error 6 Interrupt
        AE6IE: u1 = 0,
        /// AE7IE [7:7]
        /// Acknowledge Error 7 Interrupt
        AE7IE: u1 = 0,
        /// AE8IE [8:8]
        /// Acknowledge Error 8 Interrupt
        AE8IE: u1 = 0,
        /// AE9IE [9:9]
        /// Acknowledge Error 9 Interrupt
        AE9IE: u1 = 0,
        /// AE10IE [10:10]
        /// Acknowledge Error 10 Interrupt
        AE10IE: u1 = 0,
        /// AE11IE [11:11]
        /// Acknowledge Error 11 Interrupt
        AE11IE: u1 = 0,
        /// AE12IE [12:12]
        /// Acknowledge Error 12 Interrupt
        AE12IE: u1 = 0,
        /// AE13IE [13:13]
        /// Acknowledge Error 13 Interrupt
        AE13IE: u1 = 0,
        /// AE14IE [14:14]
        /// Acknowledge Error 14 Interrupt
        AE14IE: u1 = 0,
        /// AE15IE [15:15]
        /// Acknowledge Error 15 Interrupt
        AE15IE: u1 = 0,
        /// PE0IE [16:16]
        /// PHY Error 0 Interrupt
        PE0IE: u1 = 0,
        /// PE1IE [17:17]
        /// PHY Error 1 Interrupt
        PE1IE: u1 = 0,
        /// PE2IE [18:18]
        /// PHY Error 2 Interrupt
        PE2IE: u1 = 0,
        /// PE3IE [19:19]
        /// PHY Error 3 Interrupt
        PE3IE: u1 = 0,
        /// PE4IE [20:20]
        /// PHY Error 4 Interrupt
        PE4IE: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Interrupt Enable Register
    pub const DSI_IER0 = Register(DSI_IER0_val).init(base_address + 0xc4);

    /// DSI_IER1
    const DSI_IER1_val = packed struct {
        /// TOHSTXIE [0:0]
        /// Timeout High-Speed Transmission
        TOHSTXIE: u1 = 0,
        /// TOLPRXIE [1:1]
        /// Timeout Low-Power Reception Interrupt
        TOLPRXIE: u1 = 0,
        /// ECCSEIE [2:2]
        /// ECC Single-bit Error Interrupt
        ECCSEIE: u1 = 0,
        /// ECCMEIE [3:3]
        /// ECC Multi-bit Error Interrupt
        ECCMEIE: u1 = 0,
        /// CRCEIE [4:4]
        /// CRC Error Interrupt Enable
        CRCEIE: u1 = 0,
        /// PSEIE [5:5]
        /// Packet Size Error Interrupt
        PSEIE: u1 = 0,
        /// EOTPEIE [6:6]
        /// EoTp Error Interrupt
        EOTPEIE: u1 = 0,
        /// LPWREIE [7:7]
        /// LTDC Payload Write Error Interrupt
        LPWREIE: u1 = 0,
        /// GCWREIE [8:8]
        /// Generic Command Write Error Interrupt
        GCWREIE: u1 = 0,
        /// GPWREIE [9:9]
        /// Generic Payload Write Error Interrupt
        GPWREIE: u1 = 0,
        /// GPTXEIE [10:10]
        /// Generic Payload Transmit Error Interrupt
        GPTXEIE: u1 = 0,
        /// GPRDEIE [11:11]
        /// Generic Payload Read Error Interrupt
        GPRDEIE: u1 = 0,
        /// GPRXEIE [12:12]
        /// Generic Payload Receive Error Interrupt
        GPRXEIE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Interrupt Enable Register
    pub const DSI_IER1 = Register(DSI_IER1_val).init(base_address + 0xc8);

    /// DSI_FIR0
    const DSI_FIR0_val = packed struct {
        /// FAE0 [0:0]
        /// Force Acknowledge Error 0
        FAE0: u1 = 0,
        /// FAE1 [1:1]
        /// Force Acknowledge Error 1
        FAE1: u1 = 0,
        /// FAE2 [2:2]
        /// Force Acknowledge Error 2
        FAE2: u1 = 0,
        /// FAE3 [3:3]
        /// Force Acknowledge Error 3
        FAE3: u1 = 0,
        /// FAE4 [4:4]
        /// Force Acknowledge Error 4
        FAE4: u1 = 0,
        /// FAE5 [5:5]
        /// Force Acknowledge Error 5
        FAE5: u1 = 0,
        /// FAE6 [6:6]
        /// Force Acknowledge Error 6
        FAE6: u1 = 0,
        /// FAE7 [7:7]
        /// Force Acknowledge Error 7
        FAE7: u1 = 0,
        /// FAE8 [8:8]
        /// Force Acknowledge Error 8
        FAE8: u1 = 0,
        /// FAE9 [9:9]
        /// Force Acknowledge Error 9
        FAE9: u1 = 0,
        /// FAE10 [10:10]
        /// Force Acknowledge Error 10
        FAE10: u1 = 0,
        /// FAE11 [11:11]
        /// Force Acknowledge Error 11
        FAE11: u1 = 0,
        /// FAE12 [12:12]
        /// Force Acknowledge Error 12
        FAE12: u1 = 0,
        /// FAE13 [13:13]
        /// Force Acknowledge Error 13
        FAE13: u1 = 0,
        /// FAE14 [14:14]
        /// Force Acknowledge Error 14
        FAE14: u1 = 0,
        /// FAE15 [15:15]
        /// Force Acknowledge Error 15
        FAE15: u1 = 0,
        /// FPE0 [16:16]
        /// Force PHY Error 0
        FPE0: u1 = 0,
        /// FPE1 [17:17]
        /// Force PHY Error 1
        FPE1: u1 = 0,
        /// FPE2 [18:18]
        /// Force PHY Error 2
        FPE2: u1 = 0,
        /// FPE3 [19:19]
        /// Force PHY Error 3
        FPE3: u1 = 0,
        /// FPE4 [20:20]
        /// Force PHY Error 4
        FPE4: u1 = 0,
        /// unused [21:31]
        _unused21: u3 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Force Interrupt Register
    pub const DSI_FIR0 = Register(DSI_FIR0_val).init(base_address + 0xd8);

    /// DSI_FIR1
    const DSI_FIR1_val = packed struct {
        /// FTOHSTX [0:0]
        /// Force Timeout High-Speed
        FTOHSTX: u1 = 0,
        /// FTOLPRX [1:1]
        /// Force Timeout Low-Power
        FTOLPRX: u1 = 0,
        /// FECCSE [2:2]
        /// Force ECC Single-bit Error
        FECCSE: u1 = 0,
        /// FECCME [3:3]
        /// Force ECC Multi-bit Error
        FECCME: u1 = 0,
        /// FCRCE [4:4]
        /// Force CRC Error
        FCRCE: u1 = 0,
        /// FPSE [5:5]
        /// Force Packet Size Error
        FPSE: u1 = 0,
        /// FEOTPE [6:6]
        /// Force EoTp Error
        FEOTPE: u1 = 0,
        /// FLPWRE [7:7]
        /// Force LTDC Payload Write
        FLPWRE: u1 = 0,
        /// FGCWRE [8:8]
        /// Force Generic Command Write
        FGCWRE: u1 = 0,
        /// FGPWRE [9:9]
        /// Force Generic Payload Write
        FGPWRE: u1 = 0,
        /// FGPTXE [10:10]
        /// Force Generic Payload Transmit
        FGPTXE: u1 = 0,
        /// FGPRDE [11:11]
        /// Force Generic Payload Read
        FGPRDE: u1 = 0,
        /// FGPRXE [12:12]
        /// Force Generic Payload Receive
        FGPRXE: u1 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Force Interrupt Register
    pub const DSI_FIR1 = Register(DSI_FIR1_val).init(base_address + 0xdc);

    /// DSI_VSCR
    const DSI_VSCR_val = packed struct {
        /// EN [0:0]
        /// Enable
        EN: u1 = 0,
        /// unused [1:7]
        _unused1: u7 = 0,
        /// UR [8:8]
        /// Update Register
        UR: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Shadow Control
    pub const DSI_VSCR = Register(DSI_VSCR_val).init(base_address + 0x100);

    /// DSI_LCVCIDR
    const DSI_LCVCIDR_val = packed struct {
        /// VCID [0:1]
        /// Virtual Channel ID
        VCID: u2 = 0,
        /// unused [2:31]
        _unused2: u6 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC Current VCID
    pub const DSI_LCVCIDR = Register(DSI_LCVCIDR_val).init(base_address + 0x10c);

    /// DSI_LCCCR
    const DSI_LCCCR_val = packed struct {
        /// COLC [0:3]
        /// Color Coding
        COLC: u4 = 0,
        /// unused [4:7]
        _unused4: u4 = 0,
        /// LPE [8:8]
        /// Loosely Packed Enable
        LPE: u1 = 0,
        /// unused [9:31]
        _unused9: u7 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host LTDC Current Color Coding
    pub const DSI_LCCCR = Register(DSI_LCCCR_val).init(base_address + 0x110);

    /// DSI_LPMCCR
    const DSI_LPMCCR_val = packed struct {
        /// VLPSIZE [0:7]
        /// VACT Largest Packet Size
        VLPSIZE: u8 = 0,
        /// unused [8:15]
        _unused8: u8 = 0,
        /// LPSIZE [16:23]
        /// Largest Packet Size
        LPSIZE: u8 = 0,
        /// unused [24:31]
        _unused24: u8 = 0,
    };
    /// DSI Host Low-Power mode Current
    pub const DSI_LPMCCR = Register(DSI_LPMCCR_val).init(base_address + 0x118);

    /// DSI_VMCCR
    const DSI_VMCCR_val = packed struct {
        /// VMT [0:1]
        /// Video mode Type
        VMT: u2 = 0,
        /// LPVSAE [2:2]
        /// Low-Power Vertical Sync time
        LPVSAE: u1 = 0,
        /// LPVBPE [3:3]
        /// Low-power Vertical Back-Porch
        LPVBPE: u1 = 0,
        /// LPVFPE [4:4]
        /// Low-power Vertical Front-Porch
        LPVFPE: u1 = 0,
        /// LPVAE [5:5]
        /// Low-Power Vertical Active
        LPVAE: u1 = 0,
        /// LPHBPE [6:6]
        /// Low-power Horizontal Back-Porch
        LPHBPE: u1 = 0,
        /// LPHFE [7:7]
        /// Low-Power Horizontal Front-Porch
        LPHFE: u1 = 0,
        /// FBTAAE [8:8]
        /// Frame BTA Acknowledge
        FBTAAE: u1 = 0,
        /// LPCE [9:9]
        /// Low-Power Command Enable
        LPCE: u1 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video mode Current Configuration
    pub const DSI_VMCCR = Register(DSI_VMCCR_val).init(base_address + 0x138);

    /// DSI_VPCCR
    const DSI_VPCCR_val = packed struct {
        /// VPSIZE [0:13]
        /// Video Packet Size
        VPSIZE: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Packet Current Configuration
    pub const DSI_VPCCR = Register(DSI_VPCCR_val).init(base_address + 0x13c);

    /// DSI_VCCCR
    const DSI_VCCCR_val = packed struct {
        /// NUMC [0:12]
        /// Number of Chunks
        NUMC: u13 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Chunks Current Configuration
    pub const DSI_VCCCR = Register(DSI_VCCCR_val).init(base_address + 0x140);

    /// DSI_VNPCCR
    const DSI_VNPCCR_val = packed struct {
        /// NPSIZE [0:12]
        /// Null Packet Size
        NPSIZE: u13 = 0,
        /// unused [13:31]
        _unused13: u3 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Null Packet Current
    pub const DSI_VNPCCR = Register(DSI_VNPCCR_val).init(base_address + 0x144);

    /// DSI_VHSACCR
    const DSI_VHSACCR_val = packed struct {
        /// HSA [0:11]
        /// Horizontal Synchronism Active
        HSA: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video HSA Current Configuration
    pub const DSI_VHSACCR = Register(DSI_VHSACCR_val).init(base_address + 0x148);

    /// DSI_VHBPCCR
    const DSI_VHBPCCR_val = packed struct {
        /// HBP [0:11]
        /// Horizontal Back-Porch
        HBP: u12 = 0,
        /// unused [12:31]
        _unused12: u4 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video HBP Current Configuration
    pub const DSI_VHBPCCR = Register(DSI_VHBPCCR_val).init(base_address + 0x14c);

    /// DSI_VLCCR
    const DSI_VLCCR_val = packed struct {
        /// HLINE [0:14]
        /// Horizontal Line duration
        HLINE: u15 = 0,
        /// unused [15:31]
        _unused15: u1 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video Line Current Configuration
    pub const DSI_VLCCR = Register(DSI_VLCCR_val).init(base_address + 0x150);

    /// DSI_VVSACCR
    const DSI_VVSACCR_val = packed struct {
        /// VSA [0:9]
        /// Vertical Synchronism Active
        VSA: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VSA Current Configuration
    pub const DSI_VVSACCR = Register(DSI_VVSACCR_val).init(base_address + 0x154);

    /// DSI_VVBPCCR
    const DSI_VVBPCCR_val = packed struct {
        /// VBP [0:9]
        /// Vertical Back-Porch
        VBP: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VBP Current Configuration
    pub const DSI_VVBPCCR = Register(DSI_VVBPCCR_val).init(base_address + 0x158);

    /// DSI_VVFPCCR
    const DSI_VVFPCCR_val = packed struct {
        /// VFP [0:9]
        /// Vertical Front-Porch
        VFP: u10 = 0,
        /// unused [10:31]
        _unused10: u6 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VFP Current Configuration
    pub const DSI_VVFPCCR = Register(DSI_VVFPCCR_val).init(base_address + 0x15c);

    /// DSI_VVACCR
    const DSI_VVACCR_val = packed struct {
        /// VA [0:13]
        /// Vertical Active duration
        VA: u14 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Host Video VA Current Configuration
    pub const DSI_VVACCR = Register(DSI_VVACCR_val).init(base_address + 0x160);

    /// DSI_WCFGR
    const DSI_WCFGR_val = packed struct {
        /// DSIM [0:0]
        /// DSI Mode
        DSIM: u1 = 0,
        /// COLMUX [1:3]
        /// Color Multiplexing
        COLMUX: u3 = 0,
        /// TESRC [4:4]
        /// TE Source
        TESRC: u1 = 0,
        /// TEPOL [5:5]
        /// TE Polarity
        TEPOL: u1 = 0,
        /// AR [6:6]
        /// Automatic Refresh
        AR: u1 = 0,
        /// VSPOL [7:7]
        /// VSync Polarity
        VSPOL: u1 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper Configuration
    pub const DSI_WCFGR = Register(DSI_WCFGR_val).init(base_address + 0x400);

    /// DSI_WCR
    const DSI_WCR_val = packed struct {
        /// COLM [0:0]
        /// Color Mode
        COLM: u1 = 0,
        /// SHTDN [1:1]
        /// Shutdown
        SHTDN: u1 = 0,
        /// LTDCEN [2:2]
        /// LTDC Enable
        LTDCEN: u1 = 0,
        /// DSIEN [3:3]
        /// DSI Enable
        DSIEN: u1 = 0,
        /// unused [4:31]
        _unused4: u4 = 0,
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper Control Register
    pub const DSI_WCR = Register(DSI_WCR_val).init(base_address + 0x404);

    /// DSI_WIER
    const DSI_WIER_val = packed struct {
        /// TEIE [0:0]
        /// Tearing Effect Interrupt
        TEIE: u1 = 0,
        /// ERIE [1:1]
        /// End of Refresh Interrupt
        ERIE: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// PLLLIE [9:9]
        /// PLL Lock Interrupt Enable
        PLLLIE: u1 = 0,
        /// PLLUIE [10:10]
        /// PLL Unlock Interrupt
        PLLUIE: u1 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// RRIE [13:13]
        /// Regulator Ready Interrupt
        RRIE: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper Interrupt Enable
    pub const DSI_WIER = Register(DSI_WIER_val).init(base_address + 0x408);

    /// DSI_WISR
    const DSI_WISR_val = packed struct {
        /// TEIF [0:0]
        /// Tearing Effect Interrupt
        TEIF: u1 = 0,
        /// ERIF [1:1]
        /// End of Refresh Interrupt
        ERIF: u1 = 0,
        /// BUSY [2:2]
        /// Busy Flag
        BUSY: u1 = 0,
        /// unused [3:7]
        _unused3: u5 = 0,
        /// PLLLS [8:8]
        /// PLL Lock Status
        PLLLS: u1 = 0,
        /// PLLLIF [9:9]
        /// PLL Lock Interrupt Flag
        PLLLIF: u1 = 0,
        /// PLLUIF [10:10]
        /// PLL Unlock Interrupt Flag
        PLLUIF: u1 = 0,
        /// unused [11:11]
        _unused11: u1 = 0,
        /// RRS [12:12]
        /// Regulator Ready Status
        RRS: u1 = 0,
        /// RRIF [13:13]
        /// Regulator Ready Interrupt
        RRIF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper Interrupt &amp; Status
    pub const DSI_WISR = Register(DSI_WISR_val).init(base_address + 0x40c);

    /// DSI_WIFCR
    const DSI_WIFCR_val = packed struct {
        /// CTEIF [0:0]
        /// Clear Tearing Effect Interrupt
        CTEIF: u1 = 0,
        /// CERIF [1:1]
        /// Clear End of Refresh Interrupt
        CERIF: u1 = 0,
        /// unused [2:8]
        _unused2: u6 = 0,
        _unused8: u1 = 0,
        /// CPLLLIF [9:9]
        /// Clear PLL Lock Interrupt
        CPLLLIF: u1 = 0,
        /// CPLLUIF [10:10]
        /// Clear PLL Unlock Interrupt
        CPLLUIF: u1 = 0,
        /// unused [11:12]
        _unused11: u2 = 0,
        /// CRRIF [13:13]
        /// Clear Regulator Ready Interrupt
        CRRIF: u1 = 0,
        /// unused [14:31]
        _unused14: u2 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper Interrupt Flag Clear
    pub const DSI_WIFCR = Register(DSI_WIFCR_val).init(base_address + 0x410);

    /// DSI_WPCR1
    const DSI_WPCR1_val = packed struct {
        /// UIX4 [0:5]
        /// Unit Interval multiplied by
        UIX4: u6 = 0,
        /// SWCL [6:6]
        /// Swap Clock Lane pins
        SWCL: u1 = 0,
        /// SWDL0 [7:7]
        /// Swap Data Lane 0 pins
        SWDL0: u1 = 0,
        /// SWDL1 [8:8]
        /// Swap Data Lane 1 pins
        SWDL1: u1 = 0,
        /// HSICL [9:9]
        /// Invert Hight-Speed data signal on Clock
        HSICL: u1 = 0,
        /// HSIDL0 [10:10]
        /// Invert the Hight-Speed data signal on
        HSIDL0: u1 = 0,
        /// HSIDL1 [11:11]
        /// Invert the High-Speed data signal on
        HSIDL1: u1 = 0,
        /// FTXSMCL [12:12]
        /// Force in TX Stop Mode the Clock
        FTXSMCL: u1 = 0,
        /// FTXSMDL [13:13]
        /// Force in TX Stop Mode the Data
        FTXSMDL: u1 = 0,
        /// CDOFFDL [14:14]
        /// Contention Detection OFF on Data
        CDOFFDL: u1 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// TDDL [16:16]
        /// Turn Disable Data Lanes
        TDDL: u1 = 0,
        /// unused [17:17]
        _unused17: u1 = 0,
        /// PDEN [18:18]
        /// Pull-Down Enable
        PDEN: u1 = 0,
        /// TCLKPREPEN [19:19]
        /// custom time for tCLK-PREPARE
        TCLKPREPEN: u1 = 0,
        /// TCLKZEROEN [20:20]
        /// custom time for tCLK-ZERO
        TCLKZEROEN: u1 = 0,
        /// THSPREPEN [21:21]
        /// custom time for tHS-PREPARE
        THSPREPEN: u1 = 0,
        /// THSTRAILEN [22:22]
        /// custom time for tHS-TRAIL
        THSTRAILEN: u1 = 0,
        /// THSZEROEN [23:23]
        /// custom time for tHS-ZERO
        THSZEROEN: u1 = 0,
        /// TLPXDEN [24:24]
        /// custom time for tLPX for Data lanes
        TLPXDEN: u1 = 0,
        /// THSEXITEN [25:25]
        /// custom time for tHS-EXIT
        THSEXITEN: u1 = 0,
        /// TLPXCEN [26:26]
        /// custom time for tLPX for Clock lane
        TLPXCEN: u1 = 0,
        /// TCLKPOSTEN [27:27]
        /// custom time for tCLK-POST
        TCLKPOSTEN: u1 = 0,
        /// unused [28:31]
        _unused28: u4 = 0,
    };
    /// DSI Wrapper PHY Configuration Register
    pub const DSI_WPCR1 = Register(DSI_WPCR1_val).init(base_address + 0x418);

    /// DSI_WPCR2
    const DSI_WPCR2_val = packed struct {
        /// HSTXDCL [0:1]
        /// High-Speed Transmission Delay on Clock
        HSTXDCL: u2 = 0,
        /// HSTXDLL [2:3]
        /// High-Speed Transmission Delay on Data
        HSTXDLL: u2 = 0,
        /// unused [4:5]
        _unused4: u2 = 0,
        /// LPSRCL [6:7]
        /// Low-Power transmission Slew Rate
        LPSRCL: u2 = 0,
        /// LPSRDL [8:9]
        /// Low-Power transmission Slew Rate
        LPSRDL: u2 = 0,
        /// unused [10:11]
        _unused10: u2 = 0,
        /// SDCC [12:12]
        /// SDD Control
        SDCC: u1 = 0,
        /// unused [13:15]
        _unused13: u3 = 0,
        /// HSTXSRCCL [16:17]
        /// High-Speed Transmission Slew Rate
        HSTXSRCCL: u2 = 0,
        /// HSTXSRCDL [18:19]
        /// High-Speed Transmission Slew Rate
        HSTXSRCDL: u2 = 0,
        /// unused [20:21]
        _unused20: u2 = 0,
        /// FLPRXLPM [22:22]
        /// Forces LP Receiver in Low-Power
        FLPRXLPM: u1 = 0,
        /// unused [23:24]
        _unused23: u1 = 0,
        _unused24: u1 = 0,
        /// LPRXFT [25:26]
        /// Low-Power RX low-pass Filtering
        LPRXFT: u2 = 0,
        /// unused [27:31]
        _unused27: u5 = 0,
    };
    /// DSI Wrapper PHY Configuration Register
    pub const DSI_WPCR2 = Register(DSI_WPCR2_val).init(base_address + 0x41c);

    /// DSI_WPCR3
    const DSI_WPCR3_val = packed struct {
        /// TCLKPREP [0:7]
        /// tCLK-PREPARE
        TCLKPREP: u8 = 0,
        /// TCLKZEO [8:15]
        /// tCLK-ZERO
        TCLKZEO: u8 = 0,
        /// THSPREP [16:23]
        /// tHS-PREPARE
        THSPREP: u8 = 0,
        /// THSTRAIL [24:31]
        /// tHSTRAIL
        THSTRAIL: u8 = 0,
    };
    /// DSI Wrapper PHY Configuration Register
    pub const DSI_WPCR3 = Register(DSI_WPCR3_val).init(base_address + 0x420);

    /// DSI_WPCR4
    const DSI_WPCR4_val = packed struct {
        /// THSZERO [0:7]
        /// tHS-ZERO
        THSZERO: u8 = 42,
        /// TLPXD [8:15]
        /// tLPX for Data lanes
        TLPXD: u8 = 48,
        /// THSEXIT [16:23]
        /// tHSEXIT
        THSEXIT: u8 = 51,
        /// TLPXC [24:31]
        /// tLPXC for Clock lane
        TLPXC: u8 = 49,
    };
    /// DSI_WPCR4
    pub const DSI_WPCR4 = Register(DSI_WPCR4_val).init(base_address + 0x424);

    /// DSI_WPCR5
    const DSI_WPCR5_val = packed struct {
        /// THSZERO [0:7]
        /// tCLK-POST
        THSZERO: u8 = 0,
        /// unused [8:31]
        _unused8: u8 = 0,
        _unused16: u8 = 0,
        _unused24: u8 = 0,
    };
    /// DSI Wrapper PHY Configuration Register
    pub const DSI_WPCR5 = Register(DSI_WPCR5_val).init(base_address + 0x428);

    /// DSI_WRPCR
    const DSI_WRPCR_val = packed struct {
        /// PLLEN [0:0]
        /// PLL Enable
        PLLEN: u1 = 0,
        /// unused [1:1]
        _unused1: u1 = 0,
        /// NDIV [2:8]
        /// PLL Loop Division Factor
        NDIV: u7 = 0,
        /// unused [9:10]
        _unused9: u2 = 0,
        /// IDF [11:14]
        /// PLL Input Division Factor
        IDF: u4 = 0,
        /// unused [15:15]
        _unused15: u1 = 0,
        /// ODF [16:17]
        /// PLL Output Division Factor
        ODF: u2 = 0,
        /// unused [18:23]
        _unused18: u6 = 0,
        /// REGEN [24:24]
        /// Regulator Enable
        REGEN: u1 = 0,
        /// unused [25:31]
        _unused25: u7 = 0,
    };
    /// DSI Wrapper Regulator and PLL Control
    pub const DSI_WRPCR = Register(DSI_WRPCR_val).init(base_address + 0x430);
};

/// MCU debug component
pub const DBGMCU = struct {
    const base_address = 0xe0042000;
    /// IDCODE
    const IDCODE_val = packed struct {
        /// DEV_ID [0:11]
        /// Device identifier
        DEV_ID: u12 = 0,
        /// unused [12:15]
        _unused12: u4 = 0,
        /// REV_ID [16:31]
        /// Revision identifie
        REV_ID: u16 = 0,
    };
    /// DBGMCU_IDCODE
    pub const IDCODE = Register(IDCODE_val).init(base_address + 0x0);
};
pub const interrupts = struct {
    pub const UART7 = 82;
    pub const CAN3_RX1 = 106;
    pub const OTG_FS_WKUP = 42;
    pub const I2C2_EV = 33;
    pub const DFSDM1_FLT0 = 99;
    pub const DMA2_Stream6 = 69;
    pub const SAI2 = 91;
    pub const LP_Timer1 = 93;
    pub const DMA2_Stream7 = 70;
    pub const TIM3 = 29;
    pub const USART6 = 71;
    pub const SPI2 = 36;
    pub const DMA1_Stream6 = 17;
    pub const CAN1_RX0 = 20;
    pub const MDIOS = 109;
    pub const DMA1_Stream5 = 16;
    pub const EXTI1 = 7;
    pub const DMA1_Stream3 = 14;
    pub const I2C1_ER = 32;
    pub const SPI4 = 84;
    pub const DSIHOST = 98;
    pub const DMA2_Stream4 = 60;
    pub const TIM5 = 50;
    pub const CAN3_RX0 = 105;
    pub const CAN1_SCE = 22;
    pub const CAN2_RX0 = 64;
    pub const DMA2D = 90;
    pub const DFSDM1_FLT1 = 100;
    pub const DMA1_Stream2 = 13;
    pub const WWDG = 0;
    pub const UART8 = 83;
    pub const TIM1_BRK_TIM9 = 24;
    pub const ETH_WKUP = 62;
    pub const SPDIFRX = 97;
    pub const SDMMC2 = 103;
    pub const I2C4_EV = 95;
    pub const DMA2_Stream2 = 58;
    pub const PVD = 1;
    pub const TIM8_TRG_COM_TIM14 = 45;
    pub const EXTI15_10 = 40;
    pub const SPI3 = 51;
    pub const OTG_FS = 67;
    pub const QuadSPI = 92;
    pub const RTC_ALARM = 41;
    pub const OTG_HS = 77;
    pub const DMA1_Stream7 = 47;
    pub const SPI6 = 86;
    pub const DMA1_Stream1 = 12;
    pub const FLASH = 4;
    pub const DMA2_Stream5 = 68;
    pub const DMA2_Stream0 = 56;
    pub const EXTI3 = 9;
    pub const DFSDM1_FLT3 = 102;
    pub const TIM2 = 28;
    pub const OTG_HS_WKUP = 76;
    pub const I2C3_EV = 72;
    pub const SPI5 = 85;
    pub const RCC = 5;
    pub const LCD_TFT_1 = 89;
    pub const TIM1_CC = 27;
    pub const TIM7 = 55;
    pub const USART1 = 37;
    pub const DFSDM1_FLT2 = 101;
    pub const OTG_HS_EP1_OUT = 74;
    pub const JPEG = 108;
    pub const ETH = 61;
    pub const DMA1_Stream4 = 15;
    pub const TIM8_CC = 46;
    pub const TIM6_DAC = 54;
    pub const I2C3_ER = 73;
    pub const HASH_RNG = 80;
    pub const ADC = 18;
    pub const CAN2_RX1 = 65;
    pub const CAN3_TX = 104;
    pub const TIM8_UP_TIM13 = 44;
    pub const DMA2_Stream3 = 59;
    pub const TIM8_BRK_TIM12 = 43;
    pub const CAN2_TX = 63;
    pub const EXTI4 = 10;
    pub const SPI1 = 35;
    pub const UART4 = 52;
    pub const RTC_WKUP = 3;
    pub const TIM4 = 30;
    pub const DMA1_Stream0 = 11;
    pub const CAN2_SCE = 66;
    pub const LCD_TFT = 88;
    pub const USART2 = 38;
    pub const FMC = 48;
    pub const DMA2_Stream1 = 57;
    pub const EXTI0 = 6;
    pub const SDMMC1 = 49;
    pub const CAN1_RX1 = 21;
    pub const I2C2_ER = 34;
    pub const TIM1_TRG_COM_TIM11 = 26;
    pub const I2C1_EV = 31;
    pub const DCMI = 78;
    pub const CRYP = 79;
    pub const I2C4_ER = 96;
    pub const OTG_HS_EP1_IN = 75;
    pub const USART3 = 39;
    pub const CAN1_TX = 19;
    pub const UART5 = 53;
    pub const TIM1_UP_TIM10 = 25;
    pub const CAN3_SCE = 107;
    pub const TAMP_STAMP = 2;
    pub const EXTI9_5 = 23;
    pub const EXTI2 = 8;
    pub const SAI1 = 87;
};

// Added NVIC
pub const NVIC = struct {
    const base_address = 0xE000E000;
    //NVIC_ISER0
    const ISER0_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER0 = Register(ISER0_val).init(base_address + 0x100);
    //NVIC_ISER1
    const ISER1_val = packed struct {
        SETENA32: u1 = 0,
        SETENA33: u1 = 0,
        SETENA34: u1 = 0,
        SETENA35: u1 = 0,
        SETENA36: u1 = 0,
        SETENA37: u1 = 0,
        SETENA38: u1 = 0,
        SETENA39: u1 = 0,
        SETENA40: u1 = 0,
        SETENA41: u1 = 0,
        SETENA42: u1 = 0,
        SETENA43: u1 = 0,
        SETENA44: u1 = 0,
        SETENA45: u1 = 0,
        SETENA46: u1 = 0,
        SETENA47: u1 = 0,
        SETENA48: u1 = 0,
        SETENA49: u1 = 0,
        SETENA50: u1 = 0,
        SETENA51: u1 = 0,
        SETENA52: u1 = 0,
        SETENA53: u1 = 0,
        SETENA54: u1 = 0,
        SETENA55: u1 = 0,
        SETENA56: u1 = 0,
        SETENA57: u1 = 0,
        SETENA58: u1 = 0,
        SETENA59: u1 = 0,
        SETENA60: u1 = 0,
        SETENA61: u1 = 0,
        SETENA62: u1 = 0,
        SETENA63: u1 = 0,
    };
    pub const ISER1 = Register(ISER1_val).init(base_address + 0x104);
    //NVIC_ISER2
    const ISER2_val = packed struct {
        SETENA64: u1 = 0,
        SETENA65: u1 = 0,
        SETENA66: u1 = 0,
        SETENA67: u1 = 0,
        SETENA68: u1 = 0,
        SETENA69: u1 = 0,
        SETENA70: u1 = 0,
        SETENA71: u1 = 0,
        SETENA72: u1 = 0,
        SETENA73: u1 = 0,
        SETENA74: u1 = 0,
        SETENA75: u1 = 0,
        SETENA76: u1 = 0,
        SETENA77: u1 = 0,
        SETENA78: u1 = 0,
        SETENA79: u1 = 0,
        SETENA80: u1 = 0,
        SETENA81: u1 = 0,
        SETENA82: u1 = 0,
        SETENA83: u1 = 0,
        SETENA84: u1 = 0,
        SETENA85: u1 = 0,
        SETENA86: u1 = 0,
        SETENA87: u1 = 0,
        SETENA88: u1 = 0,
        SETENA89: u1 = 0,
        SETENA90: u1 = 0,
        SETENA91: u1 = 0,
        SETENA92: u1 = 0,
        SETENA93: u1 = 0,
        SETENA94: u1 = 0,
        SETENA95: u1 = 0,
    };
    pub const ISER2 = Register(ISER2_val).init(base_address + 0x108);
    //NVIC_ISER3
    const ISER3_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER3 = Register(ISER3_val).init(base_address + 0x10C);
    //NVIC_ISER4
    const ISER4_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER4 = Register(ISER4_val).init(base_address + 0x110);
    //NVIC_ISER5
    const ISER5_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER5 = Register(ISER5_val).init(base_address + 0x114);
    //NVIC_ISER6
    const ISER6_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER6 = Register(ISER6_val).init(base_address + 0x118);
    //NVIC_ISER7
    const ISER7_val = packed struct {
        SETENA0: u1 = 0,
        SETENA1: u1 = 0,
        SETENA2: u1 = 0,
        SETENA3: u1 = 0,
        SETENA4: u1 = 0,
        SETENA5: u1 = 0,
        SETENA6: u1 = 0,
        SETENA7: u1 = 0,
        SETENA8: u1 = 0,
        SETENA9: u1 = 0,
        SETENA10: u1 = 0,
        SETENA11: u1 = 0,
        SETENA12: u1 = 0,
        SETENA13: u1 = 0,
        SETENA14: u1 = 0,
        SETENA15: u1 = 0,
        SETENA16: u1 = 0,
        SETENA17: u1 = 0,
        SETENA18: u1 = 0,
        SETENA19: u1 = 0,
        SETENA20: u1 = 0,
        SETENA21: u1 = 0,
        SETENA22: u1 = 0,
        SETENA23: u1 = 0,
        SETENA24: u1 = 0,
        SETENA25: u1 = 0,
        SETENA26: u1 = 0,
        SETENA27: u1 = 0,
        SETENA28: u1 = 0,
        SETENA29: u1 = 0,
        SETENA30: u1 = 0,
        SETENA31: u1 = 0,
    };
    pub const ISER7 = Register(ISER7_val).init(base_address + 0x11C);
    //NVIC_ICER0
    const ICER0_val = packed struct {
        CLRENA0: u1 = 0,
        CLRENA1: u1 = 0,
        CLRENA2: u1 = 0,
        CLRENA3: u1 = 0,
        CLRENA4: u1 = 0,
        CLRENA5: u1 = 0,
        CLRENA6: u1 = 0,
        CLRENA7: u1 = 0,
        CLRENA8: u1 = 0,
        CLRENA9: u1 = 0,
        CLRENA10: u1 = 0,
        CLRENA11: u1 = 0,
        CLRENA12: u1 = 0,
        CLRENA13: u1 = 0,
        CLRENA14: u1 = 0,
        CLRENA15: u1 = 0,
        CLRENA16: u1 = 0,
        CLRENA17: u1 = 0,
        CLRENA18: u1 = 0,
        CLRENA19: u1 = 0,
        CLRENA20: u1 = 0,
        CLRENA21: u1 = 0,
        CLRENA22: u1 = 0,
        CLRENA23: u1 = 0,
        CLRENA24: u1 = 0,
        CLRENA25: u1 = 0,
        CLRENA26: u1 = 0,
        CLRENA27: u1 = 0,
        CLRENA28: u1 = 0,
        CLRENA29: u1 = 0,
        CLRENA30: u1 = 0,
        CLRENA31: u1 = 0,
    };
    pub const ICER0 = Register(ICER0_val).init(base_address + 0x180);
    const ICER2_val = packed struct {
        CLRENA64: u1 = 0,
        CLRENA65: u1 = 0,
        CLRENA66: u1 = 0,
        CLRENA67: u1 = 0,
        CLRENA68: u1 = 0,
        CLRENA69: u1 = 0,
        CLRENA70: u1 = 0,
        CLRENA71: u1 = 0,
        CLRENA72: u1 = 0,
        CLRENA73: u1 = 0,
        CLRENA74: u1 = 0,
        CLRENA75: u1 = 0,
        CLRENA76: u1 = 0,
        CLRENA77: u1 = 0,
        CLRENA78: u1 = 0,
        CLRENA79: u1 = 0,
        CLRENA80: u1 = 0,
        CLRENA81: u1 = 0,
        CLRENA82: u1 = 0,
        CLRENA83: u1 = 0,
        CLRENA84: u1 = 0,
        CLRENA85: u1 = 0,
        CLRENA86: u1 = 0,
        CLRENA87: u1 = 0,
        CLRENA88: u1 = 0,
        CLRENA89: u1 = 0,
        CLRENA90: u1 = 0,
        CLRENA91: u1 = 0,
        CLRENA92: u1 = 0,
        CLRENA93: u1 = 0,
        CLRENA94: u1 = 0,
        CLRENA95: u1 = 0,
    };
    pub const ICER2 = Register(ICER2_val).init(base_address + 0x188);
    //NVIC_IPR0
    const IPR0_val = packed struct {
        PRIN0: u8 = 0,
        PRIN1: u8 = 0,
        PRIN2: u8 = 0,
        PRIN3: u8 = 0,
    };
    pub const IPR0 = Register(IPR0_val).init(base_address + 0x400);
    //NVIC_IPR16, OTG_FS global is IRQ67
    const IPR16_val = packed struct {
        PRIN64: u8 = 0,
        PRIN65: u8 = 0,
        PRIN66: u8 = 0,
        PRIN67: u8 = 0,
    };
    pub const IPR16 = Register(IPR16_val).init(base_address + 0x458);
};

//Added System Control Block
pub const SCB = struct {
    const base_address = 0xE000E000;

    //SCB_ACTLR Auxiliary control register
    const ACTLR_val = packed struct {
        _unused0: u2 = 0,
        DISFOLD: u1 = 0,
        _unused3: u7 = 0,
        FPEXCODIS: u1 = 0,
        DISRAMODE: u1 = 0,
        DISITMATBFLUSH: u1 = 0,
        _unused13: u19 = 0,
    };
    pub const ACTLR = Register(ACTLR_val).init(base_address + 0x8);
};
